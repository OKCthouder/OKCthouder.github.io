<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Windows命令行神器Cmder]]></title>
    <url>%2F2018%2F09%2F11%2FWindows%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%A5%9E%E5%99%A8Cmder%2F</url>
    <content type="text"><![CDATA[简介cmder是一个增强型命令行工具，不仅可以使用windows下的所有命令，更爽的是可以使用linux的命令,shell命令。 下载官网地址：http://cmder.net/ 下载的时候，会有两个版本，分别是mini与full版；唯一的差别在于有没有内建msysgit工具，这是Git for Windows的标准配备；全安装版 cmder 自带了 msysgit, 压缩包 23M, 除了 git 本身这个命令之外, 里面可以使用大量的 linux 命令；比如 grep, curl(没有 wget)； 像vim, grep, tar, unzip, ssh, ls, bash, perl 对于爱折腾的Coder更是痛点需求。 安装直接解压到某个目录就可以了，点击Cmder.exe运行。 配置环境变量在系统变量添加 变量名： CMDER_HOME 变量值： 安装绝对路径 最后在Path添加一条斜体文字%CMDER_HOME% 添加 cmder 到右键菜单配置环境变量后，在管理员权限的终端输入以下语句。Win8或者Win10可以直接 win+x 再按 a 键进入。 1Cmder.exe /REGISTER ALL 配置好后，任意文件夹右键 新标签打开个管理员权限终端快捷键 Ctrl + t 后勾选 设置快捷键：win + alt + p或者在右下角图标，右击 设置bash作为默认开启的选项 解决中文乱码问题之前在网找了好多方法，可是都解决不了，很多人在在Environment里添加set LANG=zh_CN.UTF-8来解决中文乱码的问题，可是我用这个方法并没有成功，可能是环境的原因吧，我的系统是win10的。最后找到解决办法：Settings-&gt;Startup-&gt;Environment 添加set LANG=zh_CN.UTF-8set LC_ALL=zh_CN.utf8 重启Cmder，发现使用ls，中文正确显示了。 更改背景 更换主题内置了几款不错的主题，当然如果你觉得不合适，当然也支持自己设定。 常用功能介绍 如上图示编号的部分说明如下： 1, Cmder常用快捷键 利用Tab，自动路径补全； 利用Ctrl+T建立新页签；利用Ctrl+W关闭页签; 利用Ctrl+Tab切换页签; Alt+F4：关闭所有页签 Alt+Shift+1：开启cmd.exe Alt+Shift+2：开启powershell.exe Alt+Shift+3：开启powershell.exe (系统管理员权限) Ctrl+1：快速切换到第1个页签 Ctrl+n：快速切换到第n个页签( n值无上限) Alt + enter： 切换到全屏状态； Ctr+r 历史命令搜索 2, 可在视窗内搜寻画面上出现过的任意关键字。 3, 新增页签按钮。 4, 切换页签按钮。 5, 锁定视窗，让视窗无法再输入。 6, 切换视窗是否提供卷轴功能，启动时可查询之前显示过的内容。 7, 按下滑鼠左键可开启系统选单，滑鼠右键可开启工具选项视窗。 Win+Alt+P ：开启工具选项视窗。]]></content>
      <categories>
        <category>小工具</category>
      </categories>
      <tags>
        <tag>Windows</tag>
        <tag>Cmder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cookie 和session 的区别详解]]></title>
    <url>%2F2018%2F09%2F10%2Fcookie-and-session%2F</url>
    <content type="text"><![CDATA[二者的定义：​ 当你在浏览网站的时候，WEB 服务器会先送一小小资料放在你的计算机上，Cookie 会帮你在网站上所打的文字或是一些选择都纪录下来。当下次你再光临同一个网站，WEB 服务器会先看看有没有它上次留下的 Cookie 资料，有的话，就会依据 Cookie里的内容来判断使用者，送出特定的网页内容给你。 Cookie 的使用很普遍，许多有提供个人化服务的网站，都是利用 Cookie来辨认使用者，以方便送出使用者量身定做的内容，像是 Web 接口的免费 email 网站，都要用到 Cookie。 ​ 具体来说cookie机制采用的是在客户端保持状态的方案，而session机制采用的是在服务器端保持状态的方案。 ​ 同时我们也看到，由于采用服务器端保持状态的方案在客户端也需要保存一个标识，所以session机制可能需要借助于cookie机制来达到保存标识的目的，但实际上它还有其他选择。 ​ cookie机制。正统的cookie分发是通过扩展HTTP协议来实现的，服务器通过在HTTP的响应头中加上一行特殊的指示以提示浏览器按照指示生成相应的cookie。然而纯粹的客户端脚本如JavaScript或者VBScript也可以生成cookie。而cookie的使用是由浏览器按照一定的原则在后台自动发送给服务器的。浏览器检查所有存储的cookie，如果某个cookie所声明的作用范围大于等于将要请求的资源所在的位置，则把该cookie附在请求资源的HTTP请求头上发送给服务器。​ cookie的内容主要包括：名字，值，过期时间，路径和域。路径与域一起构成cookie的作用范围。若不设置过期时间，则表示这个cookie的生命期为浏览器会话期间，关闭浏览器窗口，cookie就消失。这种生命期为浏览器会话期的cookie被称为会话cookie。 ​ 会话cookie一般不存储在硬盘上而是保存在内存里，当然这种行为并不是规范规定的。若设置了过期时间，浏览器就会把cookie保存到硬盘上，关闭后再次打开浏览器，这些cookie仍然有效直到超过设定的过期时间。存储在硬盘上的cookie可以在不同的浏览器进程间共享，比如两个IE窗口。而对于保存在内存里的cookie，不同的浏览器有不同的处理方式session机制。session机制是一种服务器端的机制，服务器使用一种类似于散列表的结构（也可能就是使用散列表）来保存信息。 ​ 当程序需要为某个客户端的请求创建一个session时，服务器首先检查这个客户端的请求里是否已包含了一个session标识（称为session id），如果已包含则说明以前已经为此客户端创建过session，服务器就按照session id把这个session检索出来使用（检索不到，会新建一个），如果客户端请求不包含session id，则为此客户端创建一个session并且生成一个与此session相关联的session id，session id的值应该是一个既不会重复，又不容易被找到规律以仿造的字符串，这个session id将被在本次响应中返回给客户端保存。保存这个session id的方式可以采用cookie，这样在交互过程中浏览器可以自动的按照规则把这个标识发送给服务器。一般这个cookie的名字都是类似于SEEESIONID。但cookie可以被人为的禁止，则必须有其他机制以便在cookie被禁止时仍然能够把session id传递回服务器。经常被使用的一种技术叫做URL重写，就是把session id直接附加在URL路径的后面。还有一种技术叫做表单隐藏字段。就是服务器会自动修改表单，添加一个隐藏字段，以便在表单提交时能够把session id传递回服务器。比如： 1234567&lt;form name="testform" action="/xxx"&gt; &lt;input type="hidden" name="jsessionid" value="ByOK3vjFD75aPnrF7C2HmdnV6QZcEbzWoWiBYEnLerjQ99zWpBng!-145788764"&gt; &lt;input type="text"&gt; &lt;/form&gt; 实际上这种技术可以简单的用对action应用URL重写来代替。 cookie 和session 的区别： 1、cookie数据存放在客户的浏览器上，session数据放在服务器上。 2、cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗 考虑到安全应当使用session。 3、session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能 考虑到减轻服务器性能方面，应当使用COOKIE。 4、单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。 5、所以个人建议： 将登陆信息等重要信息存放为SESSION 其他信息如果需要保留，可以放在COOKIE中]]></content>
      <categories>
        <category>面试小问题</category>
      </categories>
      <tags>
        <tag>cookie</tag>
        <tag>session</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[超详细Git教程]]></title>
    <url>%2F2018%2F09%2F08%2F%E8%B6%85%E8%AF%A6%E7%BB%86Git%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[Git是什么Git是目前世界上最先进的分布式版本控制系统。 SVN与Git的最主要的区别SVN是集中式版本控制系统，版本库是集中放在中央服务器的，而干活的时候，用的都是自己的电脑，所以首先要从中央服务器哪里得到最新的版本，然后干活，干完后，需要把自己做完的活推送到中央服务器。集中式版本控制系统是必须联网才能工作，如果在局域网还可以，带宽够大，速度够快，如果在互联网下，如果网速慢的话，就纳闷了。 ​ Git是分布式版本控制系统，那么它就没有中央服务器的，每个人的电脑就是一个完整的版本库，这样，工作的时候就不需要联网了，因为版本都是在自己的电脑上。既然每个人的电脑都有一个完整的版本库，那多个人如何协作呢？比如说自己在电脑上改了文件A，其他人也在电脑上改了文件A，这时，你们两之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。 在windows上如何安装Git http://pan.baidu.com/s/1bpqprob （点此可直接下载安装，建议默认安装，不要改动安装路径） 需要从网上下载一个，然后进行默认安装即可。安装完成后，在开始菜单里面找到 “Git –&gt; Git Bash”,如下： 会弹出一个类似的命令窗口的东西，就说明Git安装成功。如下： 安装完成后，还需要最后一步设置，在命令行输入如下： 因为Git是分布式版本控制系统，所以需要填写用户名和邮箱作为一个标识。 注意：git config –global 参数，有了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然你也可以对某个仓库指定的不同的用户名和邮箱。 然后输入 输入 ssh-keygen ，按三次enter，出现 进入磁盘，找到 右键记事本打开然后复制里面内容 进入git进入Setting，新增一个，名称随便起，将刚才复制的粘贴到内容即可 如何操作创建版本库​ 什么是版本库？版本库又名仓库，英文名repository,你可以简单的理解一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改，删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻还可以将文件”还原”。 ​ 所以创建一个版本库也非常简单，如下我是D盘 –&gt; www下 目录下新建一个testgit版本库。 pwd 命令是用于显示当前的目录。 ​ 1. 通过命令 git init 把这个目录变成git可以管理的仓库，如下： ​ 这时候你当前testgit目录下会多了一个.git的目录，这个目录是Git来跟踪管理版本的，没事千万不要手动乱改这个目录里面的文件，否则，会把git仓库给破坏了。如下： ​ 把文件添加到版本库中​ 首先要明确下，所有的版本控制系统，只能跟踪文本文件的改动，比如txt文件，网页，所有程序的代码等，Git也不列外，版本控制系统可以告诉你每次的改动，但是图片，视频这些二进制文件，虽能也能由版本控制系统管理，但没法跟踪文件的变化，只能把二进制文件每次改动串起来，也就是知道图片从1kb变成2kb，但是到底改了啥，版本控制也不知道。 下面先看下**demo**如下演示： ​ 我在版本库testgit目录下新建一个记事本文件 readme.txt 内容如下：11111111 ​ 第一步：使用命令 git add readme.txt添加到暂存区里面去。如下： ​ 如果和上面一样，没有任何提示，说明已经添加成功了。 第二步：用命令 git commit告诉Git，把文件提交到仓库。 现在我们已经提交了一个readme.txt文件了，我们下面可以通过命令git status来查看是否还有文件未提交，如下： 说明没有任何文件未提交，但是我现在继续来改下readme.txt内容，比如我在下面添加一行2222222222内容，继续使用git status来查看下结果，如下： 上面的命令告诉我们 readme.txt文件已被修改，但是未被提交的修改。 接下来我想看下readme.txt文件到底改了什么内容，如何查看呢？可以使用如下命令： git diff readme.txt 如下： 如上可以看到，readme.txt文件内容从一行11111111改成 二行 添加了一行22222222内容。 知道了对readme.txt文件做了什么修改后，我们可以放心的提交到仓库了，提交修改和提交文件是一样的2步(第一步是git add 第二步是：git commit)。 如下： 版本回退​ 如上，我们已经学会了修改文件，现在我继续对readme.txt文件进行修改，再增加一行 内容为33333333333333.继续执行命令如下： 现在我已经对readme.txt文件做了三次修改了，那么我现在想查看下历史记录，如何查呢？我们现在可以使用命令 git log 演示如下所示： ​ git log命令显示从最近到最远的显示日志，我们可以看到最近三次提交，最近的一次是,增加内容为333333.上一次是添加内容222222，第一次默认是 111111.如果嫌上面显示的信息太多的话，我们可以使用命令 git log –pretty=oneline 演示如下： ​ 现在我想使用版本回退操作，我想把当前的版本回退到上一个版本，要使用什么命令呢？可以使用如下2种命令，第一种是：git reset –hard HEAD^ 那么如果要回退到上上个版本只需把HEAD^ 改成 HEAD^^ 以此类推。那如果要回退到前100个版本的话，使用上面的方法肯定不方便，我们可以使用下面的简便命令操作：git reset –hard HEAD~100 即可。未回退之前的readme.txt内容如下： 如果想回退到上一个版本的命令如下操作： 再来查看下 readme.txt内容如下：通过命令cat readme.txt查看 可以看到，内容已经回退到上一个版本了。我们可以继续使用git log 来查看下历史记录信息，如下： 我们看到 增加333333 内容我们没有看到了，但是现在我想回退到最新的版本，如：有333333的内容要如何恢复呢？我们可以通过版本号回退，使用命令方法如下： git reset –hard 版本号 ，但是现在的问题假如我已经关掉过一次命令行或者333内容的版本号我并不知道呢？要如何知道增加3333内容的版本号呢？可以通过如下命令即可获取到版本号：git reflog 演示如下： 通过上面的显示我们可以知道，增加内容3333的版本号是 6fcfc89.我们现在可以命令 git reset –hard 6fcfc89来恢复了。演示如下： 可以看到 目前已经是最新的版本了。 理解工作区与暂存区的区别工作区：就是你在电脑上看到的目录，比如目录下testgit里的文件(.git隐藏目录版本库除外)。或者以后需要再新建的目录文件等等都属于工作区范畴。 版本库**(Repository)**：工作区有一个隐藏目录.git,这个不属于工作区，这是版本库。其中版本库里面存了很多东西，其中最重要的就是stage(暂存区)，还有Git为我们自动创建了第一个分支master,以及指向master的一个指针HEAD。 我们前面说过使用Git提交文件到版本库有两步： 第一步：是使用 git add 把文件添加进去，实际上就是把文件添加到暂存区。 第二步：使用git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支上。 我们继续使用demo来演示下： 我们在readme.txt再添加一行内容为4444444，接着在目录下新建一个文件为test.txt 内容为test，我们先用命令 git status来查看下状态，如下： 现在我们先使用git add 命令把2个文件都添加到暂存区中，再使用git status来查看下状态，如下： 接着我们可以使用git commit一次性提交到分支上，如下： Git撤销修改和删除文件操作撤销修改​ 比如我现在在readme.txt文件里面增加一行 内容为555555555555，我们先通过命令查看如下： 在我未提交之前，我发现添加5555555555555内容有误，所以我得马上恢复以前的版本，现在我可以有如下几种方法可以做修改： 第一：如果我知道要删掉那些内容的话，直接手动更改去掉那些需要的文件，然后add添加到暂存区，最后commit掉。 第二：我可以按以前的方法直接恢复到上一个版本。使用 git reset –hard HEAD^ 但是现在我不想使用上面的2种方法，我想直接想使用撤销命令该如何操作呢？首先在做撤销之前，我们可以先用 git status 查看下当前的状态。如下所示： 可以发现，Git会告诉你，git checkout — file 可以丢弃工作区的修改，如下命令： git checkout — readme.txt,如下所示： 命令 git checkout –readme.txt 意思就是，把readme.txt文件在工作区做的修改全部撤销，这里有2种情况，如下： readme.txt自动修改后，还没有放到暂存区，使用 撤销修改就回到和版本库一模一样的状态。 另外一种是readme.txt已经放入暂存区了，接着又作了修改，撤销修改就回到添加暂存区后的状态。 对于第二种情况，我想我们继续做demo来看下，假如现在我对readme.txt添加一行 内容为6666666666666，我git add 增加到暂存区后，接着添加内容7777777，我想通过撤销命令让其回到暂存区后的状态。如下所示： 注意：命令git checkout — readme.txt 中的 — 很重要，如果没有 — 的话，那么命令变成创建分支了。 删除文件 假如我现在版本库testgit目录添加一个文件b.txt,然后提交。如下： 如上：一般情况下，可以直接在文件目录中把文件删了，或者使用如上rm命令：rm b.txt ，如果我想彻底从版本库中删掉了此文件的话，可以再执行commit命令 提交掉，现在目录是这样的， 只要没有commit之前，如果我想在版本库中恢复此文件如何操作呢？ 可以使用如下命令 git checkout — b.txt，如下所示： 再来看看我们testgit目录，添加了3个文件了。如下所示： 远程仓库 在了解之前，先注册github账号，由于你的本地Git仓库和github仓库之间的传输是通过SSH加密的，所以需要一点设置： ​ 第一步：创建SSH Key。在用户主目录下，看看有没有.ssh目录，如果有，再看看这个目录下有没有id_rsa和id_rsa.pub这两个文件，如果有的话，直接跳过此如下命令，如果没有的话，打开命令行，输入如下命令： ssh-keygen -t rsa –C “youremail@example.com”, 由于我本地此前运行过一次，所以本地有，如下所示： id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。 第二步：登录github,打开” settings”中的SSH Keys页面，然后点击“Add SSH Key”,填上任意title，在Key文本框里黏贴id_rsa.pub文件的内容。 点击 Add Key，你就应该可以看到已经添加的key。 如何添加远程库？ ​ 现在的情景是：我们已经在本地创建了一个Git仓库后，又想在github创建一个Git仓库，并且希望这两个仓库进行远程同步，这样github的仓库可以作为备份，又可以其他人通过该仓库来协作。 首先，登录github上，然后在右上角找到“create a new repo”创建一个新的仓库。如下： 在Repository name填入testgit，其他保持默认设置，点击“Create repository”按钮，就成功地创建了一个新的Git仓库： ​ 目前，在GitHub上的这个testgit仓库还是空的，GitHub告诉我们，可以从这个仓库克隆出新的仓库，也可以把一个已有的本地仓库与之关联，然后，把本地仓库的内容推送到GitHub仓库。 现在，我们根据GitHub的提示，在本地的testgit仓库下运行命令： git remote add origin https://github.com/tugenhua0707/testgit.git 所有的如下： 把本地库的内容推送到远程，使用 git push命令，实际上是把当前分支master推送到远程。 由于远程库是空的，我们第一次推送master分支时，加上了 –u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。推送成功后，可以立刻在github页面中看到远程库的内容已经和本地一模一样了，上面的要输入github的用户名和密码如下所示： 从现在起，只要本地作了提交，就可以通过如下命令： git push origin master 把本地master分支的最新修改推送到github上了，现在你就拥有了真正的分布式版本库了。 \2. 如何从远程库克隆？ 上面我们了解了先有本地库，后有远程库时候，如何关联远程库。 现在我们想，假如远程库有新的内容了，我想克隆到本地来 如何克隆呢？ 首先，登录github，创建一个新的仓库，名字叫testgit2.如下： 如下，我们看到： 现在，远程库已经准备好了，下一步是使用命令git clone克隆一个本地库了。如下所示： 接着在我本地目录下 生成testgit2目录了，如下所示： 六：创建与合并分支。 在 版本回填退里，你已经知道，每次提交，Git都把它们串成一条时间线，这条时间线就是一个分支。截止到目前，只有一条时间线，在Git里，这个分支叫主分支，即master分支。HEAD严格来说不是指向提交，而是指向master，master才是指向提交的，所以，HEAD指向的就是当前分支。 首先，我们来创建dev分支，然后切换到dev分支上。如下操作： git checkout 命令加上 –b参数表示创建并切换，相当于如下2条命令 git branch dev git checkout dev git branch查看分支，会列出所有的分支，当前分支前面会添加一个星号。然后我们在dev分支上继续做demo，比如我们现在在readme.txt再增加一行 7777777777777 首先我们先来查看下readme.txt内容，接着添加内容77777777，如下： 现在dev分支工作已完成，现在我们切换到主分支master上，继续查看readme.txt内容如下： 现在我们可以把dev分支上的内容合并到分支master上了，可以在master分支上，使用如下命令 git merge dev 如下所示： git merge命令用于合并指定分支到当前分支上，合并后，再查看readme.txt内容，可以看到，和dev分支最新提交的是完全一样的。 注意到上面的Fast-forward信息，Git告诉我们，这次合并是“快进模式”，也就是直接把master指向dev的当前提交，所以合并速度非常快。 合并完成后，我们可以接着删除dev分支了，操作如下： 总结创建与合并分支命令如下： 查看分支：git branch 创建分支：git branch name 切换分支：git checkout name 创建+切换分支：git checkout –b name 合并某分支到当前分支：git merge name 删除分支：git branch –d name 如何解决冲突下面我们还是一步一步来，先新建一个新分支，比如名字叫fenzhi1，在readme.txt添加一行内容8888888，然后提交，如下所示： 同样，我们现在切换到master分支上来，也在最后一行添加内容，内容为99999999，如下所示： 现在我们需要在master分支上来合并fenzhi1，如下操作： Git用&lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======，&gt;&gt;&gt;&gt;&gt;&gt;&gt;标记出不同分支的内容，其中&lt;&lt;&gt;&gt;&gt;&gt;fenzhi1 是指fenzhi1上修改的内容，我们可以修改下如下后保存： 如果我想查看分支合并的情况的话，需要使用命令 git log.命令行演示如下： 分支管理策略通常合并分支时，git一般使用”Fast forward”模式，在这种模式下，删除分支后，会丢掉分支信息，现在我们来使用带参数 –no-ff来禁用”Fast forward”模式。首先我们来做demo演示下： 创建一个dev分支。 修改readme.txt内容。 添加到暂存区。 切换回主分支(master)。 合并dev分支，使用命令 git merge –no-ff -m “注释” dev 查看历史记录 截图如下： 分支策略：首先master主分支应该是非常稳定的，也就是用来发布新版本，一般情况下不允许在上面干活，干活一般情况下在新建的dev分支上干活，干完后，比如上要发布，或者说dev分支代码稳定后可以合并到主分支master上来。 七：bug分支： ​ 在开发中，会经常碰到bug问题，那么有了bug就需要修复，在Git中，分支是很强大的，每个bug都可以通过一个临时分支来修复，修复完成后，合并分支，然后将临时的分支删除掉。 比如我在开发中接到一个404 bug时候，我们可以创建一个404分支来修复它，但是，当前的dev分支上的工作还没有提交。比如如下： 并不是我不想提交，而是工作进行到一半时候，我们还无法提交，比如我这个分支bug要2天完成，但是我issue-404 bug需要5个小时内完成。怎么办呢？还好，Git还提供了一个stash功能，可以把当前工作现场 ”隐藏起来”，等以后恢复现场后继续工作。如下： 所以现在我可以通过创建issue-404分支来修复bug了。 首先我们要确定在那个分支上修复bug，比如我现在是在主分支master上来修复的，现在我要在master分支上创建一个临时分支，演示如下： 修复完成后，切换到master分支上，并完成合并，最后删除issue-404分支。演示如下： 现在，我们回到dev分支上干活了。 工作区是干净的，那么我们工作现场去哪里呢？我们可以使用命令 git stash list来查看下。如下： 工作现场还在，Git把stash内容存在某个地方了，但是需要恢复一下，可以使用如下2个方法： git stash apply恢复，恢复后，stash内容并不删除，你需要使用命令git stash drop来删除。 另一种方式是使用git stash pop,恢复的同时把stash内容也删除了。 ​ 演示如下 多人协作当你从远程库克隆时候，实际上Git自动把本地的master分支和远程的master分支对应起来了，并且远程库的默认名称是origin。 要查看远程库的信息 使用 git remote 要查看远程库的详细信息 使用 git remote –v 如下演示： 一：推送分支： ​ 推送分支就是把该分支上所有本地提交到远程库中，推送时，要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上： ​ 使用命令 git push origin master 比如我现在的github上的readme.txt代码如下： 本地的readme.txt代码如下： 现在我想把本地更新的readme.txt代码推送到远程库中，使用命令如下： 我们可以看到如上，推送成功，我们可以继续来截图github上的readme.txt内容 如下： 可以看到 推送成功了，如果我们现在要推送到其他分支，比如dev分支上，我们还是那个命令 git push origin dev 那么一般情况下，那些分支要推送呢？ master分支是主分支，因此要时刻与远程同步。 一些修复bug分支不需要推送到远程去，可以先合并到主分支上，然后把主分支master推送到远程去。 ​ 抓取分支 多人协作时，大家都会往master分支上推送各自的修改。现在我们可以模拟另外一个同事，可以在另一台电脑上（注意要把SSH key添加到github上）或者同一台电脑上另外一个目录克隆，新建一个目录名字叫testgit2 但是我首先要把dev分支也要推送到远程去，如下 接着进入testgit2目录，进行克隆远程的库到本地来，如下： 现在目录下生成有如下所示： 现在我们的小伙伴要在dev分支上做开发，就必须把远程的origin的dev分支到本地来，于是可以使用命令创建本地dev分支：git checkout –b dev origin/dev 现在小伙伴们就可以在dev分支上做开发了，开发完成后把dev分支推送到远程库时。 如下： 小伙伴们已经向origin/dev分支上推送了提交，而我在我的目录文件下也对同样的文件同个地方作了修改，也试图推送到远程库时，如下： 由上面可知：推送失败，因为我的小伙伴最新提交的和我试图推送的有冲突，解决的办法也很简单，上面已经提示我们，先用git pull把最新的提交从origin/dev抓下来，然后在本地合并，解决冲突，再推送。 git pull也失败了，原因是没有指定本地dev分支与远程origin/dev分支的链接，根据提示，设置dev和origin/dev的链接：如下： 这回git pull成功，但是合并有冲突，需要手动解决，解决的方法和分支管理中的 解决冲突完全一样。解决后，提交，再push： 我们可以先来看看readme.txt内容了。 现在手动已经解决完了，我接在需要再提交，再push到远程库里面去。如下所示： 因此：多人协作工作模式一般是这样的： 首先，可以试图用git push origin branch-name推送自己的修改. 如果推送失败，则因为远程分支比你的本地更新早，需要先用git pull试图合并。 如果合并有冲突，则需要解决冲突，并在本地提交。再用git push origin branch-name推送。 ​ Git**基本常用命令如下**12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061mkdir： XX (创建一个空目录 XX指目录名)pwd： 显示当前目录的路径。git init 把当前的目录变成可以管理的git仓库，生成隐藏.git文件。git add XX 把xx文件添加到暂存区去。git commit –m “XX” 提交文件 –m 后面的是注释。git status 查看仓库状态git diff XX 查看XX文件修改了那些内容git log 查看历史记录git reset –hard HEAD^ 或者 git reset –hard HEAD~ 回退到上一个版本 (如果想回退到100个版本，使用git reset –hard HEAD~100 )cat XX 查看XX文件内容git reflog 查看历史记录的版本号idgit checkout — XX 把XX文件在工作区的修改全部撤销。git rm XX 删除XX文件git remote add origin https://github.com/ev-power/XiaoYong 关联一个远程库git push –u(第一次要用-u 以后不需要) origin master 把当前master分支推送到远程库git clone https://github.com/ev-power/XiaoYong 从远程库中克隆git checkout –b dev 创建dev分支 并切换到dev分支上git branch 查看当前所有的分支git checkout master 切换回master分支git merge dev 在当前的分支上合并dev分支git branch –d dev 删除dev分支git branch name 创建分支git stash 把当前的工作隐藏起来 等以后恢复现场后继续工作git stash list 查看所有被隐藏的文件列表git stash apply 恢复被隐藏的文件，但是内容不删除git stash drop 删除文件git stash pop 恢复文件的同时 也删除文件git remote 查看远程库的信息git remote –v 查看远程库的详细信息git push origin master Git会把master分支推送到远程库对应的远程分支上 ​ 本文非原创博客，部分内容有所更改，原文出自：http://www.cnblogs.com/tugenhua0707/p/4050072.html]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>SVN</tag>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第四个任务]]></title>
    <url>%2F2018%2F05%2F18%2F%E7%AC%AC%E5%9B%9B%E4%B8%AA%E4%BB%BB%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[第四个任务​ 昨天刚刚解决了困扰好久的bug，今天果然又迎来了新的bug： ​ 又是在生产环境下的问题，好吧，只能硬着头皮上了！ ​ 看了一下好像跟一开始第一个任务一样，都是在带宽型批量校验模板上的问题，可以直接找到上次的源文件进行分析。 定位问题 ​ 做了好久的逻辑业务资源，忽然找不到批量受理的入口了。。还是没有做好笔记的锅！ ​ 然后打开了OrderVerifyImportProcessor.java这个文件，找到对应的位置： ​ 加上了如下的判断语句： 好了，接下来要如何测试呢？又是在生产环境下的问题。 ​ 对的，又要从数据库入手，让我们先来看看是如何跟数据库打交道的： 123456789 List&lt;Map&lt;String,Object&gt;&gt; moList = queryDeviceBySql(value); //因为账号的数据权限没有光缆专业，所以改为sql查询 private List&lt;Map&lt;String,Object&gt;&gt; queryDeviceBySql(Object value) throws Exception&#123; if(value==null) return null; String sql = &quot;SELECT (SELECT S.OBD_LEVEL FROM CE_DEVICE_OBD_CCS S WHERE S.DEVICE_ID = D.ID) OBD_LEVEL,&quot; + &quot;D.* FROM CM_DEVICE D WHERE D.SHARDING_ID = ? AND D.NAME = ?&quot;; return metaService.query(sql, new Object[]&#123;SecurityUtils.getCurrentShardingId(),value&#125;);&#125; 让我们用这条查询语句去数据库看看，在控制台可以看到是sw_sz0923数据库，在pom.xml文件中查询账户密码，进入数据库，查询对应语句： 12SELECT (SELECT S.OBD_LEVEL FROM CE_DEVICE_OBD_CCS S WHERE S.DEVICE_ID = D.ID) OBD_LEVEL, D.* FROM CM_DEVICE D WHERE D.SHARDING_ID = &apos;755&apos; AND D.NAME = &apos;香港VDICHINALIMITED深圳代表处用户机房/99-02&apos;; ​ 可以看到查询到一条记录，既然想代码走我写的那个逻辑，就必须是查询到多条语句，好的方向对了，现在来准备向CM_DEVICE表中插入相同NAME,ID,Sharding_ID的一条记录。 ​ 然后在eclipse中重新设置断点，看看有没有在我写的代码中断，检测出多条记录。 ​ 在这里浪费了好多时间，数据库修改完毕之后一定要重启数据库，重启服务器，重启浏览器并清空缓存 ！！！！ 全部重启之后，导出结果文件，在Excel文件中出现了我写的结果。 ok，问题完成。 svn更新上传代码，在pms网站提交补丁：]]></content>
      <categories>
        <category>java, SNV, PMS</category>
      </categories>
      <tags>
        <tag>SVN</tag>
        <tag>项目检出</tag>
        <tag>java</tag>
        <tag>逻辑校验</tag>
        <tag>PMS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第三个任务]]></title>
    <url>%2F2018%2F05%2F17%2F%E7%AC%AC%E4%B8%89%E4%B8%AA%E4%BB%BB%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[第三个任务任务如下： 查找源文件：然后就是找到这个功能按钮所对应的源文件： 打开源文件：在eclipse中搜索ImpactAnalysisImportProcessor可找到ImpactAnalysisImportProcessor.java文件，这就是该按钮对应功能的源文件。 开始测试：首先将pms上面的附件下载下来，然后运行本地测试系统，导入文件测试，并跟着代码debug了一遍，可是没发现任何错误，也能直接生成result文件，并没有存在空指针错误。 于是找到了标哥，标哥说这个问题是发生在生产环境下的，要在生产环境才看的到问题，给了我一个账号，登录生产环境，果然看到了空指针错误： 看到了报错的行数，就开始在java源文件里面看对应的代码。 可是出错的源文件在本地测试环境一直没有任何问题，在生产环境又报错，而且也没有办法对生产环境进行debug，这就是这一次任务最难的点。把整一个源文件看了一遍，也没有发现什么毛病，于是标哥叫我安装一下数据库，在数据库里面看看能不能做文章。于是就开始了安装oracle跟plsql的路。 安装Oracle与plsql​ 由于我笔记本之前安装过Oracle，就想直接试试能不能用plsql直接连接上，可是试了好多次都不行，只好在标哥那里拿来了相同版本的Oracle以及plsql，把原来的全部卸载掉重新来。 下面是彻底卸载Oracle的方法：https://jingyan.baidu.com/article/922554468d4e6b851648f4e3.html plsql安装方法很简单，只需要一直点击下一步就可以了。 然后就是安装Oracle： 安装包 在这个安装界面选择第二个，然后一直下一步即可。 环境变量安装Oracle之后需要配置环境变量ORACLE_HOME和TNS_ADMIN环境变量:（在这里被坑了好久，一点要配置好环境变量，路径要对） 然后打开plsql： 点击取消按钮进入主界面： 点击工具-&gt;首选项： 在红框位置配置好两个路径，然后重启plsql。 可是重启之后发现没有读取到远程数据库，一看是因为还没有替换tnsnames.ora文件，于是在标哥那里拿来了这个文件，替换掉D:\app\Simple_Y\product\11.2.0\client_1\network\admin目录下的tnsnames.ora文件，重启plsql，就可以读取到远程数据库了。 数据库连接这时候在eclipse运行系统，然后导入excel文件解析，查看控制台消息，可以得出是哪一个数据库用户： 然后查看inventory_main项目的pom.xml文件 可以看到对应的数据库用户和密码。然后就用这个账户登录plsql： 连接上数据库之后（记得断vpn），点击下面的小按钮： 选择新建sql窗口，然后就可以对表进行查询了。 查找问题下面的问题就是找到数据库中对应报错行的那个数据，而Java文件报错的行数为171行，找到对应的代码： mapmo.put(“A_DEVICE”, aDevice==null?””:aDevice.getValue(“STANDARD_NAME”).toString()); 意思也不难理解，就是在aDevice对象中获取key值为STANDARD_NAME的value值，放入mapmo对象中，但是debug到这里发现是读取得到对象的，并没有出现空指针错误，所以需要在数据库中找到这个数据，将它置为空，看看能不能出现空指针问题。然后标哥教了我底层元数据api操作数据库的原理： 1234567&gt; QueryCriteria qc = new QueryCriteria(&quot;SERVICE&quot;);&gt; qc.addAssembleFragment(&quot;[SERVICE_END_A_DEVICE][SERVICE_END_Z_DEVICE]&quot;);&gt; qc.addExpression(QueryExpressionUtil.equals(&quot;ID&quot;, servId));&gt; List&lt;MetaObject&gt; services = metaService.query(qc).getList();&gt; //上面的就是公司操作数据库的api，一开始一直看不懂&gt; //下面解释具体的意思：&gt; &gt; 123&gt; --QueryCriteria qc = new QueryCriteria(&quot;SERVICE&quot;);&gt; select * from xm_entityspec m where m.code = &apos;SERVICE&apos;;&gt; &gt; 上面这两句是等同的，在查询结果我们可以看到service对应的表名： 下面的是等同的： 1234&gt; --qc.addAssembleFragment(&quot;[SERVICE_END_A_DEVICE][SERVICE_END_Z_DEVICE]&quot;);&gt; select * from xm_relationspec m where m.code = &apos;SERVICE_END_A_DEVICE&apos;;&gt; select * from xm_relationspec m where m.code = &apos;SERVICE_END_Z_DEVICE&apos;;&gt; &gt; 由于我们不知道两个ID分别是对应哪一个，所以需要下面的查询语句来确定： select * from xm_entityspec m where m.id in (2310000000,1020000000); 在xm_entityspec–实体规格描述表中查询它们分别对应什么： 可以看到两个ID分别对应设备和产品服务以及他们的数据表。 接下来就是： 12345&gt; --根据servid查到service实体的数据&gt; select m.a_device_id,m.* from RM_SERVICE m where m.id = &apos;441020000000001125355060&apos; ;&gt; --根据service实体数据的a_device_id查询device实体的数据&gt; select m.standard_name,m.* from CM_DEVICE m where m.id = 441020000000001083663191;&gt; &gt; 到这里就可以找到STANDARD_NAME属性的值了，在这里将STANDARD_NAME属性置为空，然后运行系统看看会不会报空指针错误。 12345&gt; --置空&gt; update CM_DEVICE set standard_name = &apos;&apos; where id = 441020000000001163583121;&gt; --查询结果&gt; select m.standard_name,m.* from CM_DEVICE m where m.id = 441020000000001083663191;&gt; &gt; ok，成功置空了，然后重新启动系统，清空浏览器缓存，重启数据库，终于如愿以偿地看到了空指针异常。 解决问题看来已经找到了问题了，让我们再来看看报错的代码行： 12&gt; mapmo.put(&quot;A_DEVICE&quot;, aDevice==null?&quot;&quot;:aDevice.getValue(&quot;STANDARD_NAME&quot;).toString());&gt; &gt; 当aDevice.getValue(“STANDARD_NAME”)不存在的时候，系统就会发生空指针异常，于是我百度了一下： map 允许null键null值 你的value引入的是一个变量吧 这个变量获取到的值为空 会报空指针异常，可以对这个变量做一个判断不就行了 是的，问题终于有突破口了，然后就对这一行进行重写： 123456&gt; mapmo.put(&quot;A_DEVICE&quot;, aDevice==null?&quot;&quot;:aDevice.getValue(&quot;STANDARD_NAME&quot;).toString());&gt; -&gt;&gt; if(aDevice!=null &amp;&amp; aDevice.getValue(&quot;STANDARD_NAME&quot;)!=null)&#123;&gt; mapmo.put(&quot;A_DEVICE&quot;, aDevice.getValue(&quot;STANDARD_NAME&quot;).toString());&gt; &#125;&gt; &gt; 加入对aDevice.getValue(“STANDARD_NAME”)的判空处理，重新运行系统，完美通过，终于把这个问题解决了。 然后svn同步本地代码，更新代码，提交自己的修改，在pms网站上提交补丁，问题解决。 这次的问题主要是在数据库方面遇到了不少阻碍，对Oracle数据库无从下手，要看懂元数据操作的api，根据其对应的select语句找到想要的数据，才能开始动手。 下面是标哥说的比较重要的三个表： xm_entityspec –实体规格描述表xm_relationspec –实体规格关系描述表xm_entitydescriptor –描述实体规格对应哪些数据表，以及数据表有哪些属性底层元数据api的实现，是基于上面3个表的，要了解元数据api，上面3个表是比较重要的]]></content>
      <categories>
        <category>java, SNV, PMS, Oracle</category>
      </categories>
      <tags>
        <tag>Oracle</tag>
        <tag>SVN</tag>
        <tag>项目检出</tag>
        <tag>java</tag>
        <tag>PMS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第二个任务]]></title>
    <url>%2F2018%2F05%2F04%2F%E7%AC%AC%E4%BA%8C%E4%B8%AA%E4%BB%BB%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[第二个任务解决了第一个问题之后，很快也就迎来了新的任务。 熊奉标 17:03:34 内容：局内模板校验，判断设备的所属机房是否为空，如果不为空，取机房作为入参；如果机房为空，再判断是否OBD，非OBD取设备id入参，如果是OBD，取obd的所属上级设备id入参。 熊奉标 17:03:39 你再看看这个问题 熊奉标 17:06:24 问题是出在checkValidResource这个方法里面 熊奉标 17:07:04 就是校验导入的模板里面的数据，是不是有可用方案 熊奉标 17:07:34 checkValidResource这个方法的作用就是根据入参校验是否有可用方案 熊奉标 17:07:47 但是校验的时候存在一个问题 熊奉标 17:08:44 判断设备的所属机房是否为空，如果不为空，取机房作为入参；如果机房为空，再判断是否OBD，非OBD取设备id入参，如果是OBD，取obd的所属上级设备id入参。上面需求定义的逻辑，代码少了：非OBD取设备id入参，这个逻辑 看了一下问题，感觉应该问题不大，所以找到了对应的方法： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162private void checkValidResource(Map&lt;String, String&gt; mapmo,String metaClassName,StringBuffer errorMsg) throws Exception&#123; if(!metaClassName.equals(&quot;ACCESSNETFIBER(SZ)_INSTALL&quot;) &amp;&amp;!metaClassName.equals(&quot;ACCESSNETFIBER(GZ)_INSTALL_PORTZI&quot;) &amp;&amp;!metaClassName.equals(&quot;ACCESSNETFIBER(GZ)_INSTALL_ROOM&quot;) &amp;&amp;!metaClassName.equals(&quot;TRANSMISSIONFIBER(SZ)_INSTALL&quot;) &amp;&amp;!metaClassName.equals(&quot;TRANSMISSIONFIBER(GZ)_INSTALL&quot;))&#123; return; &#125; String aId = mapmo.get(&quot;AROOMID&quot;)==null?&quot;&quot;:mapmo.get(&quot;AROOMID&quot;); String bId = mapmo.get(&quot;BROOMID&quot;)==null?&quot;&quot;:mapmo.get(&quot;BROOMID&quot;); String aDeviceId = mapmo.get(&quot;ADEVICENAMEID&quot;)==null?&quot;&quot;:mapmo.get(&quot;ADEVICENAMEID&quot;); String bDeviceId = mapmo.get(&quot;BDEVICENAMEID&quot;)==null?&quot;&quot;:mapmo.get(&quot;BDEVICENAMEID&quot;); String aDeviceSpecId = mapmo.get(&quot;ADEVICENAMESPECID&quot;)==null?&quot;&quot;:mapmo.get(&quot;ADEVICENAMESPECID&quot;); String bDeviceSpecId = mapmo.get(&quot;BDEVICENAMESPECID&quot;)==null?&quot;&quot;:mapmo.get(&quot;BDEVICENAMESPECID&quot;); if(aId.equals(&quot;&quot;)&amp;&amp;!aDeviceId.equals(&quot;&quot;)&amp;&amp;InventoryUtil.isSubClassOf(aDeviceSpecId, &quot;OBD&quot;))&#123; MetaObject obd = resourceConfigService.getBelongNEByOBD(aDeviceId, null); if(obd!=null)&#123; aId = obd.getValue(&quot;ID&quot;).toString(); &#125; &#125; if(aId.equals(&quot;&quot;)&amp;&amp;!aDeviceId.equals(&quot;&quot;)&amp;&amp;!InventoryUtil.isSubClassOf(aDeviceSpecId, &quot;OBD&quot;))&#123; aId = aDeviceId; &#125; if(bId.equals(&quot;&quot;)&amp;&amp;!bDeviceId.equals(&quot;&quot;)&amp;&amp;InventoryUtil.isSubClassOf(bDeviceSpecId, &quot;OBD&quot;))&#123; MetaObject obd = resourceConfigService.getBelongNEByOBD(bDeviceId, null); if(obd!=null)&#123; bId = obd.getValue(&quot;ID&quot;).toString(); &#125; &#125; if(bId.equals(&quot;&quot;)&amp;&amp;!bDeviceId.equals(&quot;&quot;)&amp;&amp;!InventoryUtil.isSubClassOf(bDeviceSpecId, &quot;OBD&quot;))&#123; bId = bDeviceId; &#125; if(aId.equals(&quot;&quot;)||bId.equals(&quot;&quot;))&#123; errorMsg.append(&quot;无可用方案！\r\n&quot;); return; &#125; String shardingId = SecurityUtils.getCurrentShardingId(); //单纤1,双纤2 String fiberNum = InventoryUtil.isEmptyString(mapmo.get(&quot;FIBERCOUNT&quot;))?&quot;&quot;:mapmo.get(&quot;FIBERCOUNT&quot;); int fiberNum_int = fiberNum.equals(&quot;双纤&quot;)?2:1; //双模1,单模3 String fiberType = InventoryUtil.isEmptyString(mapmo.get(&quot;FIBERTYPE&quot;))?&quot;&quot;:mapmo.get(&quot;FIBERTYPE&quot;); int fiberType_int = fiberType.equals(&quot;双模&quot;)?1:3; try&#123; Object[] results = metaService.executeSP(&quot;PKG_OPTROAD_SEARCH.CHOOSE_SITEFIBER&quot;, new Object[]&#123;aId,bId,7,null,null,fiberNum_int,1, fiberType_int&#125;, new int[]&#123;OracleTypes.NUMBER,OracleTypes.VARCHAR&#125;, InventoryUtil.getDbRouteContext(shardingId)); if(results == null || results.length&lt;2 || results[1] == null || results[1].toString().length()==0)&#123; errorMsg.append(&quot;无可用方案！\r\n&quot;); &#125; &#125;catch(Exception e)&#123; errorMsg.append(&quot;无可用方案！\r\n&quot;); &#125; &#125; 经过分析，发现下面代码是对 如果是OBD，取obd的所属上级设备id入参 这个逻辑进行验证: 所以就在此逻辑的基础上再加上 对 非OBD取设备id入参 这个逻辑进行判断。 然后今天标哥给了个测试文件，验证有没有走过这个逻辑判断。 经过debug，发现了一些问题： 在从数据库查询出moList这个列表时，发现moList里面全都为空，然后直接return，没有在mapmo对象中添加入aROOMID这个key值，导致aROOMID为空。 查看了queryMetaObjectByColumn这个方法，也是发现resultList为空，此时怀疑会不会是数据库数据的问题， 然后捣鼓了一下oracle，发现连接不上，所以叫来了标哥。 看了一下系统，发现之前登录的是sa用户，是广州市的测试账户，然后测试文件是深圳的机房，在数据库中查询不到对应的机房，所以返回了null。 于是更换成testsz帐号，重启系统，debug一遍，代码完美走过我添加的那个逻辑，好的任务完成。 接下来的任务就是把自己的代码提交到SVN代码库。 首先找到 选中自己修改过的java文件，右键提交，并且添加上所解决问题的PMS作为备注。 提交成功后，就要给系统打补丁，打补丁之前就要先导出jar包，右键java文件-&gt;导出-&gt;jar文件 由于本次是两个PMS一起提交，所以需要把jar包合并： jar包命名规则如上：项目名-日期-姓名-pms jar包的内部结构必须要符合路径，具体路径如上，也可以在tomcat的配置路径那里找： 打开以上目录，进入项目的地址： jar包的路径必须与以上的路径对应，这样打了补丁才会替换掉原来的文件。 然后就是登录自己的pms帐号，为pms打补丁： 填写必要的信息，提交： 还有一个加快系统运行的技巧： 就是每天第一次运行系统的时候用master运行，之后的每一次都可以用slave，速度会加快。]]></content>
      <categories>
        <category>java, SNV, PMS</category>
      </categories>
      <tags>
        <tag>SVN</tag>
        <tag>项目检出</tag>
        <tag>java</tag>
        <tag>逻辑校验</tag>
        <tag>PMS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第一个任务遇到的一些问题]]></title>
    <url>%2F2018%2F05%2F03%2F%E7%AC%AC%E4%B8%80%E4%B8%AA%E4%BB%BB%E5%8A%A1%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[​ 在捣鼓了几天的SVN检出项目之后，终于成功把代码从远程代码库下载下来并成功把系统运行起来了。但是由于系统过于庞大，跟了我几年的电脑开始有点不堪重负，CPU跟内存占用都达到了80%，风扇也转的很大声，赶紧叫来了标哥，在tomcat的配置文件那里加了一句： 1-Xms2048m -Xmx2048m -XX:PermSize=512m -XX:MaxPermSize=512m ​ 问题终于迎刃而解。 ​ 于是也就迎来了在公司的第一个任务： 熊奉标 10:56:41局内业务批量受理校验功能，如果导入的字段值有空格，则系统校验不通过，提示机房或者设施不存在。因此，要去系统优化功能，能自动去除字段值前后的空格后再进行校验。案例见附件 ​ 这个任务的需求也就是在局内业务批量受理校验功能中，用户从系统导出excel模板，对着模板填充对应的信息。但是由于用户有时候会误操作，或者输入的时候会填充多一些空格在文字的前后，此时系统校验功能就会出错，自动读取空格为某一列，然后导致错位，提示机房或者设施不存在。所以需要在系统原有的基础上进行优化，能自动去除字段值前后的空格后再进行校验。 ​ 由于我的excel是2016版本，如果单元格没有设置为文本格式的话，是没有办法直接在文字前面或者后面直接添加空格，因为excel会自动去除空格，2010版本则没有这个问题。下面则列出我的部分测试数据(高亮部分为特殊测试数据，在数字的前后分别加入空格): （必填） 无需填 无需填 无需填 （二选一必填） 无需填 无需填 （二选一必填） 接入网类型 光纤类型 纤芯数量 A端机房区域 A端机房 A端网元名称 A端端口位置 A端设备种类 B端机房区域 B端机房 B端网元名称 B端端口位置 FTTH，FTTO，FTTB+DSL，FTTB+LAN OLT，1D-OBD，2D-OBD，ONU 超出字典值范围时提示提示“无此光路类型” 默认值：单模 默认值：单纤 由光交设施或机房生成 1、已填写但不存在，提示：A端机房名称不存在； 2、未填写：由A端网元名称生成 1、已填写但不存在，提示：A端网元名称不存在； 当不存在，提示：A端端子不存在；当无空闲，提示：A端端子非空闲。 当有填写时校验字典值范围。 当无填写时，由A端网元名称生成 由光交设施或机房生成 1、已填写但不存在，提示：B端机房名称不存在； 2、未填写：由B端网元名称生成 1、已填写但不存在，提示：B端网元名称不存在； 当不存在，提示：B端端子不存在；当无空闲，提示：B端端子非空闲。 FTTH 11 11 1 2 2 2 ​ 在看了好久的源代码之后，终于开始着手写代码了。首先找到了 在该源文件中添加了如下代码： 1234public static String getStringWithoutSpace(String str)&#123; String str1 = str.replaceAll(&quot; &quot;, &quot;&quot;); return str1;&#125; ctrl + S保存，再找到如下文件： 在源代码中： 12345678910111213//由于所有excel表格数据都是获取到mapmo对象中for (int j = 0; j &lt; loopCount; j++) &#123; List&lt;Map&lt;String, String&gt;&gt; list = getDatasByPage(fileparse, j, 0); for (int k = 0; k &lt; list.size(); k++) &#123; Map&lt;String, String&gt; mapmo = list.get(k); ｝ //所以我就在想只要在每次mapmo对象获取key对应的value值时，对获得的String字符串进行去空格处理，如下所示： String fiberMainState = mapmo.get(&quot;CUS_NOTNULL_FIBERMAINSTATE&quot;);-&gt; String fiberMainState = InventoryUtil.getStringWithoutSpace(mapmo.get(&quot;CUS_NOTNULL_FIBERMAINSTATE&quot;));//对OrderVerifyImportProcessor.java文件中所有相应部位都加上InventoryUtil.getStringWithoutSpace(）处理。对读取的String进行去空格处理。 Ctrl + S保存，右键tomcat-&gt;debug运行，导入测试文件进行测试，然后弹出如下空指针异常： 这一下子就有点懵逼了，于是开始苦逼的debug断点调试，F5,F6旋转跳跃不停歇。 终于在一处地方看到了端倪： 12345678910111213String fiberMainState = InventoryUtil.getStringWithoutSpace(mapmo.get(&quot;CUS_NOTNULL_FIBERMAINSTATE&quot;));//当mapmo获取对应的value时，如果该value值本身为null，而上述的去空格代码没有进行判空处理，就会出现空指针异常。//于是将代码改成如下：public static String getStringWithoutSpace(String str)&#123; if(str != null) &#123; String str1 = str.trim(); return str1; &#125; return str;&#125; 此时再次运行系统就没有再出现空指针异常。 然后成功导入用户的检验文件，输出校验结果文件： 校验成功码： 接入网光路(深圳)-订购 接入网类型 光纤类型 纤芯数量 A端机房区域 A端机房 A端网元名称 A端端口位置 A端设备种类 B端机房区域 B端机房 FTTH 海珠 11 11 1 黄埔 2 RESULT文件并没有将空格去除，但是在读取文件的时候空格明明已经去除了，我就在想可能是因为在读取excel文件时去除空格，只是存在于内存中，而在生成RESULT文件时没有将空格去除，所以还是有空格。 于是我又找到了生成RESULT文件的方法，对其进行修改： 123456789101112131415161718192021222324252627282930313233343536373839404142private void createExcelFileManySheet(OutputStream out, String[] dataTitles, List&lt;Map&lt;String, String&gt;&gt; dataList,HSSFRichTextString[] cellComment,String metaClassName,String verifyCode) &#123; WritableWorkbook workbook; WritableCellFeatures wcfeatures = null; try &#123; workbook = Workbook.createWorkbook(out); WritableSheet sheet = workbook.createSheet(&quot;sheet1&quot;,0); NetworkTemplateUtil.initialSheetSetting(sheet); verifyCode = &quot;校验成功码：&quot;+(verifyCode==null?&quot;&quot;:verifyCode); String productName = NetworkTemplateUtil.templateNameMaps.get(metaClassName); sheet.addCell(new Label(0, 0, verifyCode)); sheet.addCell(new Label(0, 1, productName)); Label label; for (int j = 0; j &lt; dataTitles.length; j++)&#123; label = new Label(j, 2, dataTitles[j]); wcfeatures = new WritableCellFeatures(); wcfeatures.setComment(cellComment[j].toString()); label.setCellFeatures(wcfeatures); sheet.addCell(label); &#125; for (int row=0; row&lt;dataList.size(); row++) &#123; Map&lt;String , String &gt; maps = dataList.get(row); for (int n = 0; n &lt; dataTitles.length ; n++) &#123; Cell cells = sheet.getCell(n, 2); String str = cells.getCellFeatures().getComment(); label = new Label(n, row + 3, InventoryUtil.getStringWithoutSpace(maps.get(str)); //在此处加入去空格处理，所以写入RESULT文件时就会没有空格 sheet.addCell(label); &#125; &#125; workbook.write(); workbook.close(); &#125; catch (SocketException s) &#123; s.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (WriteException e) &#123; e.printStackTrace(); &#125; catch (Exception ex) &#123; ex.printStackTrace(); &#125; &#125; 事情到这个阶段就告一段落，成功运行系统，导出正确的RESULT文件，看到想要的结果，超级开心地叫来了标哥，在看了代码以后标哥给了个建议： 这样改的话，可能需要改动的地方太多了，每一处有用到mapmo获取的地方都需要加入去空格处理，工程量太大，看看能不能在一开始获取excel表数据的源头那里就直接对数据进行处理，这样以后就不用每次都处理。 然后我就找到了一开始读取excel表的方法： 123456789101112131415161718192021222324252627282930public List&lt;Map&lt;String, String&gt;&gt; parse(int begin, int end, int sheetIndex) &#123; XSSFSheet sheet = sheets.get(sheetIndex); if(sheet == null)&#123; return null; &#125; List&lt;String&gt; keyList = sheetsKeyList.get(sheetIndex); List&lt;Map&lt;String, String&gt;&gt; excelList = new ArrayList&lt;Map&lt;String, String&gt;&gt;(); int startCol = 0; if(commentRow==3) startCol=1; for (int row = begin; row &lt;= end; row++) &#123; Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;(); if (sheet.getRow(row) != null) &#123; for (int i = 0; i &lt; keyList.size(); i++) &#123; String key = keyList.get(i); String value = getCellValue(sheet, row, i+startCol); //在这里加入去空格处理： String value = InventoryUtil.getStringWithoutSpace(getCellValue(sheet, row, i+startCol)）; map.put(key, value); &#125; if (map.size() &gt; 0) &#123; excelList.add(map); &#125; &#125; else &#123; map.put(null, null); excelList.add(map); &#125; &#125; return excelList;&#125; 去除其他地方的去空格处理，运行系统，得到了想要的效果。把标哥叫来了，标哥看了下这个parse方法，发现有两三处地方都调用了这个方法，改动了这个方法后这样子就有可能影响了其他地方的功能。所以再次给出了另外一个建议： 既然所有的数据都是先获取到mapmo对象中，那可不可以考虑在获取mapmp后直接对其进行处理，然后再开始对它进行调用。 //由于所有excel表格数据都是获取到mapmo对象中for (int j = 0; j &lt; loopCount; j++) { 12345&gt; List&lt;Map&lt;String, String&gt;&gt; list = getDatasByPage(fileparse, j, 0);&gt; for (int k = 0; k &lt; list.size(); k++) &#123;&gt; Map&lt;String, String&gt; mapmo = list.get(k);&gt; ｝&gt; ​ 考虑了一下以后，在OrderVerifyImportProcessor.java文件中编写一个新的方法，对mapmo对象进行去空格处理： 123456789private void getMapmoWithoutSpace(Map&lt;String, String&gt; mapmo) &#123; if (mapmo == null) return; Set&lt;String&gt; keys = mapmo.keySet(); for (String key : keys) &#123; String value = mapmo.get(key); value = InventoryUtil.getStringWithoutSpace(value); mapmo.put(key, value); &#125;&#125; ​ 运行系统，终于大功告成，第一个任务顺利完成，终于也能在公司提交自己写的代码了，也是很有成就感。 接下来就是将自己的代码同步到远程SVN仓库： 点击Team Synchronizing视图： 点击Synchronize： 选择SVN: 可以直接选取工作空间，也可以选择工作集，然后可以创建自己的工作集，这样就不用每次都再全部同步: 成功同步后，点击以下按钮： 查看svn代码库与本地代码库不同的文件，然后全选那些不同的文件，右键-&gt;更新，先对本地代码进行更新。 然后点击如下按钮： 经过与SVN代码库的代码对比，找出做出的修改，尽量做到只提交必要的修改： 然后右键对应的文件-&gt;提交： 此处需要用到PMS帐号，由于我还没有申请PMS帐号，所以就先写到这里。 终于等到了PMS帐号，可以为公司提交代码啦，刚注册了PMS帐号，就发现自己头上有两个bug任务： 接下来让我们来提交第一个bug的解决方案： 选择需要提交的代码，此处不能选择全部提交，只需要提交改动的java文件即可： 添加上对应的PMS，点击OK即可。 接下来就是欣赏自己的成果了： 第一个任务到此就顺利完成啦~]]></content>
      <categories>
        <category>java, SNV, PMS</category>
      </categories>
      <tags>
        <tag>SVN</tag>
        <tag>java， Tomcat</tag>
        <tag>空指针， PMS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SVN检出项目遇到的坑]]></title>
    <url>%2F2018%2F04%2F14%2FSVN%E6%A3%80%E5%87%BA%E9%A1%B9%E7%9B%AE%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91%2F</url>
    <content type="text"><![CDATA[用SVN检出maven项目遇到的坑： SVN检出项目： 一开始从svn检出的项目默认为java项目，需要将项目从工作空间移除后重新导入existing maven项目。 方法二则是右键项目Configure-&gt;Convert to Maven Projects,此时就可以看到项目左上角有一个m字maven项目标识。 maven版本问题 一开始用的是maven3.5，项目导入之后全部都报错，丢包什么的。后来看到jdk1.6对应的maven版本为3.2，果断换成了3.2.5，迈出了成功的第一步。 一开始没有配置maven的setting.xml文件，没有引入公司内部资源库，导致一直找不到com.ccssoft…的jar包，后来把setting.xml换成标哥的文件，完美解决。 然后记得修改maven本地仓库，配置环境变量，在用户变量path和系统变量都要记得修改。 在eclipse中把外接maven地址更改，settings.xml文件位置也要更改。 记得把默认jdk版本换成1.6。 本来上周五按照标哥的方法把提示missing的jar删除后再重新maven-&gt;update Project更新一下，重新下载所需要的jar包，再加上把jdk和maven换成对应版本，所有项目已经没有报错了，但是过了一个周末，重启电脑以后又发现所有项目又重新报错（脸黑。。此处我怀疑是电脑太久没关机，没及时更新自己白高兴一场），于是又开始了新一轮的debug过程。。 在把百度几乎所有办法都试过了以后，还是不行，决定全部推倒重来，把项目全部都删除，在SVN重新下载项目，按照百度导入maven项目的方法，发现项目里面多了很多东西（这里还是很有成就感的！），然后把maven版本换成跟标哥一样，还是一堆错误，实在走投无路的时候发现为什么远程仓库一直连接不对，把jar包删除以后重新update也不会下载回来，于是跑到settings.xml文件把远程仓库那一段给注释掉。 重新打开eclipse，右键项目，maven-&gt;Update Project，开始下载文件！开心到飞起来啊那时候，一开始只试了一个项目，然后感觉把所有项目都勾选，update project，稍等一会儿~ 吃个饭回来后发现有几个项目终于没有报错了，松了一口气~ 然后就继续搞剩下的错误。 剩下的错误是有一些依赖文件好像在本项目没有，听了标哥的话把报错的段落全都注释掉，完美解决。 在导入项目的时候默认编码是gbk，可能会出现中文乱码的情况，右键项目property-&gt;编码改成utf-8，完美解决。 还有就是eclipse会有js自动校验，看到项目中一些jquery库文件报错，可以在window-&gt;preperence-&gt;javascript中关闭js校验。 还有就是这个项目要从tomcat debug模式运行，先配置好tomcat7.0环境，可是发现一直报错，把一些依赖文件删除之后就可以了，再一个是包重叠问题，可能pom.xml有多次引用。注释掉相应部分就可以了，或者找到重复包的位置，删除一个即可。]]></content>
      <categories>
        <category>java, SNV</category>
      </categories>
      <tags>
        <tag>SVN</tag>
        <tag>项目检出</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL基础]]></title>
    <url>%2F2017%2F09%2F05%2FMySQL%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[前言本文示例基于crashcourse数据库，文中如有错误请谅解！ MySQL入门123456789101112131415161718192021222324252627282930313233343536#查看数据库show databases; #选择一个数据库use 数据库名;#创建数据库create database 数据库名;#查看创建数据库的SQL语言show create database 数据库名;#查看表show tables; #创建表create table student(id int(11) not null,name char(20));#查看表结构desc student;#查看创建表语句show create table student;#插入数据insert into student(id,name) values(1001,’zhangsan’);#查询数据select * from student; #删除数据delete from student where id=1001; #删除表drop table student;#删除数据库drop database mydb;#查看mysql服务器状态信息show status; #查看用户权限show grants;#查看服务器错误信息 show errors; #查看服务器警告信息 show warnings; #修改数据库保护模式 set SQL_SAFE_UPDATES =0; 数据定义语句（DDL)数据表1234567Create table customers（ cust_id INT NOT NULL AUTO_INCREMENT, cust_name char(50) not null default china, cust_email char(50) null, primary key(cust_id))engine = InnoDB;#引擎为InnoDB 注： auto_incrment：自动增量，每个表只允许一个auto_increment，可通过select last_insert_id()获取该值。 指定默认值：default 更新表:alter table 12345678Alter table vendors ADD vend_phone char(20);Alter table vendors drop column vend_phone;Alter table 表名modify 列名 新类型 新参数；Alter table 表名 change 旧列名 新列名 新类型 新参数；Alter table 表名drop 列名；alter table products ADD CONSTRAINT fk_products_vendors Foreign key (vend_id) references vendors(vend_id);#更新外键rename table 旧表名 to 新表名；#重命名 视图12345Create view viewname AS 查询语句；Select * from viewname；#可以查看视图Show create view viewname；#查询创建视图语句Drop view viewname；#删除视图Update view set 列名=‘数据’ where条件； 存储过程1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556use crashcourse;delimiter // #改变分隔符(除\之外都可以作为分隔符)create procedure p5(out n5 decimal(8,2),in in_t char(1))#创建存储过程#in传入out传出begin if in_t = 'Y' then select avg(prod_price)into n5 from products; set @p=n5; #设置变量p else set n5 = 100; end if;end //delimiter ;call p5(@n5,'n');select @n5;select @p;drop procedure p5;show warnings;select * from products;delimiter //create procedure p3(in n int,in j char(1))begin if j = 'h' then select * from products where prod_price&lt;n; else select * from products where prod_price&gt;n; end if;end//## drop procedure p3//delimiter ;call p3(5,'f');#查看存储过程结果drop procedure p3;delimiter //create procedure p4(in n int)begin declare i int; declare j int; set i = 1; set j = 0; while i &lt;=n do set i = j+i; set i = i+1; end while;select j;end//delimiter ;call p4(100);drop procedure p4;show procedure status where db='crashcourse';#查看数据库的存储过程show errors;drop procedure p3; 游标(cursor,只能用于存储过程中，有开启就必须关闭)12345678910111213141516171819202122232425262728Declare cursorname cursor for 查询语句；use crashcourse;create table p_test(sid varchar(20));deLIMITER //create procedure products()begin declare a varchar(16); declare done INt default false;#default 设置默认值 declare cur cursor for select prod_id from products;#定义游标cur，语句为cursor for 查询语句 declare continue handler for not found set done = true; open cur; read_loop:loop#定义循环 fetch cur into a;#fetch 检索cur给变量a if done then#判断语句 leave read_loop;#结束循环 end if;#结束判断语句insert into p_test(sid) values(a);#插入a变量值到p_test表end loop;close cur;end//delimiter ;call products();select * from p_test;drop procedure products;drop table p_test;show procedure status where db=’crashcources’;#查看存储过程delete from p_test;#清空表show warnings; 触发器（对表操作）触发器响应的活动：insert、delete、update。before /after.每个表最多支持6个触发器。 1234Set @result = null;#定义变量，非触发器格式Create trigger tg after insert on products for each now selete ‘added’into @result;#红色部分为触发器，for each row 每行Show triggers;#查看触发器Drop trigger tg;#删除触发器 Insert触发器：可引用new的虚拟表，访问被插入的行；Before insert触发器中，new中的值可以被更新。Create tigger neworder after insert on orders for each row select new.order_num into @result;Delete触发器：可引用old表。 练习： 12345678910111213141516171819202122232425262728use crashcourse;set @result=null;create trigger tg after insert on s5 for each row selete ‘added’ into @result;select * from s5;insert into s5 values(11);select @result;drop trigger tg;show triggers;use crashcourse;set @result=null;create trigger tg before insert on s5 for each row selete new.price into @result;#引用new表select * from s5;insert into s5 values(11);select @result;drop trigger tg;show triggers;use crashcourse;set @result=null;create trigger tg before delete on s5 for each row selete old.price into @result;#引用old表select * from s5;insert into s5 values(11);delete from s5 where price=6;#删除数据select @result;drop trigger tg;show triggers; 数据检索语句(DQL)select检索数据 distinct——去除重复行，显示不重复的行。select distinct 列名 from 表名； limit——显示制定行数。select 列名 from limit n； #显示前n行select 列名 from limit n,m; #从第n行开始的m行（从0开始的） order by——结果排序。（ASCII码）select 列名 from 表名 order by 列名；select 列名 from 表名 order by 列名1，列名2； ASC——升序，降序——DESC，关键字排序只用于其前面的列名排序。 注：limit用于order by之后。 分组查询与子查询 创建分组：select vend_id,COUNT(*) AS num_prods from products GROUP BY vend_id with rollup;注：后面加上with rollup,可以汇总分组数据；group by 在where之后，order by 之前； 过滤分组：select vend_id,count(*) as num_prods from products where prod_price&gt;=10 group by vend_id having count(*)&gt;=2;注：having 针对分组结果，where针对列值。 子查询：in操作符,子查询常用于where子句的in操作符中，以及用来填充计算列。 1select cust_id from orders where order_num IN (select ordre_num from orderitems where prod_id =’TNT2’); 1select cust_name,cust_state,(select count(*) from orders where order.cust_id = customers.cust_id) AS orders from customers order by cust_name; 联结表 创建联结Select vend_name,prod_name,prod_price from vendors,products where vendors.vend_id = products.vend_id order by vend_nam,prod_name;笛卡尔积：去除联结条件，检索出的行数目为第一个表的行数乘以第二个表的行数。 内联结（等值联结）：INNER JOIN ONSELECT vend_name,prod_name,prod_price from vendors INNOR JOIN products ON vendors.vend_id = products.vend_id; 多表联结(表关联的越多，性能下降越厉害) 12345Select prod_name,vend_name,prod_price,quantity From orderitems,products,vendorsWhere products.vend_id = vendors.vend_idAND orderitems.prod_id = products.prod_idAND order_num = 20005; 表别名 12345Select cust_name,cust_contactFrom customers AS c,orders AS O,orderitems AS oiWhere c.cust_id = o.cust_idAND oou.order_num = o.order_numAND prod_id = ‘TNT2’; 自联结(自联结执行效率高于子查询) 12SECECT prod_id,prod_name from products where vend_id = (select vend_id from products where prod_id = ‘DTNTR’;Select p1.prod_id,p1.prod_name from products AS p1,products AS p2 where p1.vend_ud = p2.vend_id AND p2.prod_id = ‘DTNTR’; 外联结（左联结、右联结）左联结：SELECT customers.cus_id,orders.order_num from customers LEFT OUTER JOIN orders ON customers.cust_id = orders.order.cust_id;右联结：SELECT * from student RIGHT JOIN course ON student_id = course.student_id; 联合查询：UNION /UNION ALL（显示重复）注：查询条件列要一样，数据类型可以兼容，order by语句针对最终结果，不是对最后一个查询语句排序。 数据操作语句(DML)insert插入数据 插入完整行insert into 表名（列名）values（各个列的值）；#不需要按列名顺序插入insert into 表名 values（各个列的值）；#不给列名，按列名顺序插入 插入行的一部分 插入多行(逗号隔开)insert into 表名 values(各个列的值)，（各个列的值）； 插入查询得到的数据(插入时，是按照列进行插入，不是按照列名插入)insert into 表A（列1，列2） select 列1，列2 from表B； update更新数据update customers set cust_email = ‘elmer@fudd.com’ where cust_id = 1005;注：更新多行数据用逗号‘，‘隔开 delete删除数据 deletedelete from customers where cust_id =10006;#删除表中的行delete from customers;#清空表注：如果需要快速清空表，则采用truncate 语句，该方法比delete删除快；Truncate table 表名； #条件查询和通配符 #select 列名 from 表名 where 列满足的条件；注：同时使用order by 和where 字句时，order by 应位于where 之后，否则报错 操作符 操作符 含义 = 等于 &lt;&gt; 不等于 != 不等于 &lt; 小于 &lt;= 小于等于 &gt; 大于 &gt;= 大于等于 between 介于 and操作符select 列名 from 表名 where 条件1 and 条件2; or操作符（或）select 表名 from 表名 where 条件1 or 条件2；注：and优先级高于or，圆括号优先级高于and，优先执行圆括号内的条件同时出现and/or时，加括号语句更加严谨。 in操作符（指定条件范围）select 列 from 表 where 列 in (value1,value2,…); not操作符select * from crashcourse.products where vend_id not in(1002,1003);注：mysql中支持not对in、between、exists子句取反 like操作符（%通配符——不能匹配null）select 列 from 表 where prod_name LIKE ‘jet%’;select 列 from 表 where prod_name LIKE ‘%anvil$’;(_通配符——匹配单个字符)select 列 from 表 where prod_name like ‘_ ton anvil’; exists操作符select * from tableA Where exists(Select * From tableB Where tableB.ID=tableA.ID)；注：exists返回一个布尔值，为真则输出该语句结果，为假则不输出结果。in操作符时候查询内小外大的表，exists操作符适合查询内大外小的表。In确定给定的值是否与子查询或列表中的值相匹配。exists Exists指定一个子查询，检测行的存在，因此一般用*代替所有列。 数据控制语言(DCL)事务操作原子性、一致性、隔离性、持久性，只有InnoDB引擎支持事务操作。 rollback(回退) 123start transaction；insert、update、delete语句；rollback； commit(提交) 12set autocommit = 0;#禁止自动提交set autocommit = 1;#启动自动提交 savepoint（保留点） 12savepoint delete1；#使用保留点rollback delete1;#回退到保留点 练习： 123456789101112131415161718192021use crashcourse;select * from s5;start transaction;delete from s5;select * from s5;rollback;select * from s5;create table s6(sid varchar(10),sanme varchar(20));set autocommit =1;insert into s6 values(‘1001’,’zhangsan’);select * from s6;rollback;start transaction;insert into s6 values(‘1002’,’lisam’);savepoint in1;insert into s6 values(‘1003’,’wangwu’);rollback to in1;commit;delete from s6;select @@autocommit;#查看autocommit值 用户管理 管理用户 1234567891011Use mysql；Select user from user;Create user jack@localhost identified by ‘jack123’;Rename user jack@.localhost to peter@localhost;Update user set password = password(‘jacknewpassword’) where user = ‘jack’;#修改密码，password（‘jacknewpassword’）加密密码Set password for jack@localhost = Password(‘jacknewpassword’);#同上Drop user jack@localhost;Show grants for username;#查看权限Grant select on crashcourse.* to username；#授予crashcourse数据库select查询权限Revoke select，create on crashcourse.* from username;#grant与revoke反义 权限 整个服务器：grant all 和revoke all; 整个数据库：使用on 数据库名.*； 特定的表，使用on 数据库名.表名； 特定的列:grant select(cust_id) on *.* to jack@localhost; 特地的存储过程与函数:grant execute on procedure/fuction mydb.student to jack@localhost; 练习： 123456789101112131415use musql;select user from user;create user jack@localhost identified by ‘123’;select user from user;select user,password from user;grant select on crashcourse.* to jack;select *from student;update student set sname = ‘limin’ where sid = ‘3108001’;#error，无权限grant select(sname) on crashcourse.student to jack@localhost;select * from student;#errorselect sname from student;grant update(sanme) on crashcourse.student to jack@localhost;grant update on crashcourse.* to jack@localhost;update student set sname = ‘limin’ where sid = ‘3108001’;#可以更新update student set sid= ‘3105486’ where sname = ‘limin’;#error,无权限 MySQL正则表达式 正则表达式简介 正则表达式是用来匹配文本的特殊的字符集合，如果想从一个文本文件中提取电话号码，可以使用正则表达式来完成。 正则表达式作用 正则表达式的作用是匹配文本，讲一个正则表达式与一个文本串进行比较Mysql用where子句对正则表达式提供支持，允许指定正则表达式过滤select 查找出的数据 正则表达式格式 在where子句中使用REGEXP关键字，后面接正则表达式字符 正则表达式与like的区别 在where中可以使用like（not like ）和REGEXP(NOT REGEXP)来匹配特定的内容 like匹配整列数据 REGEXP可以匹配列中任意位置的文本 REGEXP更加灵活强大 Mysql中正则表达式不区分大小写,如果需要区分大小写，可在regexp后加binary。如：where prod_name regexp binary “JetPack .000”. 用法简介 使用‘|’，来匹配2个字符串的一个where prod_name regexp ‘1001|1002’; - 使用[],匹配几个字符中的一个 where prod_name REGEXP ‘[123]’ ton’; - 使用[^ ],不匹配几个字符中的任意一个 匹配一个范围，[1-9]1-9数字/[a-z]a-z字符 任意字符的匹配——‘\’如：. 表示.的转义字符 正则表达式字符集实例：Where prod_name regexp ‘[[:digit:]]{4};——连续四个数字 函数 concat（链接字段）select concat（vend_name,’(‘,vend_country,’)’） from vendors ORDER BY vend_name;trim——去掉字符串左右两边空格ltrim——去掉左边空格rtrim——去掉右边空格 列别名select concat（vend_name,’(‘,vend_country,’)’）AS evend_title from vendors ORDER BY vend_name; 算数计算（+ - /）`select prod_id,quantity,item_price,quantityitem_price AS expanded_price from orderitems where order_num =20005;` 文本处理函数Left(字符串，N) Right(字符串，N) ——返回串左（右）边的字符Select left(cust_address,3) from customers;Length（） ——返回串的长度Select vend_name,length(vend_name) as vend_name_length from crashcrouse,vendors;Locate（） ——找出串的一个子串Select vend_city,locate(‘o’,vend_city) from vendors;Trim() ltrim() rtrim() ——去掉空格Select trim(cust_address) from customers；Lower() upper() ——字符串大小写Select vend_name,upper(vend_name) as vend_name_upcase from croushcourse.vendors;Soundex（） ——返回串的soundex值Select cust_name,cust_contact from customers where soudex(cust_contact) = soundex(‘Y lie);Substring（） ——返回子串的字符 日期和时间处理函数Abs()——绝对值Cos()——余弦Exp（）——指数值Mod（）——余数Pi（）——圆周率Rand（）——随机数Sin（）——正弦Sqrt（）——平方根Tan（） ——正切例如：不需要from表。Select pi();Select rand(); 聚集函数Avg（）——平均值Count()——行数—count（*）表示对表的行数进行统计，count（列名）表示对该列中具体值进行统计。例如： 12select count(*) as num_cust from customers； #返回5select count(ust_email) as num_cust from customers； #返回3 注：null值被count（列名）忽略，而不被count（*）忽略。 Max（）——最大值Min（）——最小值Sum（）——列值求和DISTINCT参数：剔除重复Select avg(distinct prod_price) as avg_price from products where vend_id =1003;注：distinct适用于以上5种函数，但是不适用于count（*），必须使用别名，不能用户计算或表达式。 数据库维护 备份和恢复数据mysqldump –u root –p crashcourse&gt;/tmp/back.sql #备份数据库mysqldump –u root –p crashcourse Vendors&gt;table.sql#备份数据表mysql-uroot –p crashcourse&lt;/tmp/backup.sql#备份数据导入数据库 analyze table orders； optimize table orders; 配置文件：/etc/my.cnf 错误日志：/var/log/mysqld.log flush tables; flush logs; 注:Linux默认安装有mysql;Service mysql status #linux下查看mysql服务器开启情况Service mysql start #linux下启动mysql]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node.js读书笔记]]></title>
    <url>%2F2017%2F08%2F07%2FNode-js%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[一些NPM常用命令 NPM提供了很多命令，例如install和publish，使用npm help可查看所有命令。 使用npm help &lt;command&gt;可查看某条命令的详细帮助，例如npm help install。 在package.json所在目录下使用npm install . -g可先在本地安装当前命令行程序，可用于发布前的本地测试。 使用npm update &lt;package&gt;可以把当前目录下node_modules子目录里边的对应模块更新至最新版本。 使用npm update &lt;package&gt; -g可以把全局安装的对应命令行程序更新至最新版。 使用npm cache clear可以清空NPM本地缓存，用于对付使用相同版本号发布新版本代码的人。 使用npm unpublish &lt;package&gt;@&lt;version&gt;可以撤销发布自己发布过的某个版本代码。 文件操作小文件拷贝1234567891011var fs = require('fs');function copy(src, dst) &#123; fs.writeFileSync(dst, fs.readFileSync(src));&#125;function main(argv) &#123; copy(argv[0], argv[1]);&#125;main(process.argv.slice(2)); 豆知识： process是一个全局变量，可通过process.argv获得命令行参数。由于argv[0]固定等于NodeJS执行程序的绝对路径，argv[1]固定等于主模块的绝对路径，因此第一个命令行参数从argv[2]这个位置开始。 大文件拷贝1234567891011var fs = require('fs');function copy(src, dst) &#123; fs.createReadStream(src).pipe(fs.createWriteStream(dst));&#125;function main(argv) &#123; copy(argv[0], argv[1]);&#125;main(process.argv.slice(2)); 防止数据流内部的缓存爆仓12345678910111213141516var rs = fs.createReadStream(src);var ws = fs.createWriteStream(dst);rs.on('data', function (chunk) &#123; if (ws.write(chunk) === false) &#123; rs.pause(); &#125;&#125;);rs.on('end', function () &#123; ws.end();&#125;);ws.on('drain', function () &#123; rs.resume();&#125;); 如果写入速度跟不上读取速度的话，只写数据流内部的缓存会爆仓。我们可以根据.write方法的返回值来判断传入的数据是写入目标了，还是临时放在了缓存了，并根据drain事件来判断什么时候只写数据流已经将缓存中的数据写入目标，可以传入下一个待写数据了。 遍历文件目录同步遍历1234567891011efunction travel(dir, callback) &#123; fs.readdirSync(dir).forEach(function (file) &#123; var pathname = path.join(dir, file); if (fs.statSync(pathname).isDirectory()) &#123; travel(pathname, callback); &#125; else &#123; callback(pathname); &#125; &#125;);&#125; 异步遍历1234567891011121314151617181920212223function travel(dir, callback, finish) &#123; fs.readdir(dir, function (err, files) &#123; (function next(i) &#123; if (i &lt; files.length) &#123; var pathname = path.join(dir, files[i]); fs.stat(pathname, function (err, stats) &#123; if (stats.isDirectory()) &#123; travel(pathname, callback, function () &#123; next(i + 1); &#125;); &#125; else &#123; callback(pathname, function () &#123; next(i + 1); &#125;); &#125; &#125;); &#125; else &#123; finish &amp;&amp; finish(); &#125; &#125;(0)); &#125;);&#125;]]></content>
      <categories>
        <category>node.js</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>node.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node.js 循环的陷阱]]></title>
    <url>%2F2017%2F08%2F03%2F%E5%BE%AA%E7%8E%AF%E7%9A%84%E9%99%B7%E9%98%B1%2F</url>
    <content type="text"><![CDATA[前言&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Node.js 的异步机制由事件和回调函数实现，一开始接触可能会感觉违反常规，但习惯以后就会发现还是很简单的。然而这之中其实暗藏了不少陷阱，一个很容易遇到的问题就是循环中的回调函数，初学者经常容易陷入这个圈套。 例1让我们从一个例子开始说明这个问题。//forloop.js 123456789var fs = require('fs'); var files = ['a.txt', 'b.txt', 'c.txt']; for (var i = 0; i &lt; files.length; i++) &#123; fs.readFile(files[i], 'utf-8', function(err, contents) &#123; console.log(files[i] + ': ' + contents); &#125;); &#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这段代码的功能很直观，就是依次读取文件 a.txt、b.txt、c.txt，并输出文件名和内容。假设这三个文件的内容分别是 AAA、BBB 和 CCC，那么我们期望的输出结果就是： 12345a.txt: AAA b.txt: BBB c.txt: CCC 可是我们运行这段代码的结果是怎样的呢？竟然是这样的结果： 12345undefined: AAA undefined: BBB undefined: CCC &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个结果说明文件内容正确输出了，而文件名却不对，也就意味着， contents 的结果是正确的，但 files[i] 的值是 undefined 。这怎么可能呢，文件名不正确却能读取文件内容？ 例2既然难以直观地理解，我们就把 files[i] 分解并打印出来看看，在读取文件的回调函数中分别输出 files 、 i 和 files[i] 。 123456789101112//forloopi.js var fs = require('fs'); var files = ['a.txt', 'b.txt', 'c.txt']; for (var i = 0; i &lt; files.length; i++) &#123; fs.readFile(files[i], 'utf-8', function(err, contents) &#123; console.log(files); console.log(i); console.log(files[i]); &#125;); &#125; 运行修改后的代码，结果如下： 123456789[ 'a.txt', 'b.txt', 'c.txt' ] 3 undefined [ 'a.txt', 'b.txt', 'c.txt' ] 3 undefined [ 'a.txt', 'b.txt', 'c.txt' ] 3 undefined &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;看到这里是不是有点启发了呢？三次输出的 i 的值都是 3，超出了 files 数组的下标范围，因此 files[i] 的值就是 undefined 了。这种情况通常会在 for 循环结束时发生，例如 for (var i = 0; i &lt; files.length; i++) ，退出循环时 i 的值就是 files.length 的值。既然 i 的值是 3，那么说明了事实上 fs.readFile 的回调函数中访问到的 i 值都是循环退出以后的，因此不能分辨。而 files[i] 作为 fs.readFile 的第一个参数在循环中就传递了，所以文件可以被定位到，而且可以显示出文件的内容。 现在问题就明朗了：原因是3次读取文件的回调函数事实上是同一个实例，其中引用到的 i 值是上面循环执行结束后的值，因此不能分辨。 例3如何解决这个问题呢？我们可以利用 JavaScript 函数式编程的特性，手动建立一个闭包： 123456789101112//forloopclosure.js var fs = require('fs'); var files = ['a.txt', 'b.txt', 'c.txt']; for (var i = 0; i &lt; files.length; i++) &#123; (function(i) &#123; fs.readFile(files[i], 'utf-8', function(err, contents) &#123; console.log(files[i] + ': ' + contents); &#125;); &#125;)(i); &#125; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上面代码在 for 循环体中建立了一个匿名函数，将循环迭代变量 i 作为函数的参数传递并调用。由于运行时闭包的存在，该匿名函数中定义的变量（包括参数表）在它内部的函数（ fs.readFile 的回调函数）执行完毕之前都不会释放，因此我们在其中访问到的 i 就分别是不同闭包实例，这个实例是在循环体执行的过程中创建的，保留了不同的值。 事实上以上这种写法并不常见，因为它降低了程序的可读性，故不推荐使用。 例4大多数情况下我们可以用数组的 forEach 方法解决这个问题： 12345678910//callbackforeach.js var fs = require('fs'); var files = ['a.txt', 'b.txt', 'c.txt']; files.forEach(function(filename) &#123; fs.readFile(filename, 'utf-8', function(err, contents) &#123; console.log(filename + ': ' + contents); &#125;); &#125;);]]></content>
      <categories>
        <category>node.js</category>
      </categories>
      <tags>
        <tag>node.js</tag>
        <tag>异步机制</tag>
        <tag>循环</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何解决node.js中fs.rename文件跨域问题]]></title>
    <url>%2F2017%2F07%2F31%2F%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3node-js%E4%B8%ADfs-rename%E6%96%87%E4%BB%B6%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[前言&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最近在学习node.js，今天在写一个文件上传的功能，调用fs.rename上传文件时程序报了错。 具体如下： 123Error: EXDEV: cross-device link not permitted, rename 'C:\Users\Simple_Y\AppData\Local\Temp\12920-ww17q9.vtx0mb1emi.jpg' -&gt; 'E:\杨宇杰_备份2\光盘资源\Node.js实战\code\8\photo_app\public\photos\281295.jpg' at Error (native) 大致意思应该是说不能跨盘符上传文件，涉及到权限问题。 问题代码下面贴出我的代码(部分)： 12345678exports.submit = function (dir) &#123; return function(req, res, next)&#123; var img = req.files.photo.image; var name = req.body.photo.name || img.name; var path = join(dir, img.name); //fs.rename(img.path, path, function(err)&#123; //if (err) return next(err); 解决办法经过百度，终于找到了解决办法： 将上面的注释掉的两行代码换成下面的代码 1234567891011121314151617fs.readFile(img.path, function (err, data) &#123; if (err) throw err; console.log('File read!'); // Write the file fs.writeFile(path, data, function (err) &#123; if (err) throw err; res.write('File uploaded and moved!'); res.end(); console.log('File written!'); &#125;); // Delete the file fs.unlink(img.path, function (err) &#123; if (err) throw err; console.log('File deleted!'); &#125;); 结尾至此，运行程序，问题完美解决。 感谢万能的百度！ 参考链接：https://stackoverflow.com/questions/37153666/error-exdev-cross-device-link-not-permitted-rename-tmp-on-ubuntu-16-04-lts]]></content>
      <categories>
        <category>node.js</category>
      </categories>
      <tags>
        <tag>node.js</tag>
        <tag>fs.rename</tag>
        <tag>文件跨域</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何理解javascript中的闭包]]></title>
    <url>%2F2017%2F07%2F24%2F%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3javascript%E4%B8%AD%E7%9A%84%E9%97%AD%E5%8C%85%2F</url>
    <content type="text"><![CDATA[闭包（closure）是Javascript语言的一个难点，也是它的特色，很多高级应用都要依靠闭包实现。 一、变量的作用域要理解闭包，首先必须理解Javascript特殊的变量作用域。 变量的作用域无非就是两种：全局变量和局部变量。 Javascript语言的特殊之处，就在于函数内部可以直接读取全局变量。 Js代码 123456var n=999; function f1()&#123; alert(n); &#125; f1(); // 999 另一方面，在函数外部自然无法读取函数内的局部变量。 Js代码 12345function f1()&#123; var n=999; &#125; alert(n); // error 这里有一个地方需要注意，函数内部声明变量的时候，一定要使用var命令。如果不用的话，你实际上声明了一个全局变量！ Js代码 1234567 function f1()&#123; n=999; &#125; f1(); alert(n); // 999 二、如何从外部读取局部变量？出于种种原因，我们有时候需要得到函数内的局部变量。但是，前面已经说过了，正常情况下，这是办不到的，只有通过变通方法才能实现。 那就是在函数的内部，再定义一个函数。 Js代码 123456 function f1()&#123; n=999; function f2()&#123; alert(n); // 999 &#125; &#125; 在上面的代码中，函数f2就被包括在函数f1内部，这时f1内部的所有局部变量，对f2都是可见的。但是反过来就不行，f2内部的局部变量，对f1 就是不可见的。这就是Javascript语言特有的“链式作用域”结构（chain scope）， 子对象会一级一级地向上寻找所有父对象的变量。所以，父对象的所有变量，对子对象都是可见的，反之则不成立。 既然f2可以读取f1中的局部变量，那么只要把f2作为返回值，我们不就可以在f1外部读取它的内部变量了吗！ Js代码 12345678910 function f1()&#123; n=999; function f2()&#123; alert(n); &#125; return f2; &#125; var result=f1(); result(); // 999 三、闭包的概念上一节代码中的f2函数，就是闭包。 各种专业文献上的“闭包”（closure）定义非常抽象，很难看懂。我的理解是，闭包就是能够读取其他函数内部变量的函数。 由于在Javascript语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成“定义在一个函数内部的函数”。 所以，在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。 四、闭包的用途闭包可以用在许多地方。它的最大用处有两个，一个是前面提到的可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中。 怎么来理解这句话呢？请看下面的代码。 Js代码 12345678910111213141516 function f1()&#123; var n=999; nAdd=function()&#123;n+=1&#125; function f2()&#123; alert(n); &#125; return f2; &#125; var result=f1(); result(); // 999 nAdd(); result(); // 1000 在这段代码中，result实际上就是闭包f2函数。它一共运行了两次，第一次的值是999，第二次的值是1000。这证明了，函数f1中的局部变量n一直保存在内存中，并没有在f1调用后被自动清除。 为什么会这样呢？原因就在于f1是f2的父函数，而f2被赋给了一个全局变量，这导致f2始终在内存中，而f2的存在依赖于f1，因此f1也始终在内存中，不会在调用结束后，被垃圾回收机制（garbage collection）回收。 这段代码中另一个值得注意的地方，就是“nAdd=function(){n+=1}”这一行，首先在nAdd前面没有使用var关键字，因此 nAdd是一个全局变量，而不是局部变量。其次，nAdd的值是一个匿名函数（anonymous function），而这个 匿名函数本身也是一个闭包，所以nAdd相当于是一个setter，可以在函数外部对函数内部的局部变量进行操作。 五、使用闭包的注意点1）由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。 2）闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便 改变父函数内部变量的值。 六、思考题如果你能理解下面代码的运行结果，应该就算理解闭包的运行机制了。 Js代码 123456789101112 var name = "The Window"; var object = &#123; name : "My Object", getNameFunc : function()&#123; return function()&#123; return this.name; &#125;; &#125; &#125;; alert(object.getNameFunc()()); //The Window 常见的陷阱 看看这个： 乍一看，以为输出 0~9 ，万万没想到输出10个10？ 这里的陷阱就是：函数带()才是执行函数！ 单纯的一句 var f = function() { alert(‘Hi’); }; 是不会弹窗的，后面接一句 f(); 才会执行函数内部的代码。上面代码翻译一下就是： 为什么只垃圾回收了 result，但却不收了 i 呢？ 因为 i 还在被 function 引用着啊。好比一个餐厅，盘子总是有限的，所以服务员会去巡台回收空盘子，但还装着菜的盘子他怎么敢收？ 当然，你自己手动倒掉了盘子里面的菜（=null），那盘子就会被收走了，这就是所谓的内存回收机制。 至于 i 的值怎么还能保留，其实从文章开头一路读下来，这应该没有什么可以纠结的地方。盘子里面的菜，吃了一块不就应该少一块吗？ JavaScript闭包例子 12345678910function outerFun()&#123; var a=0; function innerFun() &#123; a++; alert(a); &#125; &#125;innerFun(); 上面的代码是错误的.innerFun()的作用域在outerFun()内部,所在outerFun()外部调用它是错误的. 改成如下,也就是闭包: Js代码 123456789101112131415161718192021function outerFun()&#123; var a=0; function innerFun() &#123; a++; alert(a); &#125; return innerFun; //注意这里&#125;var obj=outerFun();obj(); //结果为1obj(); //结果为2var obj2=outerFun();obj2(); //结果为1obj2(); //结果为2 什么是闭包: 当内部函数 在定义它的作用域 的外部 被引用时,就创建了该内部函数的闭包 ,如果内部函数引用了位于外部函数的变量,当外部函数调用完毕后,这些变量在内存不会被 释放,因为闭包需要它们. 再来看一个例子 Js代码 123456789function outerFun()&#123; var a =0; alert(a); &#125;var a=4;outerFun();alert(a); 结果是 0,4 . 因为在函数内部使用了var关键字 维护a的作用域在outFun()内部. 再看下面的代码: Js代码 1234567891011function outerFun()&#123; //没有var a =0; alert(a); &#125;var a=4;outerFun();alert(a); 结果为 0,0 真是奇怪,为什么呢? 作用域链是描述一种路径的术语,沿着该路径可以确定变量的值 .当执行a=0时,因为没有使用var关键字,因此赋值操作会沿着作用域链到var a=4; 并改变其值. -————————————————————————————————————————————————- 如果你对javascript闭包还不是很理解，那么请看下面转载的文章：(转载:http://www.felixwoo.com/archives/247) 七、什么是闭包？官方”的解释是：闭包是一个拥有许多变量和绑定了这些变量的环境的表达式（通常是一个函数），因而这些变量也是该表达式的一部分。相信很少有人能直接看懂这句话，因为他描述的太学术。其实这句话通俗的来说就是：JavaScript中所有的function都是一个闭包。不过一般来说，嵌套的function所产生的闭包更为强大，也是大部分时候我们所谓的“闭包”。看下面这段代码： 1234567function a() &#123; var i = 0; function b() &#123; alert(++i); &#125; return b;&#125;var c = a();c(); 这段代码有两个特点： 1、函数b嵌套在函数a内部； 2、函数a返回函数b。 引用关系如图： 这样在执行完var c=a()后，变量c实际上是指向了函数b，再执行c()后就会弹出一个窗口显示i的值(第一次为1)。这段代码其实就创建了一个闭包，为什么？因为函数a外的变量c引用了函数a内的函数b，就是说： 当函数a的内部函数b被函数a外的一个变量引用的时候，就创建了一个闭包。 让我们说的更透彻一些。所谓“闭包”，就是在构造函数体内定义另外的函数作为目标对象的方法函数，而这个对象的方法函数反过来引用外层函数体中的临时变量。这使得只要目标 对象在生存期内始终能保持其方法，就能间接保持原构造函数体当时用到的临时变量值。尽管最开始的构造函数调用已经结束，临时变量的名称也都消失了，但在目 标对象的方法内却始终能引用到该变量的值，而且该值只能通这种方法来访问。即使再次调用相同的构造函数，但只会生成新对象和方法，新的临时变量只是对应新 的值，和上次那次调用的是各自独立的。 八、闭包有什么作用？ 简而言之，闭包的作用就是在a执行完并返回后，闭包使得Javascript的垃圾回收机制GC不会收回a所占用的资源，因为a的内部函数b的执行需要依赖a中的变量。这是对闭包作用的非常直白的描述，不专业也不严谨，但大概意思就是这样，理解闭包需要循序渐进的过程。 在上面的例子中，由于闭包的存在使得函数a返回后，a中的i始终存在，这样每次执行c()，i都是自加1后alert出i的值。 那 么我们来想象另一种情况，如果a返回的不是函数b，情况就完全不同了。因为a执行完后，b没有被返回给a的外界，只是被a所引用，而此时a也只会被b引 用，因此函数a和b互相引用但又不被外界打扰(被外界引用)，函数a和b就会被GC回收。(关于Javascript的垃圾回收机制将在后面详细介绍) 九、闭包内的微观世界 如果要更加深入的了解闭包以及函数a和嵌套函数b的关系，我们需要引入另外几个概念：函数的执行环境(excution context)、活动对象(call object)、作用域(scope)、作用域链(scope chain)。以函数a从定义到执行的过程为例阐述这几个概念。 当定义函数a的时候，js解释器会将函数a的作用域链(scope chain)设置为定义a时a所在的“环境”，如果a是一个全局函数，则scope chain中只有window对象。 当执行函数a的时候，a会进入相应的执行环境(excution context)。 在创建执行环境的过程中，首先会为a添加一个scope属性，即a的作用域，其值就为第1步中的scope chain。即a.scope=a的作用域链。 然后执行环境会创建一个活动对象(call object)。活动对象也是一个拥有属性的对象，但它不具有原型而且不能通过JavaScript代码直接访问。创建完活动对象后，把活动对象添加到a的作用域链的最顶端。此时a的作用域链包含了两个对象：a的活动对象和window对象。 下一步是在活动对象上添加一个arguments属性，它保存着调用函数a时所传递的参数。 最后把所有函数a的形参和内部的函数b的引用也添加到a的活动对象上。在这一步中，完成了函数b的的定义，因此如同第3步，函数b的作用域链被设置为b所被定义的环境，即a的作用域。 到此，整个函数a从定义到执行的步骤就完成了。此时a返回函数b的引用给c，又函数b的作用域链包含了对函数a的活动对象的引用，也就是说b可以访问到a中定义的所有变量和函数。函数b被c引用，函数b又依赖函数a，因此函数a在返回后不会被GC回收。 当函数b执行的时候亦会像以上步骤一样。因此，执行时b的作用域链包含了3个对象：b的活动对象、a的活动对象和window对象，如下图所示： 如图所示，当在函数b中访问一个变量的时候，搜索顺序是： 先搜索自身的活动对象，如果存在则返回，如果不存在将继续搜索函数a的活动对象，依次查找，直到找到为止。 如果函数b存在prototype原型对象，则在查找完自身的活动对象后先查找自身的原型对象，再继续查找。这就是Javascript中的变量查找机制。 如果整个作用域链上都无法找到，则返回undefined。 小结，本段中提到了两个重要的词语：函数的定义与执行。文中提到函数的作用域是在定义函数时候就已经确定，而不是在执行的时候确定（参看步骤1和3）。用一段代码来说明这个问题： 123456function f(x) &#123; var g = function () &#123; return x; &#125; return g;&#125;var h = f(1);alert(h()); 这段代码中变量h指向了f中的那个匿名函数(由g返回)。 假设函数h的作用域是在执行alert(h())确定的，那么此时h的作用域链是：h的活动对象-&gt;alert的活动对象-&gt;window对象。 假设函数h的作用域是在定义时确定的，就是说h指向的那个匿名函数在定义的时候就已经确定了作用域。那么在执行的时候，h的作用域链为：h的活动对象-&gt;f的活动对象-&gt;window对象。 如果第一种假设成立，那输出值就是undefined；如果第二种假设成立，输出值则为1。 运行结果证明了第2个假设是正确的，说明函数的作用域确实是在定义这个函数的时候就已经确定了。 十、闭包的应用场景保护函数内的变量安全。以最开始的例子为例，函数a中i只有函数b才能访问，而无法通过其他途径访问到，因此保护了i的安全性。 在内存中维持一个变量。依然如前例，由于闭包，函数a中i的一直存在于内存中，因此每次执行c()，都会给i自加1。 通过保护变量的安全实现JS私有属性和私有方法（不能被外部访问） ​ 私有属性和方法在Constructor外是无法被访问的 12345678function Constructor(...) &#123; var that = this; var membername = value; function membername(...) &#123;...&#125;&#125; 以上3点是闭包最基本的应用场景，很多经典案例都源于此。 十一、Javascript的垃圾回收机制在Javascript中，如果一个对象不再被引用，那么这个对象就会被GC回收。如果两个对象互相引用，而不再被第3者所引用，那么这两个互相引用的对象也会被回收。因为函数a被b引用，b又被a外的c引用，这就是为什么函数a执行后不会被回收的原因。 十二、结语理解JavaScript的闭包是迈向高级JS程序员的必经之路，理解了其解释和运行机制才能写出更为安全和优雅的代码。]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>闭包</tag>
        <tag>funtion</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VMwave Workstation12虚拟机安装OS X 10.11所遇到的各种问题集合(详细版)]]></title>
    <url>%2F2017%2F07%2F24%2F10-11%E6%89%80%E9%81%87%E5%88%B0%E7%9A%84%E5%90%84%E7%A7%8D%E9%97%AE%E9%A2%98%E9%9B%86%E5%90%88-%E8%AF%A6%E7%BB%86%E7%89%88%2F</url>
    <content type="text"><![CDATA[一、前言最近笔者闲着无聊，由于一直挺仰慕mac大法，所以想装个mac系统来玩玩。虽然说过程不是很难，但是出现的各种小问题还是挺多的，所以在这里跟大家分享一下我的解决方法。 1.首先，当然是安装工具： Mac OS X 10.11 镜像文件（链接：http://pan.baidu.com/s/1pL8HE59 密码：cq4d）（此镜像为网络收集，如果觉得有问题自己找谢谢。） unlocker208文件（链接：http://pan.baidu.com/s/1bpftVjT 密码：dp2g） VMware Workstation12（http://blog.sina.com.cn/s/blog_af49f8090102wqmw.html） 2.详细教程请查看：http://jingyan.baidu.com/article/363872ec206a356e4ba16f30.html 在这里我就不再赘述。 二、所遇到的问题下面来看看我安装后遇到的各种问题： 1) VMware上MAC虚拟机不能上网问题首先最大的问题当然就是没网啦，别急，且听我慢慢道来： 解决方法/步骤1.从本机中选择打开连接网络，选择本地连接。如果是无线网可以选择无线网。 2.选择属性，点击共享按钮。 3.将internet连接共享下面两个选项都选中，然后在家庭网络连接选择VMware Network Adapter VMnet1。 4.在安装的虚拟机中选择虚拟机-&gt;设置选项。 5.点击网络适配器，将网络连接改成仅主机模式（Host-only），然后在右侧选择主机模式，点击确定。 6.进入Mac系统，选择设置，进入网络设置 7.配置Ipv4选择设置DHCP，点击应用即可开始上网。2)OS X 10.11 El Capitan 无法连接Apple store 和登录Apple ID的问题1.step 1强制退出Apple store进程 2. step 2打开terminal终端（在launch中搜索终端），输入以下命令： 123sudo pkill -9 -f Account sudo rm $HOME/Library/Accounts/* 进行此操作时需要提供管理员密码，输入密码敲回车就行了。 3.step 3完成前面两步你已经可以进入apple store了，但是你发现你的apple ID无法登陆： This action cant be Completed! 这时你可以terminal终端输入以下命令： 12345sudo mkdir -p /Users/Shared sudo chown root:wheel /Users/Shared sudo chmod -R 1777 /Users/Shared 至此，你的Apple ID就可以在Apple store上Login了。 3)苹果ID注册最后一步总是显示 如需帮助，请联系iTunes支持由于我的apple id是刚刚注册的，登陆apple store后提示我还没有完善资料什么的，所以我就去填资料 填完资料发现老是出现上面的那一句，继续不了。 所以我又开始了尝试 1.首先在iTunes软件上面注册Apple ID帐号时，注意要把提供付款方式选择为“银联UnionPay”，目前因为iTunes软件版本更新了不能像以前那样不绑定银行卡就可以注册Apple ID帐号。 2.然后填写银行卡以及输入银行预留手机号码。(注意：手机号码一定是要和银行卡绑定在一起的才可以使用。) 3.接下来在帐单寄送地址下方依次将个人的姓、名、街道地址、所在地区、邮编、省份、手机号码填写正确完整。 4.点击创建Apple ID，进入下一步。 5.然后收取绑定银行的短信验证码输入里面进行验证。 填入验证码就可以完美解决，我也试过用银行卡的方式，但是还是不行，最后尝试了银联这个就OK了。 三、补充对了，补充一下，可能安装后会发现虚拟机没办法占全屏，只要安装VMwave Tools既可以完美解决，至于卡顿问题，我笔记本是8G内存，我分了4G在虚拟机，相对来说比较不卡，也可以下载一个叫做beamoff的工具,在mac osx下解压即可消除卡顿的感觉。 下载链接 : http://download.csdn.NET/detail/u013803262/9702291 具体解决方法参考：http://blog.csdn.net/u013803262/article/details/53467693 好了，以上就是我装mac虚拟机所遇到的比较难缠的问题，分享给大家一下。]]></content>
      <categories>
        <category>装系统</category>
      </categories>
      <tags>
        <tag>VMwave</tag>
        <tag>OS X 10.11</tag>
        <tag>虚拟机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[将应用程序部署到Heroku]]></title>
    <url>%2F2017%2F07%2F22%2F%E5%B0%86%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E9%83%A8%E7%BD%B2%E5%88%B0Heroku%2F</url>
    <content type="text"><![CDATA[1.注册1.1在http://api/heroku.com/signup注册Hero帐号 1.2访问邮件中的链接并输入密码 1.3从 http://devcenter.heroku.com/articles/quickstart#step_2_install_the_heroku_toolbelt 为你的平台安装安装程序。 1.4打开终端窗口并登陆到Heroku 1heroku login 2.配置12345678910111213141516171.在app.js文件的顶部，添加如下行：var port = (process.env.PORT || 3000);2.将下列行从app.js中移除:app.listen(3000);3.用下列行替换它：app.listen(port);4.在应用程序的根目录中，添加一个名为Procfile的文件并加入如下内容：web: node app.js5.用如下命令安装依赖模块：npm install6.启动应用程序并检查其是否运行正常：node app.js 3.将应用程序提交到heroku1234567891011123.1使用如下命令创建Git库：git initgit add .git commit -m &quot;initial commit&quot;3.2使用如下命令在Heroku上创建应用程序。注意从这一命令返回的URL:heroku create --stack cedar3.3用如下命令将站点发布到Heroku：git push heroku master3.4访问之前得到的URL，可看到所部署的网站了！]]></content>
      <categories>
        <category>node.js</category>
      </categories>
      <tags>
        <tag>node.js</tag>
        <tag>Heroku</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Oracle学习笔记(六)]]></title>
    <url>%2F2017%2F07%2F20%2FOracle%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%85%AD%2F</url>
    <content type="text"><![CDATA[46.异常(1)12345678910111213141516171819declare v_temp number(4); begin select empno into v_temp from emp where deptno = 10; exception when too_many_rows then dbms_output.put_line('太多记录了'); when others then dbms_output.put_line('error'); end; (2)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475 declare v_tempnumber(4); begin select empno into v_temp from emp where empno = 2222; exception when no_data_found then dbms_output.put_line('没有该项数据'); end;----------------错误记录日志(用表记录：将系统日志存到数据库便于以后查看) ----------- 创建序列（用来处理递增的ＩＤ）： create sequence seq_errorlog_id start with 1 increment by 1; 创建日志表: create table errorlog ( id number primary key, errcode number, errmsg varchar2(1024), errdate date ); 示例程序： declare v_deptno dept.deptno%type := 10; v_errcode number; v_errmsg varchar2(1024); begin delete from dept where deptno = v_deptno; commit; exception when others then rollback; v_errcode:= SQLCODE; v_errmsg:= SQLERRM; insert into errorlog values (seq_errorlog_id.nextval, v_errcode,v_errmsg, sysdate); commit; end; 47. PL/SQL中的重点cursor(游标)和指针的概念差不多123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293declare cursorc isselect * from emp; //此处的语句不会立刻执行，而是当下面的open c的时候，才会真正去数据库中取数据 v_emp c%rowtype; begin open c; fetch c into v_emp;dbms_output.put_line(v_emp.ename); //这样会只输出一条数据 134将使用循环的方法输出每一条记录 close c; end;----------------------使用do while 循环遍历游标中的每一个数据--------------------- declare cursor c is select* from emp; v_emp c%rowtype; begin open c; loop fetch c into v_emp;(1) exit when(c%notfound); //notfound是oracle中的关键字，作用是判断是否还有下一条数据(2) dbms_output.put_line(v_emp.ename); //(1)(2)的顺序不能颠倒，否则会把最后一条结果再多打印一次。 end loop; close c; end;------------------------使用while循环，遍历游标--------------------- declare cursor c is select* from emp; v_emp emp%rowtype; begin open c; fetch c into v_emp; while(c%found) loop dbms_output.put_line(v_emp.ename); fetch c into v_emp; end loop; close c; end;s------------------------使用for 循环，遍历游标（最方便快捷的方法！）----------------- declare cursorc is select * from emp; begin for v_emp in c loop dbms_output.put_line(v_emp.ename); endloop; end; 带参数的游标（相当于函数）1234567891011121314151617declare cursor c(v_deptno emp.deptno%type, v_job emp.job%type) is select ename, sal from emp where deptno=v_deptno and job=v_job; begin forv_temp in c(30, 'CLERK') loop dbms_output.put_line(v_temp.ename); endloop;end; 可更新的游标123456789101112131415161718192021222324252627declare cursorc is select * from emp2 for update; begin for v_temp in c loop if(v_temp.sal&lt; 2000) then update emp2 set sal = sal * 2 where current of c; elsif (v_temp.sal =5000) then deletefrom emp2 where current of c; end if; end loop; commit; end; 48. store procedure存储过程(带有名字的程序块)12345678910111213141516171819202122232425262728293031323334353637383940414243createor replace procedure p is--除了这两句替代declare，下面的语句全部都一样 cursor c is select * from emp2 for update; begin for v_emp in c loop if(v_emp.deptno= 10) then updateemp2 set sal = sal +10 where current of c; elseif(v_emp.deptno =20) then updateemp2 set sal = sal + 20 where current ofc; else updateemp2 set sal = sal + 50 where current of c; endif; end loop; commit; end; 执行存储过程的两种方法： （1）exec p;(p是存储过程的名称) （2）begin p; end; / 带参数的存储过程先创建存储过程：（in标识传入参数，out标识传出参数，默认为传入参数） 12345678910111213141516171819202122232425262728293031323334353637383940414243 createor replace procedure p (v_ain number, v_b number, v_ret out number, v_temp inout number) is begin if(v_a&gt; v_b) then v_ret:= v_a; else v_ret:= v_b; endif; v_temp:= v_temp + 1; end;再调用： declare v_a number := 3; v_b number := 4; v_retnumber; v_tempnumber := 5; begin p(v_a,v_b, v_ret, v_temp); dbms_output.put_line(v_ret); dbms_output.put_line(v_temp); end; 删除存储过程​ dropprocedure p; 49. 创建函数计算个人所得税的税率12345678910111213141516171819202122232425createor replace function sal_tax (v_sal number) returnnumber is begin if(v_sal&lt; 2000) then return0.10; elsif(v_sal&lt;2750) then return0.15; else return0.20; endif; end; 50. 创建触发器（trigger）触发器不能单独的存在，必须依附在某一张表上 写主语 谓语 宾语 游戏 ​ 创建触发器的依附表： 1234567891011121314151617181920212223242526272829303132 createtable emp2_log ( enamevarchar2(30) , eactionvarchar2(20), etimedate ); create or replace trigger trigafter insert or delete orupdate on emp2 for each row --加上此句，每更新一行，触发一次，不加入则值触发一次 begin ifinserting then insertinto emp2_log values(USER, 'insert', sysdate); elsifupdating then insertinto emp2_log values(USER, 'update', sysdate); elsifdeleting then insertinto emp2_log values(USER, 'delete', sysdate); endif; end; 51.触发器用法之一：通过触发器更新约束的相关数据12345678910111213createor replace trigger trig afterupdate on dept foreach row begin updateemp set deptno =:NEW.deptno where deptno =: OLD.deptno; end; --只编译不显示的解决办法 set serveroutput on; 52.通过创建存储过程完成递归123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263 createor replace procedure p(v_pid article.pid%type,v_level binary_integer) is cursorc is select * from article where pid = v_pid; v_preStrvarchar2(1024) := ''; begin for i in 0..v_leave loop v_preStr:= v_preStr || ''; end loop; for v_article in c loop dbms_output.put_line(v_article.cont); if(v_article.isleaf= 0) then p(v_article.id); endif; endloop; end;-------------------------------查看当前用户下有哪些表--- 首先，用这个用户登录然后使用语句： select* from tab; -----------------------------用Oracle进行分页！-------------- 因为Oracle中的隐含字段rownum不支持'&gt;'所以： select* from ( selectrownum rn, t.* from ( select* from t_user where user_id &lt;&gt; 'root' )t where rownum &lt;6 )where rn &gt;3------------------------Oracle下面的清屏命令---------------- clearscreen; 或者 cle scr; -----------将创建好的guohailong的这个用户的密码改为abc-------------- alter user guohailong identified by abc --当密码使用的是数字的时候可能会不行]]></content>
      <categories>
        <category>Oracle</category>
      </categories>
      <tags>
        <tag>Oracle sql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Oracle学习笔记(五)]]></title>
    <url>%2F2017%2F07%2F19%2FOracle%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BA%94%2F</url>
    <content type="text"><![CDATA[PL_SQL(过程化SQL语言)38. 在客户端输出helloworld12345678910111213141516171819202122232425 set serveroutput on;//默认是off，设成on是让Oracle可以在客户端输出数据 begin dbms_output.put_line('helloworld'); end; /----------------pl/sql变量的赋值与输出---- declare v_name varchar2(20);//声明变量v_name变量的声明以v_开头 begin v_name:= 'myname'; dbms_output.put_line(v_name); end; / 39. pl/sql对于异常的处理(除数为0)12345678910111213141516171819 declare v_num number := 0; begin v_num:= 2/v_num; dbms_output.put_line(v_num);** exception**** when others then**** dbms_output.put_line('error');** end; / 40. 变量的声明​ binary_integer:整数，主要用来计数而不是用来表示字段类型 比number效率高 ​ number:数字类型 ​ char:定长字符串 ​ varchar2：变长字符串 ​ date：日期 ​ long：字符串，最长2GB ​ boolean：布尔类型，可以取值true，false，null//最好给一初值 12345678910111213141516171819----------变量的声明，使用 '%type'属性--------- declare v_empno number(4); v_empno2 emp.empno%type; v_empno3 v_empno2%type; begin dbms_output.put_line('Test'); end; / --使用%type属性，可以使变量的声明根据表字段的类型自动变换，省去了维护的麻烦，而且%type属性，可以用于变量身上 41.组合变量1234567891011121314151617---------------Table变量类型(相当于java里面的数组)-------------------- declare type type_table_emp_empno is table of emp.empno%type index by binary_integer; v_empnostype_table type_table_empno; begin v_empnos(0):= 7345; v_empnos(-1):=9999; dbms_output.put_line(v_empnos(-1)); end; 42. Record变量类型（相当于Java里面的类）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647 declare type type_record_dept is record ( deptno dept.deptno%type, dname dept.dname%type, loc dept.loc%type ); v_temp type_record_dept; begin v_temp.deptno:=50; v_temp.dname:='aaaa'; v_temp.loc:='bj'; dbms_output.put_line(v_temp.deptno|| ' ' || v_temp.dname); end; -----------使用 %rowtype声明record变量，直接参照表来声明record------------------- declare v_temp dept%rowtype; begin v_temp.deptno:=50; v_temp.dname:='aaaa'; v_temp.loc:='bj'; dbms_output.put_line(vtemp.deptno || '' || v temp.dname) end; ​ 43. select语句的运用(必须保证select语句有相应的返回记录)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667 declare v_ename emp.ename%type; v_sal emp.sal%type; begin select ename,sal into v_ename,v_sal from emp where empno = 7369; dbms_output.put_line(v_ename|| '' || v_sal); end;-------------------------select语句的应用（record）------------------------------ declare v_emp emp%rowtype; begin select * into v_emp from emp where empno=7369; dbms_output_line(v_emp.ename); end; ------------- insert语句的应用 ----------------------------- declare v_deptno dept.deptno%type := 50; v_dname dept.dname%type :='aaa'; v_loc dept.loc%type := 'bj'; begin insert into dept2 values(v_deptno,v_dname,v_loc); commit; end; -------------update 语句的应用------------------------------ declare v_deptno emp2.deptno%type := 50; v_count number; begin update emp2 set sal = sal/2 where deptno =v_deptno; dbms_output.put_line(sql%rowcount || ‘条记录被影响’); commit; end; 注：sql%rowcount统计上一条sql语句更新的记录条数 44.ddl语言，数据定义语言12345678910111213141516171819202122232425262728293031 begin execute immediate 'create table T (nnn varchar(30) default ''a'')'; end;------------------ifelse语句-------------------------------------- declare v_sal emp.sal%type; begin select sal into v_sal from emp where empno = 7369; if(v_sal&lt; 2000) then dbms_output.put_line('low'); els if(v_sal &gt; 2000) then dbms_output.put_line('middle'); else dbms_output.put_line('height'); end if; end; 45. 循环do while 循环1234567891011121314151617declare i binary_integer := 1; begin loop dbms_output.put_line(i); i:= i + 1; exit when (i&gt;=11); end loop; end; while 循环123456789101112131415declare j binary_integer := 1; begin while j &lt; 11 loop dbms_output.put_line(j); j:=j+1; end loop; end; for 循环123456789101112131415begin for k in 1..10 loop dbms_output.put_line(k); end loop; for k in reverse 1..10 loop dbms_output.put_line(k); end loop; end;]]></content>
      <categories>
        <category>Oracle</category>
      </categories>
      <tags>
        <tag>Oracle sql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Oracle学习笔记(四)]]></title>
    <url>%2F2017%2F07%2F18%2FOracle%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9B%9B%2F</url>
    <content type="text"><![CDATA[24.——-创建新用户——–123456789101112131、backup scott//备份 exp//导出2、create user createuser guohailong identified(认证) by guohailong default table space users quota(配额) 10M on users grant create session(给它登录到服务器的权限),create table, create view to guohailong3、import data Imp 25. ——-取消操作——–123456789101112131415161718192021222324252627282930313233343536373839404142434445464748rollback-----------事务确认语句-------- commit;//此时再执行rollback无效当正常断开连接的时候例如exit,事务自动提交。 当非正常断开连接，例如直接关闭dos窗口或关机，事务自动提交 -----表的备份 create table dept2 as select * from dept;-----插入数据 insert into dept2 values(50,'game','beijing'); ----只对某个字段插入数据 insert into dept2(deptno,dname) values(60,'game2');-----将一个表中的数据完全插入另一个表中（表结构必须一样） insert into dept2 select * from dept;-----求前五名员工的编号和名称（使用伪字段rownum 只能使用 &lt; 或 = 要使用 &gt; 必须使用子查询） select empno,ename from emp where rownum &lt;= 5;----求10名雇员以后的雇员名称-------- select ename from (select rownum r,ename from emp) where r &gt; 10;----求薪水最高的前5个人的薪水和名字--------- select ename, sal from (select ename, sal from emp order by sal desc) where rownum&lt;=5; ----求按薪水倒序排列后的第6名到第10名的员工的名字和薪水-------- selectename, sal from (select ename, sal, rownum r from (select ename, sal from emp orderby sal desc) ) where r&gt;=6 and r&lt;=10 26. ——-面试题——–​ 有3个表S，C，SC ​ S（SNO，SNAME）代表（学号，姓名） ​ C（CNO，CNAME，CTEACHER）代表（课号，课名，教师） ​ SC（SNO，CNO，SCGRADE）代表（学号，课号成绩） ​ 问题： ​ 1，找出没选过“黎明”老师的所有学生姓名。 ​ 2，列出2门以上（含2门）不及格学生姓名及平均成绩。 ​ 3，即学过1号课程有学过2号课所有学生的姓名。 ​ 答案： 1234567891011121、 select sname from s join sc on(s.sno =sc.sno) join c on (sc.cno = c.cno) where cteacher &lt;&gt; '黎明';2、 select sname where sno in (select sno from sc where scgrade &lt; 60 group by sno having count(*) &gt;=2);3、 select sname from s where sno in (select sno, from sc where cno=1 and cno in (select distinct sno from sc where cno = 2); ) 27. ——–创建表———–123456789101112131415161718192021create table stu(id number(6),name varchar2(20) constraint stu_name_mmnot null,sex number(1),age number(3),sdate date,grade number(2) default 1,class number(4),email varchar2(50) unique ); 28. 五种约束条件：非空约束、唯一约束、主键约束、外键约束、检查约束（check）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273--------------给name字段加入 非空 **约束**，并给约束一个名字，若不取，系统默认取一个------------- create table stu ( id number(6), name varchar2(20) constraint stu_name_mm not null, sex number(1), age number(3), sdate date, grade number(2) default 1, class number(4), email varchar2(50) );--------------给nameemail字段加上唯一约束两个 null值 不为重复------------- create table stu ( id number(6), name varchar2(20) constraint stu_name_mmnot null, sex number(1), age number(3), sdate date, grade number(2) default 1, class number(4), email varchar2(50) unique );--------------两个字段的组合不能重复 约束：表级约束------------- create table stu ( id number(6), name varchar2(20) constraint stu_name_mmnot null, sex number(1), age number(3), sdate date, grade number(2) default 1, class number(4), email varchar2(50)， constraint stu_name_email_uni unique(email,name) ); 29. ——-主键约束——–​ 12345678910111213141516171819202122232425create table stu ( id number(6), name varchar2(20) constraint stu_name_mmnot null, sex number(1), age number(3), sdate date, grade number(2) default 1, class number(4), email varchar2(50), constraint stu_id_pk primary key (id), constraintstu_name_email_uni unique(email, name) ); 30.—外键约束 被参考字段必须是主键—123456789101112131415161718192021222324252627282930313233343536373839create table stu(id number(6),name varchar2(20) constraint stu_name_mmnot null,sex number(1),age number(3),sdate date,grade number(2) default 1,class number(4) references class(id),email varchar2(50), constraint stu_class_fk foreign key (class) references class(id), constraint stu_id_pk primary key (id), constraint stu_name_email_uni unique(email, name) ); 红色为字段约束的写法，蓝色为表级约束的写法 createtable class ( idnumber(4) primary key, namevarchar2(20) not null ); 31. 修改表结构12345678910111213141516171819---------------添加字段-------------------------- altertable stu add(addr varchar2(29));---------------删除字段-------------------------- altertable stu drop (addr);---------------修改表字段的长度------------------ altertable stu modify (addr varchar2(50));//更改后的长度必须要能容纳原先的数据----------------删除约束条件---------------- altertable stu drop constraint 约束名-----------修改表结构添加约束条件--------------- altertable stu add constraint stu_class_fk foreign key (class) references class(id); 32. 数据字典表（有user_tables、user_views、user_constraints等等）12345678910111213141516---------------查看当前用户下面所有的表、视图、约束-----数据字典表user_tables--- select table_name from user_tables; select view_name from user_views; select constraint_name from user_constraints; 存储数据字典表的信息的表：dictionary; //该表共有两个字段 table_name comments //table_name主要存放数据字典表的名字 //comments主要是对这张数据字典表的描述 ​ 33. 索引(能优化查询效率)12345678910111213create index idx_stu_email on stu (email);// 在stu这张表的email字段上建立一个索引：idx_stu_email---------- 删除索引 ------------------ drop index index_stu_email;---------查看所有的索引---------------- select index_name from user_indexes;---------创建视图------------------- create view v$stu as select id,name,age from stu; ​ 视图的作用: 简化查询，保护我们的一些隐私数据，通过视图也可以用来更新数据，但是我们一般不这么用 缺点：要对视图进行维护 34.创建序列（sequence，oracle特有的东西，一般用来做主键）​ 12345678910111213create sequence seq;//创建序列 select seq.nextval from dual;// 查看seq序列的下一个值 drop sequence seq;//删除序列 create table article ( id number, title varchar2(1024),cont long); create sequence seq; insert into article (id,title,cont) values(seq.nextval , ‘a’, ‘b’); 35. 数据库的三范式​ （1）要有主键，列不可分 ​ （2）不能存在部分依赖：当有多个字段联合起来作为主键的时候，不是主键的字段不能部分依赖于主键中的某个字段 ​ （3）不能存在传递依赖]]></content>
      <categories>
        <category>Oracle</category>
      </categories>
      <tags>
        <tag>Oracle sql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Oracle学习笔记(三)]]></title>
    <url>%2F2017%2F07%2F18%2FOracle%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%89%2F</url>
    <content type="text"><![CDATA[12. SQL1999_table_connections123select ename, dname,grade from emp e,deptd, salgrade swhere e.deptno = d.deptno and e.sal between s.losal and s.hisal and job &lt;&gt; 'CLERK' ​ 有没有办法把过滤条件和连接条件分开来? 出于这样考虑,Sql1999标准推出来了.有许多人用的还是 旧的语法,所以得看懂这种语句. 1234567891011select ename,dname from emp,dept;(旧标准).select ename,dname from emp** cross join** dept;(1999标准)select ename,dname from emp,dept where emp.deptno=dept.deptno (旧)select ename,dname from emp join dept on(emp.deptno = dept.deptno); 1999标准.没有Where语句.select ename,dname from emp join dept using(deptno);等同上句,但不推荐使用.select ename,grade from emp e join salgrade s on(e.sal between s.losal and s.hisal); ​ join 连接语句, on过滤条件。连接，条件一眼分开。如果用Where语句较长时，连接语句和过滤语句混在一起。​ 三张表连接： 1234567slect ename, dname, grade fromemp e join dept d on(e.deptno=d.deptno)join salgrade s on(e.sal between s.losal and s.hisal)where ename not like '_A%'; ​ 把每张表连接 条件不混在一起，然后数据过滤条件全部区分开来。读起来更清晰，更容易懂一点。 123 select e1.ename,e2.ename from emp e1 join emp e2on(e1.mgr = e2.emptno); ​ 左外连接：会把左边这张表多余数据显示出来。 123 select e1.ename,e2.ename from emp e1 left joinemp e2 on(e1.mgr =e2.empno);left 后可加outer ​ 右外连接：把右边这张表多余数据显示出来。 123 select ename,dname from emp e right outer join dept don(e.deptno =d.deptno); outer可以取掉。 ​ 全外连接： 即把左边多余数据，也把右边多余数据拿出来， 123 select ename,dname from emp e full join dept don(e.deptno =d.deptno); PS：所谓的“外”连接，即把多余的数据显示出来。Outer关键字可以省略。 13. 求部门中哪些人的薪水最高123select ename, sal from empjoin (select max(sal) max_sal, deptno from emp group by deptno) ton (emp.sal = t.max_sal and emp.deptno = t.deptno) 14. 求部门平均薪水的等级123select deptno,avg_sal,grade from (select deptno,avg(sal) avg_sal from emp group by deptno)t join salgrade s on(t.avg_sal between s.losal and s.hisal) 15. 求部门平均的薪水的平均等级123select deptno,avg(grade) from (select deptno,ename, grade from emp join salgrade s on(emp.sal between s.losal and s.hisal)) tgroup by deptno 16. 哪些人是经理12select ename from emp where empno in(select mgr from emp);select ename from emp where empno in(select distinct mgr from emp); 17.不准用组函数，求薪水的最高值（面试题）12select distinct sal from emp where sal not in(select distinct e1.sal from emp e1 join emp e2 on (e1.sal&lt;e2.sal)); 18.平均薪水最高的部门编号123456select deptno,avg_sal from(select avg(sal)avg_sal,deptno from emp group by deptno)where avg_sal=(select max(avg_sal)from (select avg(sal) avg_sal,deptno from emp group by deptno)) 19.平均薪水最高的部门名称123456789 select dname from dept where deptno=( select deptno from (select avg(sal)avg_sal,deptno from emp group by deptno) where avg_sal= (select max(avg_sal)from (select avg(sal) avg_sal,deptno from emp group by deptno) ) ) 20.求平均薪水的等级最低的部门的部门名称12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455 --组函数嵌套 --如：平均薪水最高的部门编号，可以E.更简单的方法如下： select deptno,avg_sal from (select avg(sal) avg_sal,deptno from emp group by deptno) where avg_sal = (select max(avg(sal)) from emp group by deptno) 组函数最多嵌套两层 -- 分析： -- 首先求 --1.平均薪水： select avg(sal) from emp group by deptno; -- 2.平均薪水等级： 把平均薪水当做一张表，需要和另外一张表连接salgrade select deptno,grade,avg_sal from ( select deptno,avg(sal) avg_sal from emp group by deptno) t join salgrade s on(t.avg_sal between s.losal and s.hisal) -- 上面结果又可当成一张表。 -- DEPTNO GRADE AVG_SAL -------- ------- ---------- -- 30 3 1566.66667 -- 20 4 2175 -- 10 4 2916.66667 -- 3.求上表平均等级最低值 select min(grade) from ( select deptno,grade,avg_sal from (select deptno,avg(sal) avg_sal from emp group by deptno)t join salgrade s on(t.avg_sal between s.losal and s.hisa) ) -- 4.把最低值对应的2结果的那张表的对应那张表的deptno, 然后把2对应的表和另外一张表做连接。 select dname ,deptno,grade,avg_sal from ( select deptno,grade,avg_sal from (select deptno,avg(sal) avg_sal from emp group by deptno)t join salgrade s on(t.avg_sal between s.losal and s.hisal) ) t1 join dept on (t1.deptno = dept.deptno) where t1.grade = ( select deptno,grade,avg_sal from (select deptno,avg(sal) avg_sal from emp group by deptno) t join salgrade s on(t.avg_sal between s.losal and s.hisal) ) )-- 结果如下： -- DNAME DEPTNO GRADE AVG_SAL-- -------- ------- -------- ---------- SALES 30 3 1566.6667 21. 视图（视图就是一张表，一个字查询）【 ​ 默认scott账户没有创建视图的权限，可通过如下语句授权：​ 首先登陆超级管理员：conn sys/用户密码 as sysdba;​ 授权：grant create table,create view to scott;​ 再以scott账户登陆：conn scott/tiger 】 12345678910111213141516171819202122232425262728-- 20中语句有重复，可以用视图来简化。 conn sys/bjsxt as sysdba; grant create table,create view to scott; conn scott/tiger-- 创建视图： create view v$_dept_avg-sal_info as select deptno,grade,avg_sal from ( select deptno,avg(sal) avg_sal from emp group by deptno)t join salgrade s on 9t.avg_sal between s.losal and s.hisal) -- 然后 select * from v$_dept_avg-sal_info -- 结果如下：-- DEPTNO GRADE AVG_SAL-- -------- ------- ------------ 30 3 1566.66667-- 20 4 2175-- 10 4 2916.66667-- 然后G中查询可以简化成： select dname,t1.deptno,grade,avg_sal from v$_dept_avg-sal_info t1 join dept on t1.deptno =dept.deptno) where t1.grade= ( select min(grade) from v$_dept_avg-sal_info t1 ) 22. 求比普通员工最高薪水还要高的经理人的名称1234567select ename, sal from emp where empno in (select distinct mgr from emp where mgr is not null) and sal &gt; ( select max(sal) from emp where empno not in (select distinct mgr from emp where mgr is not null) ) 23. 面试题：比较效率理论上前一句效率高，但实际上可能Oracle可能会自动对代码优化，所以不见得后一句就会慢。 12select * from emp where deptno = 10 and ename like '%A%'; --效率高，因为将过滤力度大的放在前面select * from emp where ename like '%A% and deptno = 10;]]></content>
      <categories>
        <category>Oracle</category>
      </categories>
      <tags>
        <tag>Oracle sql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Oracle学习笔记(二)]]></title>
    <url>%2F2017%2F07%2F17%2FOracle%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[8. Group by语句//需求:现在想求每个部门的平均薪水. 12345678910111213 select avg(sal) from emp group by deptno; select deptno avg(sal) from emp group by deptno; select deptno,job,max(sal) from emp group by deptno,job; 求薪水值最高的人的名字.select ename,max(sal) from emp;出错,因为max只有一个值,但等于max值的人可能好几个,不能匹配.应如下求:select ename from emp where sal=(select max(sal) from emp);Group by语句应注意,出现在select中的字段,如果没出现在组函数中,必须出现在Group by语句中. 9. Having 对分组结果筛选1Where是对单条纪录进行筛选,Having是对分组结果进行筛选. 12345678910select avg(sal),deptno from emp group by deptno having avg(sal)&gt;2000;查询工资大于1200雇员,按部门编号进行分组,分组后平均薪水大于1500,按工薪倒充排列.select * from emp where sal&gt;1200group by deptnohaving avg(sal)&gt;1500order by avg(sal) desc; 10. 字查询​ 谁挣的钱最多(谁:这个人的名字, 钱最多) 1select 语句中嵌套select 语句,可以在where,from后. ​ 问哪些人工资,在平均工资之上. 1select ename,sal from emp where sal&gt;(select avg(sal) from emp); 1234567891011//查找每个部门挣钱最多的那个人的名字.select ename ,deptno from emp where sal in(select max(sal) from ename group by deptno) //查询会多值.//应该如下:select max(sal),deptno from emp group by deptno;//当成一个表.语句如下:select ename, sal from emp join(select max(sal) max_sal,deptno from emp groupby deptno) t on(emp.sal=t.max_sal and emp.deptno=t.deptno); //每个部门的平均薪水的等级. //分析:首先求平均薪水(当成表),把平均薪水和另外一张表连接. 11. self_table_connection把某个人的名字以及他的经理人的名字求出来(经理人及这个人在表中同处一行) 分析:首先求出这个人的名字,取他的编号,然后从另一张表与其相对应编号,然后找到经理的名字. 1select e1.ename ,e2.ename from emp e1,emp e2 where e1.mgr= e2.empno. //empno编号和MGR都是编号.]]></content>
      <categories>
        <category>Oracle</category>
      </categories>
      <tags>
        <tag>Oracle</tag>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Oracle学习笔记(一)]]></title>
    <url>%2F2017%2F07%2F16%2FOracle%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%80%2F</url>
    <content type="text"><![CDATA[前言12sqlplus sys/所设定的密码 as sysdba(用管理员登陆)alter user scott account unlock;(解锁scott账户) 1. table structure12描述某一张表：desc 表名select * from 表名 2. select 语句1计算数据可以用空表：比如：select 2*3 from dual 1select ename,sal*12 annual_sal from emp;与select ename,sal*12 "annual sal" from emp;区别，加双引号保持原大小写。不加全变大写。 1select ename || "abcd" 如果连接字符串中含有单引号，用两个单引号代替一个单引号。(||代表连接符) 3. distinct123456select deptno from emp;select distinct deptno from emp;select distinct deptno from emp;select distinct deptno ,job from emp去掉deptno,job两者组合的重复。更多的项，就是这么多项的组合的不重复组合。 4. where12345678select * from emp where deptno =10;select * from emp where deptno &lt;&gt;10;不等于10 select * from emp where ename ='bike';select ename,sal from emp where sal between 800 and 1500 (&gt;=800 and &lt;=1500)空值处理:select ename,sal,comm from emp where comm is (not) null;select ename,sal,comm from emp where ename ( not)in ('smith','king','abc');select ename from emp where ename like '_A%';_代表一个字母,%代表0个或多个字母. 如果查询%可用转义字符.\%. 还可以用escape '$'比如:select ename from emp where ename like '%$a%' escape '$'; 5. orderby123select * from dept; select * from dept order by dept desc;(默认:asc)select ename,sal,deptno from emp order by deptno asc,ename desc; 6. sql function11234567891011121314151617181920212223242526272829303132333435363738394041select ename,sal*12 annual_sal from empwhere ename not like '_A%' and sal&gt;800order by sal desc;select lower(ename) from emp;select ename from emp where lower(ename) like '_a%';等同于select ename from emp where ename like '_a%' or ename like '_A%';select substr(ename,2,3) from emp;从第二字符截,一共截三个字符.select chr(65) from dual 结果为:Aselect ascii('a') from dual 结果为:65select round(23.652,1) from dual; 结果为: 23.7select round(23.652,-1) from dual; 20 select to_char(sal,'$99_999_999') from emp;select to_char(sal,'L99_999_999') from emp;人民币符号,L:代表本地符号这个需要掌握牢:select birthdate from emp;显示为:BIRTHDATE----------------17-12月-80----------------改为:select to_char(birthdate,'YYYY-MM-DD HH:MI:SS') from emp;显示: BIRTHDATE-------------------1980-12-17 12:00:00-------------------select to_char(sysdate,'YYYY-MM-DD HH24:MI:SS') from dual; //也可以改为:HH12TO_CHAR(SYSDATE,'YY-------------------2017-07-15 14:46:14 123to_date函数:select ename,birthdate from emp where birthdate &gt; to_date('1981-2-20 12:34:56','YYYY-MM-DD HH24:MI:SS');如果直接写 birthdate&gt;'1981-2-20 12:34:56'会出现格式不匹配,因为表中的格式为: DD-MM月-YY. 123456789select sal from emp where sal&gt;888.88 无错.但select sal from emp where sal&gt;$1,250,00;会出现无效字符错误. 改为:select sal from emp where sal&gt;to_number('$1,250.00','$9,999.99');s把空值改为0select ename,sal*12+nvl(comm,0) from emp;这样可以防止comm为空时,sal*12相加也为空的情况. 7. Group function 组函数1max,min,avg ,count,sum函数 1select to_char(avg(sal),'99999999,99') from emp; 1234567select round(avg(sal),2) from emp;结果:2073.21 select count(*) from emp where deptno=10;select count(ename) from emp where deptno=10; count某个字段,如果这个字段不为空就算一个.select count(distinct deptno) from emp;select sum(sal) from emp;]]></content>
      <categories>
        <category>Oracle</category>
      </categories>
      <tags>
        <tag>Oracle sql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java读书笔记-Thread类]]></title>
    <url>%2F2017%2F07%2F14%2Fjava%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-Thread%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[一、线程的三个常用方法 二、线程死锁图解 Thread1锁住了上面的对象，等待锁住下面的对象来完成执行过程。但是下面的对象被Thread2锁住了，它也等着锁住上面的对象来完成执行，因此陷入了死锁。 三、死锁小程序12345678910111213141516171819202122232425262728293031323334353637383940414243public class TestDeadLock implements Runnable &#123; public int flag = 1; static Object o1 = new Object(), o2 = new Object(); public void run() &#123; System.out.println("flag=" + flag); if(flag == 1) &#123; synchronized(o1) &#123; try &#123; Thread.sleep(500); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; synchronized(o2) &#123; System.out.println("1"); &#125; &#125; &#125; if(flag == 0) &#123; synchronized(o2) &#123; try &#123; Thread.sleep(500); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; synchronized(o1) &#123; System.out.println("0"); &#125; &#125; &#125; &#125; public static void main(String[] args) &#123; TestDeadLock td1 = new TestDeadLock(); TestDeadLock td2 = new TestDeadLock(); td1.flag = 1; td2.flag = 0; Thread t1 = new Thread(td1); Thread t2 = new Thread(td2); t1.start(); t2.start(); &#125;&#125; 四、面试题下面举个小例子： 1234567891011121314151617181920212223242526272829303132public class TT implements Runnable &#123; int b = 100; public synchronized void m1() throws Exception&#123; //Thread.sleep(2000); b = 1000; Thread.sleep(5000); System.out.println("b = " + b); &#125; public void m2() throws Exception &#123; Thread.sleep(2500); b = 2000; &#125; public void run() &#123; try &#123; m1(); &#125; catch(Exception e) &#123; e.printStackTrace(); &#125; &#125; public static void main(String[] args) throws Exception &#123; TT tt = new TT(); Thread t = new Thread(tt); t.start(); tt.m2(); System.out.println(tt.b); &#125;&#125; 上面的输出结果是：2000 五、wait()跟sleep()区别1)wait时别的线程可以访问锁定对象(调用wait方法的时候必须锁定该对象) 2)sleep时别的线程也不可以访问锁定对象 2)Thread.sleep()与Object.wait()二者都可以暂停当前线程，释放CPU控制权，主要的区别在于Object.wait()在释放CPU同时，释放了对象锁的控制，而在同步块中的Thread.sleep()方法并不释放锁，仅释放CPU控制权。 六、wait()跟notify()方法 1)wait()方法与notify()必须要与synchronized(resource)一起使用。(也就是wait与notify针对已经获取了resource锁的线程进行操作，从语法角度来说就是Obj.wait(),Obj.notify必须在synchronized(Obj){...}语句块内。) 2) wait和notify方法均可释放对象的锁，但wait同时释放CPU控制权，即它后面的代码停止执行，线程进入阻塞状态，而notify方法不立刻释放CPU控制权，而是在相应的synchronized(){}语句块执行结束，再自动释放锁。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>Thread</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java读书笔记-IO类-编程小问题]]></title>
    <url>%2F2017%2F07%2F13%2Fjava%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-IO%E7%B1%BB-%E7%BC%96%E7%A8%8B%E5%B0%8F%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最近在重新复习下java SE的内容，把一下小问题记录下来。 一、Java流式输入输出原理图 二、流的分类 三、节点流类型 总结以stream结尾的是字节流，以reader或writer结尾的是字符流。 一、字节流文件复制12345678910111213141516171819202122import java.io.*;public class TestFileOutputStream &#123; public static void main(String[] args) &#123; int b = 0; FileInputStream in = null; FileOutputStream out = null; try &#123; in = new FileInputStream("d:/share/java/HelloWorld.java"); out = new FileOutputStream("d:/share/java/io/HW.java"); while((b=in.read())!=-1)&#123; out.write(b); &#125; in.close(); out.close(); &#125; catch (FileNotFoundException e2) &#123; System.out.println("找不到指定文件"); System.exit(-1); &#125; catch (IOException e1) &#123; System.out.println("文件复制错误"); System.exit(-1); &#125; System.out.println("文件已复制"); &#125;&#125; 二、BufferedWriter和BufferedReader图解如果只是用FileWriter的话只能每次写入一个字符，而在外面再包装一层BufferedWriter的话一次可以写入一个缓冲区的内容。 三、OutputStreamWriter工作原理如果只是用FileWriter的话只能每次写入一个字节，而在外面再包装一层BufferedWriter的话一次可以写入一个字符串的内容。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>IO</tag>
        <tag>编程小问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java读书笔记-常用类-编程小问题]]></title>
    <url>%2F2017%2F07%2F11%2Fjava%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E5%B8%B8%E7%94%A8%E7%B1%BB-%E7%BC%96%E7%A8%8B%E5%B0%8F%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最近在重新复习下java SE中常用类的内容，把一下小问题记录下来。 一、用Java编写一个程序，输出一个字符串中的大写英文字母数，小写英文字母数以及非英文字母数。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import java.util.regex.*;public class TestString &#123; public static void main(String[] args) &#123; //方法一 //String s = "AaaaABBBBcc&amp;^%adfsfdCCOOkk99876 _haHA"; //int lCount = 0, uCount = 0, oCount = 0; /* for(int i=0; i&lt;s.length(); i++) &#123; char c = s.charAt(i); if(c &gt;= 'a' &amp;&amp; c &lt;= 'z') &#123; lCount ++; &#125; else if (c &gt;='A' &amp;&amp; c &lt;= 'Z') &#123; uCount ++; &#125; else &#123; oCount ++; &#125; &#125; */ //方法二 /* String sL = "abcdefghijklmnopqrstuvwxyz"; String sU = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"; for(int i=0; i&lt;s.length(); i++) &#123; char c = s.charAt(i); if(sL.indexOf(c) != -1) &#123; lCount ++; &#125; else if (sU.indexOf(c) != -1) &#123; uCount ++; &#125; else &#123; oCount ++; &#125; &#125; */ //方法三 for(int i=0; i&lt;s.length(); i++) &#123; char c = s.charAt(i); if(Character.isLowerCase(c)) &#123; lCount ++; &#125; else if (Character.isUpperCase(c)) &#123; uCount ++; &#125; else &#123; oCount ++; &#125; &#125; System.out.println(lCount + " " + uCount + " " + oCount); 二、将“1,2;3,4,5;6,7,8”这个字符串分解为二维数组。123456789101112131415161718192021public class ArrayParser &#123; public static void main(String[] args)&#123; double[][] d; String = "1,2;3,4,5;6,7,8"; String[] sFirst = s.split(";"); d = new double[sFirst.length][]; for(int i = 0; i &lt; sFirst.length; i++)&#123; String[] sSecond = sFirst[i].split(","); d[i] = new double[sSecond.length]; for(int j = 0; j &lt; sSecong.length; j++)&#123; d[i][j] = Double.parseDouble(sSecond[j]); &#125; &#125; for(int i = 0; i &lt; d.length; i++)&#123; for(int j = 0; j &lt; d[i].length; j++)&#123; System.out.print(d[i][j] + " "); &#125; System.out.println(); &#125; &#125;&#125; 三、利用递归列出目录结构12345678910111213141516171819202122232425import java.io.*;public class FileList &#123; public static void main(String[] args) &#123; File f = new File("d:/A"); System.out.println(f.getName()); tree(f, 1); &#125; private static void tree(File f, int level) &#123; String preStr = ""; for(int i=0; i&lt;level; i++) &#123; preStr += " "; &#125; File childs = f.listFiles(); for(int i=0; i&lt;childs.length; i++) &#123; System.out.println(preStr + childs[i].getName()); if(childs[i].isDirectory()) &#123; tree(childs[i], level + 1); &#125; &#125; &#125;&#125; 四、编写一个方法，输出在一个字符串中，指定字符串出现的次数123456789101112131415 String s = "sunjavahpjavaokjavajjavahahajavajavagoodjava"; String sToFind = "java"; int count = 0; int index = -1; while((index = s.indexOf(sToFind)) != -1) &#123; s = s.substring(index + sToFind.length()); count ++; &#125; System.out.println(count);&#125;]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>class</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[别再乱用jQuery return false]]></title>
    <url>%2F2017%2F05%2F14%2F%E5%88%AB%E5%86%8D%E4%B9%B1%E7%94%A8jQuery%20return%20false%2F</url>
    <content type="text"><![CDATA[前言​ event.preventDefault()方法是用于取消事件的默认行为，但此方法并不被ie支持，在ie下需要用window.event.returnValue = false; 来实现。这不是jQuery的方法，是JS本身自带的。 event.preventDefault()​ 该方法将通知 Web 浏览器不要执行与事件关联的默认动作（如果存在这样的动作）。例如，如果 type 属性是 “submit”，在事件传播的任意阶段可以调用任意的事件句柄，通过调用该方法，可以阻止提交表单。注意，如果 Event 对象的 cancelable 属性是 fasle，那么就没有默认动作，或者不能阻止默认动作。无论哪种情况，调用该方法都没有作用。 event.stopPropagation()​ 该方法将停止事件的冒泡，阻止它被分派到其他 Document 节点。在事件冒泡的任何阶段都可以调用它。注意，虽然该方法不能阻止同一个 Document 节点上的其他事件句柄被调用，但是它可以阻止把事件分派到其他节点。event是DOM的事件方法，所以不是单独使用，比如指定DOM。 测试在jQuery代码中，我们常见用return false来阻止浏览器的默认行为。例如点击链接，浏览器默认打开一个新窗口/标签，为了阻止浏览器的默认行为，我们往往这样操作： 1234$("a.toggle").click(function() &#123; $("#mydiv").toggle(); return false; &#125;); 这段代码的作用是通过点击toggle来隐藏或显示#mydiv，并阻止浏览器继续访问href指定链接。测试如下： click toggle 点击上一行的toggle，这段文字将被显示或隐藏。 return false的作用return false达到了我们想要的目的，但这并不是阻止浏览器执行默认行为的正确方法。调用return false，它实际完成了3件事： 1.event.preventDefault()2.event.stopPropagation()3.停止回调函数执行并立即返回。我们真正的目的是event.preventDefault()，后两者可不是我们想要的。JavaScript事件有两种，一种称为事件冒泡（event bubbling），一种称为事件捕捉（event capturing）。事件冒泡指事件在初始DOM上触发，通过DOM树往上在每一级父元素上触发；当事件向下冒泡时，我们则称之为事件捕获。 测试因为return false多做了两件事，由此为代码埋下隐患。下面有一个简单的例子，点击一个链接，加载新的页面内容到当前页面： 1234567891011121314151617&lt;div class="post"&gt; &lt;a href="/js/loadp1.txt"&gt;Click here to load page1&lt;/a&gt; &lt;div class="content"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="post"&gt; &lt;a href="/js/loadp2.txt"&gt;Click here to load page2&lt;/a&gt; &lt;div class="content"&gt; &lt;/div&gt; &lt;/div&gt; $("div.post a").click(function() &#123; var href = $(this).attr("href"); $(this).next().load(href); return false; &#125;); 测试如下： Click here to load page1 Click here to load page2 ​ 点击链接就能加载页面内容到当前页，一切都OK。现在我们想要加一个新功能，例如论坛帖子的浏览，只有当前点击的帖子内容才会显示，其他帖子都隐藏。为此我们需要为div.post加一个click()事件处理： 1234$("div.post").click(function()&#123; $("div.post .content").hide(); // hide all content $(this).children(".content").show(); // show this one &#125;); ​ 添加完这段代码后，我们发现它不生效，缘故是因为$(&quot;div.post a&quot;).click(function() { return false; });，由于return false执行了event.stopPropagation()，因此事件不能冒泡到上一级DOM，即$(&quot;div.post&quot;).click()不会被事件触发。要达成我们的任务，应该把return false替换为event.preventDefault()： 12345$("div.post a").click(function(e) &#123; var href = $(this).attr("href"); $(this).next().load(href); e.preventDefault(); &#125;); 测试修改后的代码： Click here to load page1 Click here to load page2 return false 和 live/delegate如果把return false和live/delegate事件混用，情况就更糟糕了： 12345678$("a").click(function()&#123; // do something return false; &#125;); $("a").live("click", function()&#123; // this won't fire &#125;); 如果确实需要阻止事件冒泡，也应该显式地调用： 12345678$("div.post").click(function()&#123; // do something &#125;); $("div.post a").click(function(e)&#123; // 浏览器跳转到新页面（默认行为） // 但阻止事件冒泡，即不会执行$("div.post").click() e.stopPropagation(); &#125;); event.stoplmmediatePropagetion()​ event.stopPropagation()用于阻止事件冒泡，jQuery中还有另一个函数：event.stopImmediatePropagation()，它用于阻止一个事件的继续执行，即使当前对象上还绑定了其他处理函数： 12345678910111213141516$("div a").click(function()&#123; // do something &#125;); $("div a").click(function(e)&#123; // stop immediate propagation e.stopImmediatePropagation(); &#125;); $("div a").click(function()&#123; // never fires &#125;); $("div a").click(function()&#123; // never fires &#125;); 总结​ 最后结论是：理解return false，尽量避免使用它，请用event.preventDefault()替代return false。]]></content>
      <categories>
        <category>javascript</category>
        <category>jQuery</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery读书笔记]]></title>
    <url>%2F2017%2F05%2F01%2FjQuery%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[最近在学习jQuery,顺便做了一点笔记，防止以后要寻找的时候找不到。 1)$(“form :input”) 返回form中的所有表单对象，包括textarea、select、button等 $(“form input”)返回form中的所有input标签对象 $(“#form1:input”)表示id为#form1的input form input 是属于层级选择器(将每一个选择器匹配到的元素合并后一起返回) 2)121. &lt;div id = "id#b"&gt;bb&lt;/div&gt; 2. &lt;div id = "id[1]"&gt;cc&lt;/div&gt; 上述div不能用普通方式来获取，例如 121. $("#id#b"); 2. $("#id[1]"); 而应该用转义字符： 121. $("#id\#b"); 2. $("#id\[1\]"); 3)12345671. $(document).ready(function()&#123; 2. //... 3. &#125;); 4. 可以简写为 5. $(function()&#123; 6. //... 7. &#125;) 4)123456781. &lt;div class="test"&gt; 2. &lt;div style="display:none;"&gt;aa&lt;/div&gt; 3. &lt;div style="display:none;"&gt;bb&lt;/div&gt; 4. &lt;div style="display:none;"&gt;cc&lt;/div&gt; 5. &lt;div class="test" style="display:none;"&gt;dd&lt;/div&gt; 6. &lt;/div&gt; 7. &lt;div class="test" style="display:none;"&gt;ee&lt;/div&gt; 8. &lt;div class="test" style="display:none;"&gt;ff&lt;/div&gt; 下面用jquery选取： 123456789101. $(function()&#123; 2. //注意区分类似这样的选择器 3. //虽然一个空格，却截然不同的效果. 4. var t_a = ('.test :hidden'); 5. var t_b = ('.test:hidden'); 6. var len_a = $t_a.length; 7. var len_b = $t_b.length; 8. ("&lt;p&gt;('.test :hidden')的长度为"+len_a+"&lt;/p&gt;").appendTo("body"); //4 9. ("&lt;p&gt;('.test:hidden')的长度为"+len_b+"&lt;/p&gt;").appendTo("body"); //3 10. &#125;) 原因是： var $t_a = $(“.test :hidden”); 以上代码是选取class为”test”的元素里面的隐藏元素 而代码： var $t_b = $(“.test:hidden”); 这是选取隐藏的class为“test”的元素 5)detach()和remove()一样，也是从DOM中去掉匹配的元素。但是这个方法不会把匹配的元素从jQuery对象中删除，因而可以在将来再使用这些匹配的元素，与remove不同的是，所以绑定的事件、附加的数据等都会保留下来。 6)$(this).clone(true).appendTo(“body”); //注意参数true 在clone()方法中传递了一个参数true，它的含义是复制元素的同事复制元素中所绑定的事件，因而该元素的副本也同样具有复制功能。 7)在css()方法中，如果属性中带有“-”符号，例如font-size属性，如果在设置这些属性的值得时候不带引号，那么就要用驼峰式写法，例如： $(“p”).css({fontSize : “30px” , backgroundColor : “#888888”}); 如果加上了引号，既可以写成”font-size”,也可以写成“fontSize”。 8)show()方法和hide()方法会同时修改元素的多个样式属性，即高度、宽度和不透明度；fadeOut()和fadeIn()方法智慧修改元素的不透明度；slideDown()方法和slideUp()方法智慧改变元素的高度。 9)1234567891011121. $("button:eq(1)").click(function () &#123; 2. $("#panel").stop();//停止当前动画，继续下一个动画 3. &#125;); 4. $("button:eq(2)").click(function () &#123; 5. $("#panel").stop(true);//清除元素的所有动画 6. &#125;); 7. $("button:eq(3)").click(function () &#123; 8. $("#panel").stop(false,true);//让当前动画直接到达末状态 ，继续下一个动画 9. &#125;); 10. $("button:eq(4)").click(function () &#123; 11. $("#panel").stop(true,true);//清除元素的所有动画，让当前动画直接到达末状态 12. &#125;); 10)animate回调函数 12345$("#panel").click(function () &#123; $(this).animate(&#123;left: "400px", height: "200px", opacity: "1"&#125;, 3000) .animate(&#123;top: "200px", width: "200px"&#125;, 3000, function () &#123; $(this).css("border", "5px solid blue"); &#125;) 11)用attr()和prop()访问对象的属性的原则： 第一个原则：只添加属性名称该属性就会生效应该使用prop()； 第一个原则：只存在true/false的属性应该使用prop()。 按照官方说明，如果是设置disable和checked这些属性，应使用prop()方法，而不是使用attr()方法。（例如在某些浏览器里，只要写了disabled属性就可以，有些则要写：disabled = “disabled”。）]]></content>
      <categories>
        <category>javascript</category>
        <category>jQuery</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>javascript</tag>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript冒泡事件的作用效果]]></title>
    <url>%2F2017%2F04%2F22%2Fjavascript%E5%86%92%E6%B3%A1%E4%BA%8B%E4%BB%B6%E7%9A%84%E4%BD%9C%E7%94%A8%E6%95%88%E6%9E%9C%2F</url>
    <content type="text"><![CDATA[​ 这段时间在学习js，忽然发现了冒泡事件挺有趣的，故研究后来跟各位分享一下效果。 话不多说，直接上代码： 代码123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="body"&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=""&gt;home&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=""&gt;About&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;script&gt; function stopBubble(e)&#123; if(e &amp;&amp; e.stopPropagation)&#123;//如果不是IE浏览器 e.stopPropagation(); &#125;else&#123;//是IE浏览器 window.event.cancelBubble=true; &#125; &#125; var all = document.getElementsByTagName("*"); for(var i =0;i&lt;all.length;i++)&#123; all[i].onmouseover = function(e)&#123;//鼠标悬停在元素上 this.style.border="1px solid red"; stopBubble(e); &#125;; all[i].onmouseout=function(e)&#123;//鼠标离开 this.style.border="0px"; stopBubble(e);//阻止冒泡 &#125;; &#125; &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 总结​ 上面是一个简单的例子,当鼠标悬停在元素之上,我们为这个元素加上红色边框,如果离开了再去掉这个红色边框, ​ 如果不加 这个 阻止冒泡的方法,每次都会给父类增加红色边框,大家 可以试验一下.一试便知!]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>冒泡事件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[u盘安装windows 10与Ubuntu Linux双系统图解教程]]></title>
    <url>%2F2017%2F03%2F23%2FLinux%E5%8F%8C%E7%B3%BB%E7%BB%9F%E5%9B%BE%E8%A7%A3%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[注意如果图片加载不出来请在：http://blog.csdn.net/onlylove_kd/article/details/70544204 进行查看。 前言按照本图解教程的方法可以完成Windows 10和Ubuntu Kylin双系统的安装。（有些图片是百度得来的） Windows 10和Ubuntu Kylin双系统引导成功图： 1.安装环境Windows 10系统 2.安装 ubuntu 首先需要准备以下工具以及安装包：1、ubuntu 系统安装包​ https://mirrors.tuna.tsinghua.edu.cn/#（这个是清华的镜像站点，里面有各种镜像，下载速度也很可观） 2、刻录软件，推荐软碟通，会提示注册，选择继续使用​ 下载：在百度搜一大把 3、一个大于 2G 的 U 盘4、EasyBCD 软件，此软件是同来作为系统引导所用​ 下载地址：http://dl.pconline.com.cn/download/90611.html 3.准备安装1、回到桌面，鼠标右键点击开始菜单图标，选择属性，结果如下 2、进入然后选择磁盘管理，结果如下： 3、选择你认为剩余磁盘空间够大的磁盘，比如 D 盘，右键点击磁盘，选择压缩卷，结果如下： 4、然后就是分区的大小了，个人建议分个 50G 出去最好，然后等待，最终结果如下：压 缩后会发现多出一块未分区磁盘（黑色分区），如果选择的压缩大小是 50G， 则黑色的的应该是 50G 可用空间。 好了，磁盘分区到此结束，现在进行第四步。 4.用软碟通将 UBUNTU 的镜像写入 U 盘1、安装并打开软碟通，插上 U 盘，并且最好备份你的 U 盘，因为之后需要格式化 2、进入软碟通，进行如下操作 选择文件，并且打开你下载的 UBUNTU 所在的目录，选择 unbuntu 镜像（改成选择Ubuntu Kylin 镜像即可），选择打开，如图： 3、在软碟通界面菜单栏选择启动，选择写入硬盘映像，如图所示 接下来很重要，记住次序： 进入以后界面如下： 1、看你的硬盘驱动器是否对应的是你的 U 盘（必须是） ，一般默认是 2、看映像文件是否对应你的 ubuntu 镜像 3、如果上述均没有错误，选择格式化，之后就会格式化你的 U 盘 4、在 U 盘格式化完毕之后，选择写入，之后就是慢慢等待了，等待写入完毕 5.U 盘安装系统（记得关闭电脑的快速启动）写在前面，因为个厂商的计算机 BOOT 启动的快捷键不相同，所以 个人觉得要是你无法进入接下来的 BOOT 界面，还是自行百度如何 进入 BOOT 界面，本人华硕笔记本，所以默认快捷键是 F2。 第 6 步非常关键，如果你不想重装系统，你一定要小心 1、重启系统，在开机刚开始按 F2，之后里面会有如下界面，手机 渣渣，多多包涵，选择 USB HDD，回车确认 2、之后就进入 unbuntu 的安装界面了 3、或许没有这个界面，但是下面的界面是一定有的 4、然后选择左边的，往下拉会有中文选择，如图 5、安装 unbuntu 6、选择继续（注意，接下来这一步非常重要，一定小心），得到如下所视界面，如图 这一步很关键，一定要选择其他选项，切记，然后进入如下界面 看到没有，里面会有一个空闲分区，也就是我们之前所创建的那个分区 在这里，我们谈谈关于 Linux 的分区：a.首先 Linux 分区适合 WINDOWS 分区是不一样的， Linux 是以文 件形式作为分区 b.所以分区就像划分磁盘大小一样， 在这里我个人建议如果你的 划分的空盘分区为 60G，则我们可以将其分为 : 1)、/:这是 linux 也就是 ubuntu 的根目录就一个反斜杠表示， 我们将其分为 25G，文件格式为 ext4 2）、 /home:这是 ubuntu 根目录下的一个文件夹， 这个也可以说 是我们的个人目录，所以为了让我们自己的目录大一点，我们可 以将其分为 30G 或者 20G，文件格式为 ext4 3）、swap:这个是 Linux 也就是 ubuntu 的交换区目录，这个一 般的大小为内存的 2 倍左右， 主要是用来在电脑内存不足的情况 下，系统会调用这片区域，来运行程序，我们可以将其分为 4G， 这个没有让你选用文件格式 4）、/boot：这个就是实现你双系统的原因了，这个就是用启动 ubuntu 的目录，里面会有系统的引导，这个文件其实只有几十 兆，但是我们建议将其划分为 200M 文件格式为 ext4，这个分区必不可少，否则后果你懂得！ 好了，这部分分区讲诉完毕，下面就让我们来进行期待已久的分区吧。当然，你可以划分的更详细，具体划分可以百度。7、分区 选择空闲分区之后，点击添加，会得到如图界面： A.首先就是创建根目录，上面提到过，大小 25G 左右，用于 EXT4 文件系统，挂载点有下拉菜单，选择/就好，然后确定，继续选择空闲分区，别看错了，然后添加 B.然后就是交换区的创建，步骤如上，区别是大小为 4G，用于那个下拉菜单选择交换空间，即 SWAP，然后确定 C./BOOT 的创建，大小 200M，文件系统为 EXT4，挂载点选择/boot，点击确定 D、/HOME 的创建，大小 30G，文件系统 40G，挂载点/HOME,点击确定 到此分区完成 接下来的这一步很重要，切记（关系到 ubuntu 的开机启动） 依然在这个界面上，选择安装启动下拉菜单，我们刚刚不是创建了/boot 的文件 吗，现在你看看这个区前面的编号是多少，我的是下面这个 /dev/sda1,不同的机 子在在这个上面会有不同的编号，也就是 sda1 然后在安装启动的下拉菜单中找到 sda1，选择它，切记一定是/boot 的编号 如下图 接下来就选择开始安装了；8、选择继续，进入下一步操作，并设置地区为：chongqing，按你需要设置，在下一步操作中选择语言 9、键盘布局“默认”，建议选择下面的这个 10、这里设置系统用户，自己设置输入就可以了 11、这个可选可不选，点“继续” 12． 系统开始安装，可以喝杯咖啡，等安装完毕就可以了（这里应该是欢迎使用Ubuntu Kylin） 当这些全部完成之后，机子会重启。你会发现直接进入你的 win10 系统，因为我们把它的引 导搞到/boot 分区了。我们要用 EasyBCD 来给它创建启动时候的选择系统是 windows 还是 ubuntu 。 6.用 EasyBCD 引导 ubuntu接下来就很简单了，在 WIN10 下安装 EasyBCD,之后呢打开如图并且选择添加新条目： 得到如图，选择有企鹅那个，也就是 LINUX/BSD 那个选项，在磁盘驱动器那个下拉菜单选 择以 linux 开头，大小为 200M 左右的那个选项，如图 选择完了之后，添加条目，重启电脑，你就会发现你的 UBUNTU 和 WIN10的双系统就安装完成了。到此，ubuntu 安装结束！ 当你不要 ubuntu 的时候，直接在 window 里磁盘管理删了它所在的分区，然后在 Easybcd 里 删了它的引导就行，不影响你的 windows 系统，这就是为啥我不用 ubuntu 来引导 windows 的原因。 然后就可以尽情享受双系统的乐趣了哈哈哈。 Ubuntu Kylin桌面]]></content>
      <categories>
        <category>装系统</category>
      </categories>
      <tags>
        <tag>U盘</tag>
        <tag>windows10</tag>
        <tag>Ubuntu</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello Hexo]]></title>
    <url>%2F2017%2F01%2F23%2Fhello-hexo%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>Hexo教程</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于解决VS2015不能用fscanf而老是提示用fscanf_s的方法]]></title>
    <url>%2F2016%2F12%2F17%2F%E5%85%B3%E4%BA%8E%E8%A7%A3%E5%86%B3VS2015%E4%B8%8D%E8%83%BD%E7%94%A8fscanf%E8%80%8C%E8%80%81%E6%98%AF%E6%8F%90%E7%A4%BA%E7%94%A8fscanf-s%E7%9A%84%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[前言​ 由于笔者之前用的是dev还有code block，没怎么用过VS2015这个软件，所以发现有些东西不太一样，在下面跟大家分享一下。 问题​ 在处理文件输入的时候，我本来是想用fscanf函数，但是编译的时候老是说fscanf函数不安全，建议改成fscanf_s函数。但是fscanf_s函数我不会用，找了挺久的资料，终于知道解决方法了。 解决方法方法一：在程序最前面加#define _CRT_SECURE_NO_DEPRECATE； 方法二：在程序最前面加#define _CRT_SECURE_NO_WARNINGS； 方法三：在程序最前面加#pragma warning(disable:4996)； 方法四：把scanf改为scanf_s；. 方法五：无需在程序最前面加那行代码，只需在新建项目时取消勾选“SDL检查”即可； 方法六：若项目已建立好，在项目属性里关闭SDL也行； 方法七：在工程项目设置一下就行；将报错那个宏定义放到 项目属性 – C/C++– 预处理器 – 预处理器定义； 方法八：在 项目属性 – c/c++ – 命令行 添加：/D _CRT_SECURE_NO_WARNINGS 就行了。]]></content>
      <categories>
        <category>编译器问题</category>
      </categories>
      <tags>
        <tag>Visual Studio</tag>
        <tag>fscanf_s</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构课设--用B树实现图书管理系统]]></title>
    <url>%2F2016%2F12%2F17%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AF%BE%E8%AE%BE-%E7%94%A8B%E6%A0%91%E5%AE%9E%E7%8E%B0%E5%9B%BE%E4%B9%A6%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[前言​ 此文章是分享一下上学期数据结构课程的课程设计，我选择的是以B树为数据结构，开发一个图书管理系统，B树的优点在于查询快，增删结点相对于链表或者顺序表效率更好，因此用来存储大量图书信息更加合适。 开发环境vs2015 下面贴出代码： 代码library.h123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171#include "windows.h" #include "stdio.h" #include "conio.h" #include "stdlib.h" #include "malloc.h" #include "time.h" #include "string.h" #include "errno.h" #define TRUE 1 #define FALSE 0 #define OVERFLOW -1 #define OK 1 #define ERROR 0 #define M 3//定义阶数 #define Super_Manager_Code 5372 //超级管理员密码 #define MAX_NAME_LEN 20//姓名长度 #define MAX_BKNAME_LEN 50 #define OK 1 #define ERROR 0 #define bookinfomationfile "bookinfo.dat" // 图书信息文件 #define borrowerfile "borrower.dat" // 借阅者名单文件 typedef int KeyType; typedef int Status; /*****************************书和借阅者结点存储定义*************************/ typedef struct ReaderNode &#123;//借阅者 int IDnum; //ID号 char reader_name[MAX_NAME_LEN]; //姓名 ReaderNode *rnext; //指向下一个借阅者的指针 &#125;ReaderNode, *ReaderType; typedef struct BookNode &#123; int booknum; //书号 char bookname[MAX_BKNAME_LEN]; //书名 char writer[MAX_NAME_LEN]; //作者名字 int current; //现存量 int total; //总库存 int published_year; //出版年份 float price; //价格 ReaderType reader; //借阅者链表指针 &#125;BookNode, *BookType; //图书类型 typedef BookNode Record; //将书的结点定义为记录 /*******************************B树存储定义***************************/ typedef struct BTNode &#123; //B树结点类型定义 int keynum; //结点中关键字个数，即结点的大小 KeyType key[M+1]; //关键字，key[0]未用 struct BTNode *parent; //双亲结点指针 struct BTNode *ptr[M + 1]; //孩子结点指针数组 Record *recptr[M + 1]; //记录指针向量，0号单元未用 &#125;BTNode, *BTree; //B树结点和B树类型 typedef struct result &#123; BTNode *pt; //指向找到的结点 int i; //1&lt;=i&lt;=m,在结点中的关键字位序 int tag; //1:查找成功，0:查找失败 &#125;result, *resultPtr; //B树的查找结果类型 /*******************************B树接口定义***************************/ result SearchBTree(BTree T, int k); /* 初始条件:树T存在 操作结果:在m阶B数T上查找关键字k，返回p&#123;pt,i,tag&#125; */ Status InsertBTree(BTree &amp;T, int k, BTree q, int i, Record *recptr); /* 初始条件:树T存在 操作结果:在B树T上结点p-&gt;pt的key[i]和key[i+1]之间插入关键字k */ Status DeleteBTree(BTree &amp;T, int k); /* 初始条件:B树上p结点存在 操作结果:删除B树T上结点p-&gt;pt的关键字k */ void BTreeTraverse(BTree T, void(*visit)(BTree)); /* 初始条件:树T存在 操作结果:遍历B树 */ int menu(); /* 输出选择菜单 */ void ShowBTree(BTree T, short x = 8); /* 以凹入表的形式输出B树 */ int login(); /* 登陆界面 */ /*******************************图书馆接口定义***************************/ void InitLibrary(BTree &amp;L); /* 初始化一棵空树 */ void InsertBook(BTree &amp;L, BookType B, result res); /* 插入新的书籍 */ int DeleteBook(BTree &amp;L, BookType B); /* 删除已存在的书籍，不存在则提示不存在 */ int CanBorrow(BTree L, BookType B, ReaderType R); /* 判断指定书籍能否出借 */ void BorrowBook(BTree L, BookType B, ReaderType R); /* 书籍出借 */ int ReturnBook(BTree L, int booknum, int IDnum, BookType &amp;B, ReaderType &amp;R); /* 书籍归还 */ void PrintH(); /* 输出表格的头部 */ void PrintB(BookType B); /* 输出指定书籍的信息 */ void PrintT(); /* 输出表格的尾部 */ void PrintAll(BTree p); /* 输出B树结点的全部关键字信息 */ void PrintBook(BookType B); /* 以表格形式输出一本书的信息 */ void PrintAllbooks(BTree L); /* 输出所有书的信息 */ int ShowBookinfo(BTree L, int booknum); /* 输出指定某本书的信息 */ void PrintBorrower(ReaderType R); /* 输出某本书的借阅者信息 */ void Welcome(int color); /* 显示欢迎界面 */ void Creat(BTree &amp;L); /* 从文件中读取图书信息 */ library.cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238#include"Library.h" void InitLibrary(BTree &amp;L) &#123; L = NULL; &#125; void InsertBook(BTree &amp;L, BookType B, result res) &#123; //书库L已存在，res包含B书在书库L中的位置或应该插入的位置 //如果书库中已存在B书，则只将B书的库存量增加，否则插入B书到书库L中 if (res.tag == 0) InsertBTree(L, B-&gt;booknum, res.pt, res.i, B); //书库中不存在该书，则插入 else &#123; BookType b = res.pt-&gt;recptr[res.i]; b-&gt;current = b-&gt;current + B-&gt;total;//现存量增加 b-&gt;total = b-&gt;total + B-&gt;total;//总库存增加 &#125; &#125; int DeleteBook(BTree &amp;L, BookType B) &#123; //如果书库中存在B书，则从书库中删除B书的信息，并返回OK，否则返回ERROR if (DeleteBTree(L, B-&gt;booknum)) return OK;//删除成功 else return ERROR;//删除失败 &#125; int CanBorrow(BTree L, BookType B, ReaderType R) &#123; //如果书库中存在B书，若B书现存量大于0，则可出借返回OK，否则返回ERROR if(B-&gt;current&gt;0) return TRUE;//现存量大于零 else return FALSE;//其他情况均不允许出借 &#125; void BorrowBook(BTree L, BookType B, ReaderType R) // 书库L存在，B书是书库中的书并且可被读者R借阅（已通过CanBorrow()判断） // 借出一本B书，登记借阅者R的信息，改变现存量，记录借书日期，最迟应还日期等信息。 &#123; ReaderType r; if (!B-&gt;reader) B-&gt;reader = R; // 无其他借阅者，则直接登记 else &#123; for (r = B-&gt;reader; r-&gt;rnext; r = r-&gt;rnext); r-&gt;rnext = R; // 否则到借阅者链表尾，登记 &#125; B-&gt;current--; // 现存量减1 &#125; int ReturnBook(BTree L, int booknum, int IDnum, BookType &amp;B, ReaderType &amp;R) &#123; //booknum为还书书号，IDnum是借阅者的ID号 //若书库中不存在书号为booknum的书，则搜索出错，返回-1 //若有借阅记录，则注销该记录，并用B和R返回图书信息和借阅者信息并返回1 //若没有r借阅的记录，则用B返回图书信息，并返回0 result res = SearchBTree(L, booknum); //在B树上按书号搜索 if (res.tag == 0) return -1; B = res.pt-&gt;recptr[res.i]; ReaderType p = res.pt-&gt;recptr[res.i]-&gt;reader, pre = p; while (p) &#123; if (pre == p&amp;&amp;p-&gt;IDnum == IDnum) &#123; R = p; B-&gt;current++;//现存量加一 return 1; &#125; if (p-&gt;IDnum == IDnum) &#123;//多个借书者 R = p; pre-&gt;rnext = p-&gt;rnext; B-&gt;current++;//现存量+1 return 1; &#125; pre = p; p = p-&gt;rnext; &#125; return 0; &#125; void PrintH() &#123;//表格头部格式 printf("\n"); printf("|*********************************图书基本信息**********************************|\n"); printf("| 书号 | 书名 | 作者 | 现存 | 总库存 | 出版年份 | 定价 |\n"); &#125; void PrintB(BookType B) &#123; //显示B书基本信息 printf("|--------|--------------------|---------------|------|--------|----------|------|\n"); printf("| %-4d |%-20s|%-15s|", B-&gt;booknum,B-&gt;bookname,B-&gt;writer); printf(" %-5d| %-4d | %-6d |%-6.1f|\n", B-&gt;current, B-&gt;total, B-&gt;published_year, B-&gt;price); &#125; void PrintT() &#123;//表格底部格式 printf("|--------|--------------------|---------------|------|--------|----------|------|\n"); &#125; void PrintAll(BTree p) &#123;//显示B树每个结点的记录信息 int i; for (i = 1; i &lt;= p-&gt;keynum; ++i) &#123; PrintB(p-&gt;recptr[i]); &#125; &#125; void PrintBook(BookType B) &#123;//以表格形式显示一本书的基本信息 PrintH(); PrintB(B); PrintT(); printf("\n"); &#125; void PrintBorrower(ReaderType R) &#123;//以表格形式显示一本书的借阅者信息 ReaderType p = R; printf("|------------------------|\n"); while (p) &#123; printf("| %-5d | %-10s |\n", p-&gt;IDnum, p-&gt;reader_name); p = p-&gt;rnext; &#125; printf("|------------------------|\n"); &#125; void PrintAllbooks(BTree L) &#123;//显示书库L所有图书信息 PrintH(); BTreeTraverse(L, PrintAll); PrintT(); &#125; int ShowBookinfo(BTree L, int booknum) &#123; //若书库L中存在书号为booknum的书，则现在该书的所有信息并返回OK，书库L不存在则 //返回ERROR result res = SearchBTree(L, booknum); if (!res.tag) return ERROR; BookType B = res.pt-&gt;recptr[res.i]; PrintBook(B); return OK; &#125; void gotoxy(short x, short y) // 移动光标到（x，y）坐标，25&gt;x&gt;=0,80&gt;y&gt;=0 &#123; COORD point = &#123; x, y &#125;; SetConsoleCursorPosition(GetStdHandle(STD_OUTPUT_HANDLE), point); &#125; void SetColor(unsigned short TextColor) // 设置字体和背景颜色 &#123; HANDLE hCon = GetStdHandle(STD_OUTPUT_HANDLE); SetConsoleTextAttribute(hCon, TextColor); &#125; void Welcome(int color) // 显示欢迎界面 &#123; SetColor(color); gotoxy(2, 5); printf(" ╭╮╭╮╭──╮╭╮ ╭──╮╭──╮╭╭╮╮╭──╮\n"); printf(" │││││╭─╯││ │╭─╯│╭╮││ ││╭─╯\n"); printf(" │╰╯││╰─╮││ ││ │││││││││╰─╮\n"); printf(" │││││╭─╯││ ││ │││││╭╮││╭─╯\n"); printf(" │ ││╰─╮│╰─╮│╰─╮│╰╯││││││╰─╮\n"); printf(" ╰╰╯╯╰──╯╰──╯╰──╯╰──╯╰╯╰╯╰──╯\n"); SetColor(11); printf(" ╔══════════════╗\n"); printf(" ║ 欢迎进入图书管理系统 ║\n"); printf(" ╚══════════════╝\n"); SetColor(color+1); &#125; void Creat(BTree &amp;L) &#123; // ********************************************************************************** // 创建函数。当显示菜单时按8即可进入本创建函数。 // L为书库。 // 从指定文件读入图书信息进行图书入库。 // 然后从文件读入借阅者名字，用随机数产生借阅证号和借阅书号，进行图书借阅，并记录日志， // 接着读入预约者名字，用随机数产生借阅证号和图书证号，进行图书预约，并记录日志 // 完成后即可返回主菜单，进行还书、预约或其他测试。 FILE *fp; BookType B; result res; errno_t err; ReaderType R; //fp = fopen_s(bookinfomationfile, "r"); // 打开图书信息文件 if ((err = fopen_s(&amp;fp, "bookinfo.dat", "r")) != 0) &#123; printf("不能打开图书信息文件,请确认%s文件已放到盘根目录...", bookinfomationfile); getchar(); return; &#125; printf("\n下面将从文件%s读入图书信息。按任意键继续...", bookinfomationfile); getchar(); while (!feof(fp)) // 当未到文件结束 &#123; B = (BookType)malloc(sizeof(BookNode)); // 申请图书空间 fscanf(fp, "%d %s %s %d %d %d %f", &amp;B-&gt;booknum, B-&gt;bookname, B-&gt;writer, &amp;B-&gt;current, &amp;B-&gt;total, &amp;B-&gt;published_year, &amp;B-&gt;price);// 读入图书数据 B-&gt;reader = NULL; // 读者和借阅者指针置空 res = SearchBTree(L, B-&gt;booknum); // 查找插入位置 if (!res.tag) // 书库中不存在该书，则插入 &#123; InsertBook(L, B, res); // 插入 printf("\n\n\n 插入下面的图书"); PrintBook(B); // 显示该图书 printf("\nB树的状态\n\n"); ShowBTree(L); // 显示插入后B树的状态 &#125; &#125; fclose(fp); printf("\n\n读入的所有图书信息"); PrintAllbooks(L); // 显示所有图书 printf("\n文件图书信息读入完毕!下面从文件读入借书者信息，按任意键继续...\n"); getchar(); // ********************************************************************************** system("cls"); int booknum, i = 0; fp = fopen(borrowerfile, "r"); // 打开借阅者名单文件 if (!fp) &#123; printf("\n\n\n不能打开读者信息文件,请确认%s文件已放到盘根目录...", borrowerfile); getch(); return; &#125; while (i++ &lt;4000 &amp;&amp; !feof(fp)) &#123; R = (ReaderType)malloc(sizeof(ReaderNode)); fscanf(fp, "%6s", &amp;R-&gt;reader_name); // 从文件读入借阅者名字 R-&gt;IDnum = rand() % 100; // 用随机数产生借阅证号 R-&gt;rnext = NULL; // 后续借阅者预约者指针置空 booknum = rand() % 100 + 1; // 随机产生借阅书号 res = SearchBTree(L, booknum); // 搜索二叉树 if (res.tag) // 如果找到该书号 &#123; B = res.pt-&gt;recptr[res.i]; if (CanBorrow(L, B, R)) // 判断该借阅者是否可以借阅该书 &#123; BorrowBook(L, B, R); // 如果可以则借出一本 &#125; &#125; &#125; fclose(fp); PrintAllbooks(L); // 显示所有图书（可以看到现存量减少） printf("\n借书信息读入完毕，下面将从文件读入预约者信息。按任意键继续...."); getch(); &#125; BTree_Operation.cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338/********************************B树接口实现****************************/ int Search(BTree p, int k) &#123; //在B树p中查找关键字k的位置i，使得p-&gt;node[i].key&lt;=K&lt;p-&gt;node[i+1].key int i; for (i = 0; i &lt; p-&gt;keynum&amp;&amp;p-&gt;key[i + 1] &lt;= k; i++); return i; &#125; result SearchBTree(BTree T, KeyType k) // 在m阶B树上查找关键字k，返回结果（pt，i，tag）。若查找成功，则特征值tag=1，指针pt // 所指结点中第i个关键字等于k；否则返回特征值tag=0，等于k的关键字应插入在pt所指结点 // 中第i和第i+1个关键字之间。 &#123; int i = 1; BTree p = T, q = NULL; // 初始化，p指向待查结点，q指向p的双亲 int found = FALSE; while (p &amp;&amp; !found) &#123; i = Search(p, k); // 查找k的位置使p-&gt;key[i]&lt;=k&lt;p-&gt;key[i+1] if (i&gt; 0 &amp;&amp; k == p-&gt;key[i]) found = TRUE; else &#123; // 未找到，则查找下一层 q = p; p = p-&gt;ptr[i]; &#125; &#125; if (found) &#123; result r = &#123; p, i, 1 &#125;; return r; &#125; // 查找成功 else &#123; result r = &#123; q, i, 0 &#125;; return r; &#125; // 查找不成功，返回k的插入位置信息 &#125; void split(BTree &amp;q, int s, BTree &amp;ap) &#123; //将q结点分裂成两个结点，前一半保留，后一半移入新结点ap int i, n = q-&gt;keynum; ap = (BTNode*)malloc(sizeof(BTNode));//生成新结点ap ap-&gt;ptr[0] = q-&gt;ptr[s]; for (i = s + 1; i &lt;= M; i++) &#123;//后一半移入ap结点 ap-&gt;key[i-s] = q-&gt;key[i]; ap-&gt;ptr[i-s] = q-&gt;ptr[i]; ap-&gt;recptr[i - s] = q-&gt;recptr[i]; &#125; ap-&gt;keynum = n - s;//计算ap的关键字个数 ap-&gt;parent = q-&gt;parent; for (i = 0; i &lt;= M - s; i++) &#123; if (ap-&gt;ptr[i]) ap-&gt;ptr[i]-&gt;parent = ap;//将ap所有孩子结点指向ap &#125; q-&gt;keynum = s - 1;//q结点的前一半保留，修改keynum &#125; void newroot(BTree &amp;T, BTree p, int k, BTree ap,Record *recptr) &#123;//生成新的根结点 T = (BTNode*)malloc(sizeof(BTNode)); T-&gt;keynum = 1; T-&gt;ptr[0] = p; T-&gt;ptr[1] = ap; T-&gt;key[1] = k; T-&gt;recptr[1] = recptr; //T的子树ap的父亲指针 if (p != NULL) p-&gt;parent = T; if (ap != NULL) ap-&gt;parent = T; T-&gt;parent = NULL;//新根的双亲是空指针 &#125; void Insert(BTree &amp;q, int i, int k, BTree ap,Record *recptr) &#123;//k和ap分别插到q-&gt;key[i+1]和q-&gt;ptr[i+1] //并插入关键字为k的记录recprt int j, n = q-&gt;keynum; for (j = n; j &gt; i; j--) &#123; q-&gt;key[j + 1] = q-&gt;key[j];//关键字指针向后移一位 q-&gt;ptr[j + 1] = q-&gt;ptr[j];//孩子结点指针向后移一位 q-&gt;recptr[j + 1] = q-&gt;recptr[j]; &#125; q-&gt;key[i+1] = k;//赋值 q-&gt;ptr[i+1] = ap; q-&gt;recptr[i + 1] = recptr; if (ap != NULL) ap-&gt;parent = q; q-&gt;keynum++;//关键字数+1 &#125; Status InsertBTree(BTree &amp;T, KeyType k, BTree q, int i, Record *rec) // 在m阶B树T上结点*q的key[i]与key[i+1]之间插入关键字K和记录rec。 // 若引起结点过大，则沿双亲链进行必要的结点分裂调整，使T仍是m阶B树。 &#123; BTree ap = NULL; int finished = FALSE; if (!q) newroot(T, NULL, k, NULL, rec); // T是空树，生成仅含关键字K的根结点*T else &#123; while (!finished) &#123; Insert(q, i, k, ap, rec); // 将k和ap分别插入到q-&gt;key[i+1]和q-&gt;ptr[i+1] if (q-&gt;keynum &lt; M) finished = TRUE; // 插入完成 else &#123; split(q, (M + 1) / 2, ap); // 分裂结点Q k = q-&gt;key[(M + 1) / 2]; rec = q-&gt;recptr[(M + 1) / 2]; if (q-&gt;parent) &#123; // 在双亲结点*q中查找k的插入位置 q = q-&gt;parent; i = Search(q, k); &#125; else finished = OVERFLOW; // 根节点已分裂为*q和*ap两个结点 &#125; &#125; if (finished == OVERFLOW) // 根结点已分裂为结点*q和*ap newroot(T, q, k, ap, rec); // 需生成新根结点*T,q和ap为子树指针 &#125; return OK; &#125; // InsertBTree void TakePlace(BTree &amp;q, int &amp;i) &#123; //*q结点的第i个关键字为k，用q的后继关键字代替q，且令q指向后继所在结点 BTree p = q; q = q-&gt;ptr[i]; while (q-&gt;ptr[0]) q = q-&gt;ptr[0]; //查找p的后继 p-&gt;key[i] = q-&gt;key[1]; //记录代替 p-&gt;recptr[i] = q-&gt;recptr[1]; i = 1; //代替后应该删除q所指结点的第1个关键字 &#125; void Del(BTree q, int i) &#123; //删除q所指结点第i个关键字及其记录 for (; i &lt; q-&gt;keynum; i++) &#123;//关键字和记录指针前移 q-&gt;key[i] = q-&gt;key[i + 1]; q-&gt;recptr[i] = q-&gt;recptr[i + 1]; &#125; q-&gt;keynum--;//关键字数目减1 &#125; Status Borrow(BTree q) // 若q的兄弟结点关键字大于(m-1)/2,则从兄弟结点上移最小（或最大）的关键字到双亲结点， // 而将双亲结点中小于(或大于）且紧靠该关键字的关键字下移至q中,并返回OK，否则返回EREOR。 &#123; int i; BTree p = q-&gt;parent, b = NULL; // p指向q的双亲结点 for (i = 0; p-&gt;ptr[i] != q; i++); // 查找q在双亲p的子树位置 if (i &gt;= 0 &amp;&amp; i + 1 &lt;= p-&gt;keynum &amp;&amp; p-&gt;ptr[i + 1]-&gt;keynum &gt; (M - 1) / 2) &#123; // 若q的右兄弟关键字个数大于(m-1)/2 b = p-&gt;ptr[i + 1]; // b指向右兄弟结点 q-&gt;ptr[1] = b-&gt;ptr[0]; // 子树指针也要同步移动 q-&gt;key[1] = p-&gt;key[i + 1]; // 从父节点借第i+1个关键字 q-&gt;recptr[1] = p-&gt;recptr[i + 1]; p-&gt;key[i + 1] = b-&gt;key[1]; // b第一个关键字上移到父节点 p-&gt;recptr[i + 1] = b-&gt;recptr[1]; for (i = 1; i &lt;= b-&gt;keynum; i++) // b第一个关键字上移，需把剩余记录前移一位 &#123; b-&gt;key[i] = b-&gt;key[i + 1]; b-&gt;recptr[i] = b-&gt;recptr[i + 1]; b-&gt;ptr[i - 1] = b-&gt;ptr[i]; &#125; &#125; else if (i &gt; 0 &amp;&amp; p-&gt;ptr[i - 1]-&gt;keynum &gt; (M - 1) / 2) &#123; // 若q的左兄弟关键字个数大约(m-1)/2 b = p-&gt;ptr[i - 1]; // b指向左兄弟结点 q-&gt;ptr[1] = q-&gt;ptr[0]; q-&gt;ptr[0] = b-&gt;ptr[b-&gt;keynum]; q-&gt;key[1] = p-&gt;key[i]; // 从父节点借第i个关键字 q-&gt;recptr[1] = p-&gt;recptr[i]; p-&gt;key[i] = b-&gt;key[b-&gt;keynum]; // 将b最后一个关键字上移到父节点 p-&gt;recptr[i] = b-&gt;recptr[b-&gt;keynum]; &#125; else return ERROR; // 无关键字大于(m-1)/2的兄弟 q-&gt;keynum++; b-&gt;keynum--; for (i = 0; i &lt;= q-&gt;keynum; i++) if (q-&gt;ptr[i]) q-&gt;ptr[i]-&gt;parent = q; // 刷新q的子结点的双亲指针 return OK; &#125; void Combine(BTree &amp;q) &#123; int i, j; BTree p = q-&gt;parent, b = NULL;//p指向q的父亲 for (i = 0; p-&gt;ptr[i] != q; i++);//查找q在父亲p中的子树位置 if (i == 0) &#123;//若为0，则需合并为兄弟的第一个关键字 b = p-&gt;ptr[i + 1]; for (j = b-&gt;keynum; j &gt;= 0; j--) &#123;//将b的关键字和记录后移一位 b-&gt;key[j + 1] = b-&gt;key[j]; b-&gt;recptr[j + 1] = b-&gt;recptr[j]; b-&gt;ptr[j + 1] = b-&gt;ptr[j]; &#125; b-&gt;ptr[0] = q-&gt;ptr[0];//合并 b-&gt;key[1] = p-&gt;key[1]; b-&gt;recptr[1] = p-&gt;recptr[1]; &#125; else if (i &gt; 0) &#123;//若q在父亲的子树位置大于0，需合并为兄弟b的最后一个关键字 b = p-&gt;ptr[i - 1]; b-&gt;key[b-&gt;keynum + 1] = p-&gt;key[i];//合并 b-&gt;recptr[b-&gt;keynum + 1] = p-&gt;recptr[i]; b-&gt;ptr[b-&gt;keynum + 1] = q-&gt;ptr[0]; &#125; if(i==0||i==1)//若i为0或1，需将父结点p关键字前移一位 for (; i &lt; p-&gt;keynum; i++) &#123; p-&gt;key[i] = p-&gt;key[i + 1]; p-&gt;ptr[i] = p-&gt;ptr[i + 1]; p-&gt;recptr[i] = p-&gt;recptr[i + 1]; &#125; p-&gt;keynum--; b-&gt;keynum++; free(q); q = b; //q指向修改的兄弟结点 for (i = 0; i &lt;= b-&gt;keynum; i++) if (b-&gt;ptr[i]) b-&gt;ptr[i]-&gt;parent = b;//刷新b的子结点的双亲指针 &#125; Status DeleteBTree(BTree &amp;T, KeyType k) // 在m阶B树T上删除关键字k及其对应记录，并返回OK。 // 如T上不存在关键字k，则返回ERROR。 &#123; KeyType x = k; BTree q, b = NULL; int finished = FALSE, i = 1; result res = SearchBTree(T, k); // 在T中查找关键字k if (res.tag == 0) return ERROR; // 未搜索到 else &#123; q = res.pt; // q指向待删结点 i = res.i; if (q-&gt;ptr[0]) TakePlace(q, i); // 若q的子树不空，(非底层结点) // 则以其后继代之，且令q指向后继所在结点 Del(q, i); // 删除q所指向结点中第i个关键字及记录 if (q-&gt;keynum &gt;= (M - 1) / 2 || !q-&gt;parent) // 若删除后关键字个数不小于(m-1)/2或q是根节点 &#123; finished = TRUE; // 删除完成 if (q-&gt;keynum == 0) T = NULL; // 若q的关键字个数为0 ，则为空树 &#125; while (!finished) &#123; if (Borrow(q)) finished = TRUE; // 若q的相邻兄弟结点关键字大于(m-1)/2,则从该 // 兄弟结点上移一个最大（或最小）关键字到 // 父节点，从父节点借一关键字到q else &#123; // 若q相邻兄弟关键字个数均等于┌m /2┑-1 Combine(q); // 将q中的剩余部分和双亲中的相关关键字合并至q的一个兄弟中 q = q-&gt;parent; // 检查双亲 if (q == T &amp;&amp; T-&gt;keynum == 0) // 若被删结点的父节点是根T且T的关键字个数为0 &#123; T = T-&gt;ptr[0]; // 新根 T-&gt;parent = NULL; free(q); // 删除原双亲结点 finished = TRUE; &#125; else if (q-&gt;keynum &gt;= M / 2) finished = TRUE; &#125; // 合并后双亲关键字个数不少于(m-1)/2，完成 &#125; &#125; return OK; &#125; void BTreeTraverse(BTree T, void (*visit)(BTree )) &#123; //遍历B树T，对每个结点调用visit函数 if (!T) return; visit(T); for (int i = 0; i &lt;= T-&gt;keynum; ++i) &#123; if (T-&gt;ptr[i]) BTreeTraverse(T-&gt;ptr[i], visit); &#125; &#125; void ShowBTree(BTree T, short x) // 递归以凹入表形式显示B树T,每层的缩进量为x，初始缩进量为8 &#123; if (!T) return; int i; printf("\n"); for (i = 0; i &lt;= x; i++) putchar(' '); // 缩进x for (i = 1; i &lt;= T-&gt;keynum; i++) &#123; printf("%d,", T-&gt;key[i]); &#125; for (i = 0; i &lt;= T-&gt;keynum; i++) // 递归显示子树结点关键字 ShowBTree(T-&gt;ptr[i], x + 7); &#125; int menu() &#123;//菜单 int choice; printf("\n\n\t\t\t|**********************************************|\n"); printf("\t\t\t|**********************************************|\n"); printf("\t\t\t ______________________________________________|\n"); printf("\t\t\t| 图书馆管理系统 |\n"); printf("\t\t\t| |\n"); printf("\t\t\t| 1.采编入库 2.清除库存 |\n"); printf("\t\t\t| |\n"); printf("\t\t\t| 3.借阅图书 4.归还图书 |\n"); printf("\t\t\t| |\n"); printf("\t\t\t| 5.查看图书馆全部图书 6.查看某图书信息 |\n"); printf("\t\t\t| |\n"); printf("\t\t\t| 7.查看某书借阅者信息 8.读取图书信息 |\n"); printf("\t\t\t| |\n"); printf("\t\t\t| 0.退出 |\n"); printf("\t\t\t|______________________________________________|\n"); printf("\t\t\t|**********************************************|\n"); printf("\t\t\t|**********************************************|\n"); printf("\t\t\t| 15软件工程(4)班 |\n"); printf("\t\t\t| 3115005372 |\n"); printf("\t\t\t| 杨宇杰 |\n"); printf("\t\t\t|********************S**************************|\n"); do &#123; printf("\t\t\t请选择功能（输入0-8任意一个数字）:"); scanf_s("%d", &amp;choice); &#125; while (choice &lt; 0 || choice &gt; 8);//避免非法输入 return choice; &#125; void gotoxy(HANDLE hOut, int x, int y) &#123;//定位光标 COORD pos; pos.X = x; //横坐标 pos.Y = y; //纵坐标 SetConsoleCursorPosition(hOut, pos); &#125; int login() &#123;//登陆界面 HANDLE hOut = GetStdHandle(STD_OUTPUT_HANDLE);//定义显示器句柄变量 int secret_code, i; printf("\n\n\t\t\t ______________________________________\n"); printf("\t\t\t| |\n"); printf("\t\t\t| |\n"); printf("\t\t\t| 请输入图书管理员密码！ |\n"); printf("\t\t\t| 密码：____ |\n");//密码为5372 printf("\t\t\t|______________________________________|\n"); gotoxy(hOut, 43, 6); scanf_s("%d", &amp;secret_code); fflush(stdin); printf("\n\t\t\tLoding：");//进入动画 for (i = 0; i&lt;11; i++) &#123; Sleep(50); printf("█ "); &#125; printf("\n\t\t\t载入完成，进入下一级系统"); Sleep(1000); system("cls");//清屏 if (secret_code == Super_Manager_Code)//判断是不是管理员 return 1; else return 0; &#125; main.cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180#include"Library.h" int main() &#123; BTree L = NULL; BookType B; result res; ReaderType R; int booknum, IDnum, k, book_num; char flag; int i; for (i = 0; i &lt;= 10; i++)&#123; // 显示欢迎界面 Welcome(i % 16); Sleep(100); &#125; Sleep(800); system("cls");//清屏 if (login()) &#123; for (;;) &#123; switch (menu()) &#123; case 1://采编图书 B = (BookType)malloc(sizeof(BookNode)); B-&gt;reader = NULL; printf("请输入要入库的书号：\n"); fflush(stdin); scanf_s("%d", &amp;B-&gt;booknum); getchar(); res = SearchBTree(L, B-&gt;booknum); if (!res.tag) &#123; fflush(stdin); printf("请输入该书书名：\n"); fflush(stdin); gets_s(B-&gt;bookname); printf("请输入该书作者：\n"); fflush(stdin); gets_s(B-&gt;writer); printf("请输入入库数：\n"); fflush(stdin); scanf_s("%d", &amp;B-&gt;current); printf("请输入出版年份：\n"); fflush(stdin); scanf_s("%d", &amp;B-&gt;published_year); printf("请输入书本价格：\n"); fflush(stdin); scanf_s("%f", &amp;B-&gt;price); B-&gt;total = B-&gt;current; InsertBook(L, B, res); printf("用凹入表形式显示B树如下：\n"); ShowBTree(L, 8); break; &#125; else &#123;//图书已存在，只增加库存 printf("书库已有该书记录，请输入增加的册数：\n"); fflush(stdin); scanf_s("%d", &amp;B-&gt;total); InsertBook(L, B, res); B = res.pt-&gt;recptr[res.i]; printf("用凹入表形式显示B树如下：\n"); ShowBTree(L); printf("新书入库操作完成！\n"); system("pause"); break; &#125; case 2://清空库存 printf("请输入要删除的图书书号：\n"); fflush(stdin); scanf_s("%d", &amp;booknum); res = SearchBTree(L, booknum); if (res.tag) &#123; B = res.pt-&gt;recptr[res.i]; PrintBook(B); printf("\n您确认删除上面的图书&lt;Y确认，其余按键返回主菜单&gt;?"); fflush(stdin); getchar(); flag = getchar(); if (flag == 'Y' || flag == 'y') &#123; DeleteBook(L, B); printf("\n清除完毕！\t删除后用凹入表显示B树如下：\n"); ShowBTree(L, 8); &#125; &#125; else &#123; printf("\n书库不存在此书，删除失败！\n"); &#125; printf("\t"); system("pause"); break; case 3://借阅图书 R = (ReaderType)malloc(sizeof(ReaderNode)); R-&gt;rnext = NULL; printf("请输入借阅图书书号：\n"); fflush(stdin); scanf_s("%d", &amp;booknum); getchar(); res = SearchBTree(L, booknum); if (res.tag) &#123; B = res.pt-&gt;recptr[res.i]; printf("请输入您的姓名：\n"); fflush(stdin); gets_s(R-&gt;reader_name); printf("请输入您的ID号：\n"); fflush(stdin); scanf_s("%d", &amp;R-&gt;IDnum); if (CanBorrow(L, B, R)) &#123; BorrowBook(L, B, R); printf("\n借书完成！"); &#125; else &#123; printf("\n库存不足，借阅失败！"); free(R); &#125; &#125; else &#123; printf("\n库存无此书，借阅失败！"); free(R); &#125; printf("\t"); system("pause"); break; case 4://归还图书 printf("\n请输入图书号：\n"); scanf_s("%d", &amp;booknum); printf("请输入您的ID号：\n"); scanf_s("%d", &amp;IDnum); k = ReturnBook(L, booknum, IDnum, B, R); if (k == 1) &#123; printf("\n还书完成！"); R = NULL; &#125; else if (k == 0) &#123; printf("\n还书失败，系统没有您借该书记录！"); &#125; else &#123; printf("\n书库中不存在此书!"); &#125; printf("\t"); system("pause"); break; case 5://输出总库存 printf("图书馆总库存信息如下：\n"); PrintAllbooks(L); break; case 6://查找某种图书 printf("请输入要查找的图书的编号：\n"); scanf_s("%d", &amp;book_num); ShowBookinfo(L, book_num); break; case 7://输出某图书的借阅者信息 printf("请输入要查找的图书的编号：\n"); scanf_s("%d", &amp;book_num); res = SearchBTree(L, book_num); if (res.tag) &#123; B = res.pt-&gt;recptr[res.i]; printf("借阅者信息如下：\n"); PrintBorrower(B-&gt;reader); &#125; else &#123; printf("\n书库不存在此书，查找失败！\n"); &#125; printf("\t"); system("pause"); break; case 8:Creat(L); system("cls"); break; case 0: //退出管理系统 exit(0); default: break; &#125; &#125; &#125; else &#123; printf("密码输入错误！\n"); system("pause"); &#125; return 0; &#125; bookinfo.dat12345678910111213141516171835 灯下漫笔 鲁迅 39 39 1997 19.5 16 BASIC语言 谭浩强 38 38 1980 18.0 18 C程序设计 谭浩强 40 40 2007 26.0 70 阿Q正传 鲁迅 28 28 1984 13.5 5 计算机组成原理 白中英 56 56 2008 39.0 50 意志力训练手册 美·弗兰克 46 46 2005 20.0 22 打出速度-五笔教程 导向科技 45 45 2003 18.0 60 幽默大师 南琦 48 48 2007 38.5 13 鲁迅小说选 鲁迅 39 39 1976 18.3 17 计算机组成原理题库 白中英 36 36 2008 18.5 12 坟 鲁迅 55 55 1973 8.6 45 学会说话 南琦 57 57 2004 18.5 25 准风月谈 鲁迅 60 60 1973 13.9 42 超越自己 南琦 45 45 2007 15.0 15 鲁迅杂文选 鲁迅 30 30 1973 18.9 90 鲁迅日文作品集 鲁迅 45 45 1981 15.5 30 数字电子简明教程 余孟尝 55 55 2005 35.0 7 数据结构(C语言版) 严蔚敏 60 60 2008 30.0 程序截图]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>数据结构</tag>
        <tag>B_tree</tag>
        <tag>课程设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言实现顺序表的基本操作]]></title>
    <url>%2F2016%2F09%2F26%2FC%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[前言 ​ 数据结构老师给了几个接口，叫我们自己去实现顺序表的功能，感想就是顺序表实现起来比链表容易，但是还是要花费挺长的时间来构思，这一次的收获还是挺多的。 编译环境 ​ VS 2015 所用语言 ​ C 实现功能顺序表的初始化及创建 顺序表的遍历 顺序表的增删查改 代码顺序表.h1234567891011121314151617181920212223242526#include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; #include&lt;malloc.h&gt; #define LIST_INIT_SIZE 100 #define LISTINCREMENT 10 #define TRUE 1 #define FLASE 0 typedef int Elemtype; typedef int Status; /*接口定义 Status InitList_Sq(SqList &amp;L,int size,int inc); void CreateList_Sq(SqList &amp;L); void print_Sq(SqList &amp;L); int Search_Sq(SqList L, Elemtype e); Status DestroyList_Sq(SqList &amp;L); Status ClearList_Sq(SqList &amp;L); Status ListEmpty_Sq(SqList L); int ListLength_Sq(SqList L); Status GetElem_Sq(SqList L, int i, Elemtype &amp;e); Status PutElem_Sq(SqList &amp;L, int i, Elemtype e); Status Append_Sq(SqList &amp;L, Elemtype e); Status DeleteLast_Sq(SqList &amp;L, Elemtype &amp;e); */ 源代码.h123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134#include "顺序表.h" //定义顺序表类型 typedef struct &#123; Elemtype *elem; int length; int listsize; int increment; &#125;SqList; //初始化顺序表 Status InitList_Sq(SqList &amp;L,int size,int inc) &#123; L.elem = (Elemtype *)malloc(size * sizeof(Elemtype)); L.length = 0; L.listsize = size; L.increment = inc; return TRUE; &#125; //创建顺序表 Status CreateList_Sq(SqList &amp;L) &#123; int i; printf("请输入你要创建的顺序表元素个数：\n"); scanf_s("%d", &amp;L.length); if (L.length &gt;= L.listsize) &#123; L.elem = (Elemtype *)realloc(L.elem, (L.listsize + L.increment) * sizeof(Elemtype)); &#125; if (!L.elem) &#123; return FLASE; &#125; printf("请输入你要创建的顺序表：\n"); for (i = 0; i&lt;L.length; i++) &#123; scanf_s("%d", &amp;L.elem[i]); &#125; &#125; //遍历顺序表 void print_Sq(SqList &amp;L) &#123; int i; for (i = 0; i&lt;L.length; i++) &#123; printf("%4d", L.elem[i]); &#125; &#125; //查找元素的位置 int Search_Sq(SqList L, Elemtype e) &#123; int i = 0; while (L.elem[i] != e&amp;&amp;i&lt;L.length) &#123; i++; &#125; if (i&gt;L.length) return -1; else return i + 1;//因为C语言是从下标为0开始的，当i=0时表示第一个元素 &#125; //销毁顺序表 Status DestroyList_Sq(SqList &amp;L) &#123; if (L.elem == NULL) return -1; else free(L.elem); printf("\n销毁成功\n"); return TRUE; &#125; //清空顺序表 Status ClearList_Sq(SqList &amp;L) &#123; if (L.elem == NULL) exit(0); int i; Elemtype *p_elem = L.elem; for (i = 0; i&lt;L.length; i++) &#123; *L.elem = NULL; L.elem++; &#125; L.elem = p_elem; &#125; //判断顺序表是否为空 Status ListEmpty_Sq(SqList L) &#123; int i; Elemtype* p_elem = L.elem; for (i = 0; i&lt;L.length; i++) &#123; if (*L.elem != 0) &#123; L.elem = p_elem; return FLASE; &#125; L.elem++; &#125; return TRUE; &#125; //求顺序表的长度 int ListLength_Sq(SqList L) &#123; return L.length; &#125; //用e返回顺序表L中第i个元素的值 Status GetElem_Sq(SqList L, int i, Elemtype &amp;e) &#123; int j; Elemtype* p_elem = L.elem; if (i&lt;1 || i&gt;L.length) return FLASE; for (j = 1; j &lt;= i; j++) L.elem++; e = *L.elem; L.elem = p_elem; return TRUE; &#125; //将顺序表L中第i个元素赋值为e Status PutElem_Sq(SqList &amp;L, int i, Elemtype e) &#123; L.elem[i - 1] = e; return TRUE; &#125; //在顺序表L表尾添加元素e Status Append_Sq(SqList &amp;L, Elemtype e) &#123; L.elem[L.length] = e; L.length++; L.listsize += L.increment; return TRUE; &#125; //删除顺序表L表尾元素 Status DeleteLast_Sq(SqList &amp;L, Elemtype &amp;e) &#123; e = L.elem[L.length - 1]; L.length--; return TRUE; &#125; 主函数.c1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include "顺序表.h" #include "源代码.h" //--------------------主函数入口-------------------- int main()&#123; SqList L; int size, inc; int e; int a; int length; int i; int temp; int j=10; int ee; printf("\n--------------------顺序表初始化------------------\n"); printf("请输入顺序表的长度size以及扩容量：\n"); scanf_s("%d %d", &amp;size, &amp;inc); InitList_Sq(L, size, inc); CreateList_Sq(L); printf("\n--------------------判断是否为空------------------\n"); if(ListEmpty_Sq(L))&#123; printf("该顺序表为空\n"); &#125; else printf("该顺序表不为空\n"); printf("\n--------------------遍历顺序表--------------------\n"); printf("此时顺序表为：\n"); print_Sq(L); printf("\n--------------------查找元素----------------------\n"); printf("\n请输入要查找的元素：\n"); scanf_s("%d",&amp;e); a = Search_Sq(L, e); printf("%d为第%d位：\n",e,a); printf("\n--------------------输出长度----------------------\n"); length = ListLength_Sq(L); printf("顺序表的长度为%d\n",length); printf("\n----------将顺序表L中第i个元素赋值为temp----------\n"); printf("请输入第i个元素的i值和temp值：\n"); scanf_s("%d %d",&amp;i,&amp;temp); PutElem_Sq(L, i, temp); printf("\n此时顺序表为：\n"); print_Sq(L); printf("\n---------------在顺序表表尾添加元素---------------\n"); Append_Sq(L, j); printf("\n此时顺序表为：\n"); print_Sq(L); printf("\n---------------在顺序表表尾删除元素---------------\n"); DeleteLast_Sq(L, ee); printf("\n被删除的元素为%d\n",ee); printf("此时顺序表为：\n"); print_Sq(L); printf("\n-------------------清空顺序表---------------------\n"); ClearList_Sq(L); if(ListEmpty_Sq(L))&#123; printf("\n清空成功\n"); &#125; printf("\n------------------销毁顺序表----------------------\n"); DestroyList_Sq(L); getchar(); getchar(); return 0; &#125; 总结​ 经过这次的实践，较为深刻的理解了顺序表的结构以及基本操作。]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>Sequerce</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言实现链栈的基本操作]]></title>
    <url>%2F2016%2F04%2F01%2FC%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E9%93%BE%E6%A0%88%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[前言本文是关于链栈的**增删查改**等基本操作。 所用语言C 编译环境dev c++ 代码LinkStack.h123456789101112131415161718192021222324252627282930313233typedef struct StackNode&#123; ElemType data; struct StackNode *next; &#125; StackNode, *StackNodePtr; typedef struct LinkStack &#123; StackNodePtr top; int count; &#125; LinkStack, *LinkStackPtr; // 构造一个空栈 S，成功返回 TRUE，失败返回 FALSE Status initStack(LinkStackPtr S); /********************************************************************************** Name............: Status push(LinkStackPtr S,ElemType e) Description.....: 数据 e 压栈 Parameters......: S-指向 LinkStack 类型指针变量 e-压栈的数据 Return values...: 成功-return TRUE 失败-return FALSE PreCondition....：调用 push 前，S 需要经过 initStack 初始化 PostCondition...：成功时，生成了一个存储 e 的新结点，数据 e 压入了 S 栈顶，栈 S 的长度 count 增 1，同时栈 S 的 top 指针指向新结点；失败时，栈 S 不改变 **********************************************************************************/ // 数据压栈，成功返回 TRUE,失败返回 FALSE Status push(LinkStackPtr S, ElemType e); // 数据弹栈，并赋值给 e，成功返回 TRUE,失败返回 FALSE Status pop(LinkStackPtr S, ElemType *e); // 栈的判空，若为空，返回 TRUE，否则返回 FALSE Status isStackEmpty(LinkStackPtr S); // 获取栈顶元素，并赋值给 e，成功返回 TRUE,失败返回 FALSE Status getTop(LinkStackPtr S, ElemType *e); // 销毁栈，成功返回 TRUE,失败返回 FALSE Status destroyStack(LinkStackPtr S); //利用上面的操作，实现一个算术表达值的求值。 （求值独立成一个函数，写在 test.c 中，带括号的中 缀表达式只包括加减，包括括号），比如： (1+(2-3)-(4+5)) */ 栈作业.h1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192//将int类型定义为ElemType typedef int ElemType; //链栈结构 typedef struct StackNode &#123; ElemType data; struct StackNode *next; &#125; StackNode, *StackNodePtr; typedef struct LinkStack &#123; StackNodePtr top; int count; &#125; LinkStack, *LinkStackPtr; typedef enum Status &#123; FLASE, TRUE &#125;Status; // 构造一个空栈S，成功返回TRUE，失败返回FALSE Status initStack(LinkStackPtr S); /********************************************************************************** Name............: Status push(LinkStackPtr S,ElemType e) Description.....: 数据e压栈 Parameters......: S-指向LinkStack类型指针变量 e-压栈的数据 Return values...: 成功-return TRUE 失败-return FALSE PreCondition....：调用push前，S需要经过initStack初始化 PostCondition...：成功时，生成了一个存储e的新结点，数据e压入了S栈顶，栈S的长度count 增1，同时栈S的top指针指向新结点；失败时，栈S 不改变 **********************************************************************************/ // 数据压栈，成功返回TRUE,失败返回FALSE Status push(LinkStackPtr S, ElemType e); // 数据弹栈，并赋值给e，成功返回TRUE,失败返回FALSE Status pop(LinkStackPtr S, ElemType *e); // 栈的判空，若为空，返回TRUE，否则返回FALSE Status isStackEmpty(LinkStack S); // 获取栈顶元素，并赋值给e，成功返回TRUE,失败返回FALSE Status getTop(LinkStackPtr S, ElemType *e); // 销毁栈，成功返回TRUE,失败返回FALSE Status destroyStack(LinkStackPtr S); // 输出栈的元素 Status StackTraverse(LinkStack S); unsigned char Prior[8][8] = &#123; // 运算符优先级表 // '+' '-' '*' '/' '(' ')' '#' '^' /*'+'*/'&gt;','&gt;','&lt;','&lt;','&lt;','&gt;','&gt;','&lt;', /*'-'*/'&gt;','&gt;','&lt;','&lt;','&lt;','&gt;','&gt;','&lt;', /*'*'*/'&gt;','&gt;','&gt;','&gt;','&lt;','&gt;','&gt;','&lt;', /*'/'*/'&gt;','&gt;','&gt;','&gt;','&lt;','&gt;','&gt;','&lt;', /*'('*/'&lt;','&lt;','&lt;','&lt;','&lt;','=',' ','&lt;', /*')'*/'&gt;','&gt;','&gt;','&gt;',' ','&gt;','&gt;','&gt;', /*'#'*/'&lt;','&lt;','&lt;','&lt;','&lt;',' ','=','&lt;', /*'^'*/'&gt;','&gt;','&gt;','&gt;','&lt;','&gt;','&gt;','&gt;' &#125;; typedef struct StackChar &#123; char c; struct StackChar *next; &#125;SC; //StackChar类型的结点SC typedef struct StackFloat &#123; float f; struct StackFloat *next; &#125;SF; //StackFloat类型的结点SF 栈作业.c123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235#include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; #include"栈作业.h" #include&lt;math.h&gt; #include&lt;string.h&gt; /* 构造一个空栈S */ Status initStack(LinkStackPtr S) &#123; S-&gt;top = (StackNodePtr)malloc(sizeof(StackNode)); if(!S-&gt;top) &#123; return FLASE; &#125; S-&gt;top = NULL; S-&gt;count = 0; return TRUE; &#125; /*插入元素e为新的栈顶元素*/ Status push(LinkStackPtr S, ElemType e) &#123; StackNodePtr s= ( StackNodePtr ) malloc (sizeof (StackNode)); if( NULL == s) return FLASE; s-&gt;data = e; s-&gt;next = S-&gt;top;/*把当前的栈顶元素复制给新结点的直接后继*/ S-&gt;top = s; /*把新的结点s赋值给栈顶指针*/ S-&gt;count++; return TRUE; &#125; /*若栈不空，则删除S的栈顶元素，用e返回其值，并返回TRUE；否则返回FALSE*/ Status pop(LinkStackPtr S, ElemType *e) &#123; StackNodePtr p; if(isStackEmpty(*S)) return FLASE; *e = S-&gt;top-&gt;data; p = S-&gt;top; S-&gt;top = S-&gt;top-&gt;next; free(p); S-&gt;count--; return TRUE; &#125; // 栈的判空，若为空，返回TRUE，否则返回FALSE Status isStackEmpty(LinkStack S) &#123; return S.count==0?TRUE:FLASE; &#125; // 获取栈顶元素，并赋值给e，成功返回TRUE,失败返回FALSE Status getTop(LinkStackPtr S, ElemType *e) &#123; if(S-&gt;top == NULL) &#123; return FLASE; &#125; else &#123; *e = S-&gt;top-&gt;data; &#125; return TRUE; &#125; // 销毁栈，成功返回TRUE,失败返回FALSE Status destroyStack(LinkStackPtr S) &#123; StackNodePtr p,q; p = S-&gt;top; while(p) &#123; q = p; p = p-&gt;next; free(q); &#125; S-&gt;count=0; return TRUE; &#125; //输出栈的元素 Status StackTraverse(LinkStack S) &#123; StackNodePtr p; p=S.top; while(p) &#123; printf("%d ",p-&gt;data); p=p-&gt;next; &#125; printf("\n"); return TRUE; &#125; /*********************************************************************** 各个模块的主要功能： *Push(SC *s,char c)：把字符压栈 *Push1(SF *s,float f)：把数值压栈 *Pop(SC *s)：把字符退栈 *Pop1(SF *s)：把数值退栈 Operate(a,theta,b)：根据theta对a和b进行'+' 、'-' 、'*' 、'/' 、'^'操作 In(Test,*TestOp)：若Test为运算符则返回true，否则返回false ReturnOpOrd(op,*TestOp)：若Test为运算符，则返回此运算符在数组中的下标 precede(Aop,Bop)：根据运算符优先级表返回Aop与Bop之间的优先级 EvaluateExpression(*MyExpression)：用算符优先法对算术表达式求值 ***********************************************************************/ SC *Push(SC *s,char c) //SC类型的指针Push，返回p &#123; SC *p=(SC*)malloc(sizeof(SC)); p-&gt;c=c; p-&gt;next=s; return p; &#125; SF *Push1(SF *s,float f) //SF类型的指针Push，返回p &#123; SF *p=(SF*)malloc(sizeof(SF)); p-&gt;f=f; p-&gt;next=s; return p; &#125; SC *Pop(SC *s) //SC类型的指针Pop &#123; SC *q=s; s=s-&gt;next; free(q); return s; &#125; SF *Pop1(SF *s) //SF类型的指针Pop &#123; SF *q=s; s=s-&gt;next; free(q); return s; &#125; float Operate(float a,unsigned char theta, float b) //计算函数Operate &#123; switch(theta) &#123; case '+': return a+b; case '-': return a-b; case '*': return a*b; case '/': return a/b; case '^': return pow(a,b); default : return 0; &#125; &#125; char OPSET[8]=&#123;'+','-','*','/','(',')','#','^'&#125;; Status In(char Test,char *TestOp) &#123; int Find=FLASE,i; for(i=0; i&lt; 8; i++) &#123; if(Test == TestOp[i]) Find= TRUE; &#125; return Find; &#125; Status ReturnOpOrd(char op,char *TestOp) &#123; int i; for(i=0; i&lt; 8; i++) &#123; if (op == TestOp[i]) return i; &#125; &#125; char precede(char Aop, char Bop) &#123; return Prior[ReturnOpOrd(Aop,OPSET)][ReturnOpOrd(Bop,OPSET)]; &#125; float EvaluateExpression(char* MyExpression) &#123; // 算术表达式求值的算符优先算法 // 设OPTR和OPND分别为运算符栈和运算数栈，OP为运算符集合 SC *OPTR=NULL; // 运算符栈，字符元素 SF *OPND=NULL; // 运算数栈，实数元素 char TempData[20]; float Data,a,b; char theta,*c,Dr[]=&#123;'#','\0'&#125;; OPTR=Push(OPTR,'#'); c=strcat(MyExpression,Dr); strcpy(TempData,"\0");//字符串拷贝函数 while (*c!= '#' || OPTR-&gt;c!='#') &#123; if (!In(*c, OPSET)) &#123; Dr[0]=*c; strcat(TempData,Dr); //字符串连接函数 c++; if (In(*c, OPSET)) &#123; Data=atof(TempData); //字符串转换函数(double) OPND=Push1(OPND, Data); strcpy(TempData,"\0"); &#125; &#125; else // 不是运算符则进栈 &#123; switch (precede(OPTR-&gt;c, *c)) &#123; case '&lt;': // 栈顶元素优先级低 OPTR=Push(OPTR, *c); c++; break; case '=': // 脱括号并接收下一字符 OPTR=Pop(OPTR); c++; break; case '&gt;': // 退栈并将运算结果入栈 theta=OPTR-&gt;c;OPTR=Pop(OPTR); b=OPND-&gt;f;OPND=Pop1(OPND); a=OPND-&gt;f;OPND=Pop1(OPND); OPND=Push1(OPND, Operate(a, theta, b)); break; &#125; //switch &#125; &#125; //while return OPND-&gt;f; &#125; //EvaluateExpression Test.c123456789101112131415161718192021222324252627#include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; #include"栈作业.c" int main() &#123; int j; LinkStack s; int e; if(initStack(&amp;s)) for(j=1;j&lt;=10;j++) push(&amp;s,j); printf("栈中元素依次为："); StackTraverse(s); pop(&amp;s,&amp;e); printf("弹出的栈顶元素 e=%d\n",e); printf("栈空否：%d(1:空 0:否)\n",isStackEmpty(s)); getTop(&amp;s,&amp;e); destroyStack(&amp;s); printf("清空栈后，栈空否：%d(1:空 0:否)\n",isStackEmpty(s)); char array[128]; puts("请输入表达式:"); gets(array); puts("该表达式的值为:"); printf("%s\b=%g\n",s,EvaluateExpression(array)); getchar(); return 0; &#125; 总结本次通过对链栈的基本操作的编写，较深刻的理解了栈的结构以及原理，虽然过程磕磕绊绊，但是收获蛮多的。]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>linkstack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言实现链表的基本操作]]></title>
    <url>%2F2016%2F03%2F22%2FC%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E9%93%BE%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[前言本文是用C语言实现的关于链表的增删查改等基本操作。 编译环境dev c++ 下面贴出代码： 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; typedef struct Node &#123; int data; struct Node *next; &#125;Node, *ptr_Node; typedef enum Status &#123; SUCCESS, ERROR &#125;Status; const int MAXN = 1e5+7; const int totalPerLine = 8; int totalNode; ptr_Node create(int *arr, int n); void destroy(ptr_Node head); Status _insert(ptr_Node *head, ptr_Node node, int index); Status _delete(ptr_Node *head, int index, int *data); int search(ptr_Node head, int data); Status edit(ptr_Node head, int index, int *data); void print(ptr_Node head); Status sort(ptr_Node *head); int main() &#123; int i, n; int data[MAXN]; printf("please input n:\n"); scanf("%d", &amp;n); printf("please input %d numbers:\n",n); for(i = 0; i &lt; n; ++i) scanf("%d", &amp;data[i]);//初始化数组； totalNode = n; ptr_Node head = create(data, n);//将数组的内容输入到链表中； printf("Now the List is:\n"); print(head);//输出链表的内容； Node* node = (Node*)calloc(1, sizeof(Node*));//初始化要插入的结点； node-&gt;data = 122344; node-&gt;next = NULL; printf("insert node to 2\n"); _insert(&amp;head, node, 2);//将node插入到第2位之后； print(head);//输出插入后的结果； int k = 0; printf("delete a number:\n"); _delete(&amp;head, 2, &amp;k);//删除第2个数字的后一位； print(head); printf("the delete number is:\n"); printf("%d\n", k);//输出删除后的结果 ； k = search(head, 122344);//在链表中寻找122344； printf("%d\n", k); k = search(head, 12); printf("%d\n", k); printf("edit the (index+1) number:\n"); edit(head, 2, &amp;k); print(head); printf("%d\n", k); printf("the sort numbers are:\n"); sort(&amp;head); print(head); destroy(head); return 0; &#125; ptr_Node create(int *arr, int n) &#123; Node *head = (Node*)calloc(1, sizeof(Node)); if(head == NULL) return NULL; int cur = 0; head-&gt;data = arr[cur++]; Node *curNode = head; while(cur &lt; n)&#123; Node* temp = (Node*)calloc(1, sizeof(Node)); if(temp == NULL) &#123; destroy(head); return NULL; &#125; temp-&gt;data = arr[cur++]; curNode-&gt;next = temp; curNode = temp; &#125; return head; &#125; void destroy(ptr_Node head) &#123; Node *curNode = head; while(curNode != NULL) &#123; Node *temp = curNode-&gt;next; free(curNode); curNode = temp; &#125; &#125; Status _insert(ptr_Node *head, ptr_Node node, int index) &#123; int cur = 1; ptr_Node curNode = *head; while(cur &lt; index) &#123; curNode = curNode-&gt;next; ++cur; &#125; Node* rest = curNode-&gt;next; curNode-&gt;next = node; node-&gt;next = rest; ++totalNode; return SUCCESS; &#125; Status _delete(ptr_Node *head, int index, int *data) &#123; if(index == totalNode) return ERROR; int cur = 1; ptr_Node curNode = *head; while(cur &lt; index) &#123; curNode = curNode-&gt;next; ++cur; &#125; Node *rest = curNode-&gt;next-&gt;next; Node *temp = curNode-&gt;next; curNode-&gt;next = rest; *data = temp-&gt;data; free(temp); --totalNode; return SUCCESS; &#125; int search(ptr_Node head, int data) &#123; int cur = 0; ptr_Node curNode = head; while(curNode-&gt;data != data) &#123; curNode = curNode-&gt;next; if(curNode == NULL) return -1; ++cur; &#125; return cur; &#125; Status edit(ptr_Node head, int index, int *data) &#123; if(index == totalNode) return ERROR; int cur = 0; ptr_Node curNode = head; while(cur &lt; index) &#123; curNode = curNode-&gt;next; ++cur; &#125; printf("%d\n", *data); int temp = curNode-&gt;data; curNode-&gt;data = *data; *data = temp; return SUCCESS; &#125; void print(ptr_Node head) &#123; int curPerLine = 0; ptr_Node curNode = head; while(curNode != NULL) &#123; if(curPerLine == totalPerLine) &#123; puts(""); curPerLine = 0; &#125; printf("%d ", curNode-&gt;data); ++curPerLine; curNode = curNode-&gt;next; &#125; puts(""); &#125; Status sort(ptr_Node *head) &#123; ptr_Node curNodeA = *head; while(curNodeA != NULL) &#123; ptr_Node curNodeB = curNodeA; ptr_Node temp = curNodeA; while(curNodeB != NULL) &#123; if(temp-&gt;data &gt; curNodeB-&gt;data) temp = curNodeB; curNodeB = curNodeB-&gt;next; &#125; int tempData = curNodeA-&gt;data; curNodeA-&gt;data = temp-&gt;data; temp-&gt;data = tempData; curNodeA = curNodeA-&gt;next; &#125; return SUCCESS; &#125; 总结这是第一次做这么长的东西，感觉有点凌乱，有时候找bug找到想哭，不过在这个过程中收获了特别多。]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>linklist</tag>
      </tags>
  </entry>
</search>