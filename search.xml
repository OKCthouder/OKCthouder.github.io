<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[如何解决node.js中fs.rename文件跨域问题]]></title>
    <url>%2F2017%2F07%2F31%2F%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3node-js%E4%B8%ADfs-rename%E6%96%87%E4%BB%B6%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[前言&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最近在学习node.js，今天在写一个文件上传的功能，调用fs.rename上传文件时程序报了错。 具体如下： 123Error: EXDEV: cross-device link not permitted, rename 'C:\Users\Simple_Y\AppData\Local\Temp\12920-ww17q9.vtx0mb1emi.jpg' -&gt; 'E:\杨宇杰_备份2\光盘资源\Node.js实战\code\8\photo_app\public\photos\281295.jpg' at Error (native) 大致意思应该是说不能跨盘符上传文件，涉及到权限问题。 问题代码下面贴出我的代码(部分)： 12345678exports.submit = function (dir) &#123; return function(req, res, next)&#123; var img = req.files.photo.image; var name = req.body.photo.name || img.name; var path = join(dir, img.name); //fs.rename(img.path, path, function(err)&#123; //if (err) return next(err); 解决办法经过百度，终于找到了解决办法： 将上面的注释掉的两行代码换成下面的代码 1234567891011121314151617fs.readFile(img.path, function (err, data) &#123; if (err) throw err; console.log('File read!'); // Write the file fs.writeFile(path, data, function (err) &#123; if (err) throw err; res.write('File uploaded and moved!'); res.end(); console.log('File written!'); &#125;); // Delete the file fs.unlink(img.path, function (err) &#123; if (err) throw err; console.log('File deleted!'); &#125;); 结尾至此，运行程序，问题完美解决。 感谢万能的百度！ 参考链接：https://stackoverflow.com/questions/37153666/error-exdev-cross-device-link-not-permitted-rename-tmp-on-ubuntu-16-04-lts]]></content>
      <categories>
        <category>node.js</category>
      </categories>
      <tags>
        <tag>node.js</tag>
        <tag>fs.rename</tag>
        <tag>文件跨域</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VMwave Workstation12虚拟机安装OS X 10.11所遇到的各种问题集合(详细版)]]></title>
    <url>%2F2017%2F07%2F24%2F10-11%E6%89%80%E9%81%87%E5%88%B0%E7%9A%84%E5%90%84%E7%A7%8D%E9%97%AE%E9%A2%98%E9%9B%86%E5%90%88-%E8%AF%A6%E7%BB%86%E7%89%88%2F</url>
    <content type="text"><![CDATA[一、前言最近笔者闲着无聊，由于一直挺仰慕mac大法，所以想装个mac系统来玩玩。虽然说过程不是很难，但是出现的各种小问题还是挺多的，所以在这里跟大家分享一下我的解决方法。 1.首先，当然是安装工具： Mac OS X 10.11 镜像文件（链接：http://pan.baidu.com/s/1pL8HE59 密码：cq4d）（此镜像为网络收集，如果觉得有问题自己找谢谢。） unlocker208文件（链接：http://pan.baidu.com/s/1bpftVjT 密码：dp2g） VMware Workstation12（http://blog.sina.com.cn/s/blog_af49f8090102wqmw.html） 2.详细教程请查看：http://jingyan.baidu.com/article/363872ec206a356e4ba16f30.html 在这里我就不再赘述。 二、所遇到的问题下面来看看我安装后遇到的各种问题： 1) VMware上MAC虚拟机不能上网问题首先最大的问题当然就是没网啦，别急，且听我慢慢道来： 解决方法/步骤1.从本机中选择打开连接网络，选择本地连接。如果是无线网可以选择无线网。 2.选择属性，点击共享按钮。 3.将internet连接共享下面两个选项都选中，然后在家庭网络连接选择VMware Network Adapter VMnet1。 4.在安装的虚拟机中选择虚拟机-&gt;设置选项。 5.点击网络适配器，将网络连接改成仅主机模式（Host-only），然后在右侧选择主机模式，点击确定。 6.进入Mac系统，选择设置，进入网络设置 7.配置Ipv4选择设置DHCP，点击应用即可开始上网。2)OS X 10.11 El Capitan 无法连接Apple store 和登录Apple ID的问题1.step 1强制退出Apple store进程 2. step 2打开terminal终端（在launch中搜索终端），输入以下命令： 123sudo pkill -9 -f Account sudo rm $HOME/Library/Accounts/* 进行此操作时需要提供管理员密码，输入密码敲回车就行了。 3.step 3完成前面两步你已经可以进入apple store了，但是你发现你的apple ID无法登陆： This action cant be Completed! 这时你可以terminal终端输入以下命令： 12345sudo mkdir -p /Users/Shared sudo chown root:wheel /Users/Shared sudo chmod -R 1777 /Users/Shared 至此，你的Apple ID就可以在Apple store上Login了。 3)苹果ID注册最后一步总是显示 如需帮助，请联系iTunes支持由于我的apple id是刚刚注册的，登陆apple store后提示我还没有完善资料什么的，所以我就去填资料 填完资料发现老是出现上面的那一句，继续不了。 所以我又开始了尝试 1.首先在iTunes软件上面注册Apple ID帐号时，注意要把提供付款方式选择为“银联UnionPay”，目前因为iTunes软件版本更新了不能像以前那样不绑定银行卡就可以注册Apple ID帐号。 2.然后填写银行卡以及输入银行预留手机号码。(注意：手机号码一定是要和银行卡绑定在一起的才可以使用。) 3.接下来在帐单寄送地址下方依次将个人的姓、名、街道地址、所在地区、邮编、省份、手机号码填写正确完整。 4.点击创建Apple ID，进入下一步。 5.然后收取绑定银行的短信验证码输入里面进行验证。 填入验证码就可以完美解决，我也试过用银行卡的方式，但是还是不行，最后尝试了银联这个就OK了。 三、补充对了，补充一下，可能安装后会发现虚拟机没办法占全屏，只要安装VMwave Tools既可以完美解决，至于卡顿问题，我笔记本是8G内存，我分了4G在虚拟机，相对来说比较不卡，也可以下载一个叫做beamoff的工具,在mac osx下解压即可消除卡顿的感觉。 下载链接 : http://download.csdn.NET/detail/u013803262/9702291 具体解决方法参考：http://blog.csdn.net/u013803262/article/details/53467693 好了，以上就是我装mac虚拟机所遇到的比较难缠的问题，分享给大家一下。]]></content>
      <categories>
        <category>装系统</category>
      </categories>
      <tags>
        <tag>VMwave</tag>
        <tag>OS X 10.11</tag>
        <tag>虚拟机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何理解javascript中的闭包]]></title>
    <url>%2F2017%2F07%2F24%2F%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3javascript%E4%B8%AD%E7%9A%84%E9%97%AD%E5%8C%85%2F</url>
    <content type="text"><![CDATA[闭包（closure）是Javascript语言的一个难点，也是它的特色，很多高级应用都要依靠闭包实现。 一、变量的作用域要理解闭包，首先必须理解Javascript特殊的变量作用域。 变量的作用域无非就是两种：全局变量和局部变量。 Javascript语言的特殊之处，就在于函数内部可以直接读取全局变量。 Js代码 123456var n=999; function f1()&#123; alert(n); &#125; f1(); // 999 另一方面，在函数外部自然无法读取函数内的局部变量。 Js代码 12345function f1()&#123; var n=999; &#125; alert(n); // error 这里有一个地方需要注意，函数内部声明变量的时候，一定要使用var命令。如果不用的话，你实际上声明了一个全局变量！ Js代码 1234567 function f1()&#123; n=999; &#125; f1(); alert(n); // 999 二、如何从外部读取局部变量？出于种种原因，我们有时候需要得到函数内的局部变量。但是，前面已经说过了，正常情况下，这是办不到的，只有通过变通方法才能实现。 那就是在函数的内部，再定义一个函数。 Js代码 123456 function f1()&#123; n=999; function f2()&#123; alert(n); // 999 &#125; &#125; 在上面的代码中，函数f2就被包括在函数f1内部，这时f1内部的所有局部变量，对f2都是可见的。但是反过来就不行，f2内部的局部变量，对f1 就是不可见的。这就是Javascript语言特有的“链式作用域”结构（chain scope）， 子对象会一级一级地向上寻找所有父对象的变量。所以，父对象的所有变量，对子对象都是可见的，反之则不成立。 既然f2可以读取f1中的局部变量，那么只要把f2作为返回值，我们不就可以在f1外部读取它的内部变量了吗！ Js代码 12345678910 function f1()&#123; n=999; function f2()&#123; alert(n); &#125; return f2; &#125; var result=f1(); result(); // 999 三、闭包的概念上一节代码中的f2函数，就是闭包。 各种专业文献上的“闭包”（closure）定义非常抽象，很难看懂。我的理解是，闭包就是能够读取其他函数内部变量的函数。 由于在Javascript语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成“定义在一个函数内部的函数”。 所以，在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。 四、闭包的用途闭包可以用在许多地方。它的最大用处有两个，一个是前面提到的可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中。 怎么来理解这句话呢？请看下面的代码。 Js代码 12345678910111213141516 function f1()&#123; var n=999; nAdd=function()&#123;n+=1&#125; function f2()&#123; alert(n); &#125; return f2; &#125; var result=f1(); result(); // 999 nAdd(); result(); // 1000 在这段代码中，result实际上就是闭包f2函数。它一共运行了两次，第一次的值是999，第二次的值是1000。这证明了，函数f1中的局部变量n一直保存在内存中，并没有在f1调用后被自动清除。 为什么会这样呢？原因就在于f1是f2的父函数，而f2被赋给了一个全局变量，这导致f2始终在内存中，而f2的存在依赖于f1，因此f1也始终在内存中，不会在调用结束后，被垃圾回收机制（garbage collection）回收。 这段代码中另一个值得注意的地方，就是“nAdd=function(){n+=1}”这一行，首先在nAdd前面没有使用var关键字，因此 nAdd是一个全局变量，而不是局部变量。其次，nAdd的值是一个匿名函数（anonymous function），而这个 匿名函数本身也是一个闭包，所以nAdd相当于是一个setter，可以在函数外部对函数内部的局部变量进行操作。 五、使用闭包的注意点1）由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。 2）闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便 改变父函数内部变量的值。 六、思考题如果你能理解下面代码的运行结果，应该就算理解闭包的运行机制了。 Js代码 123456789101112 var name = "The Window"; var object = &#123; name : "My Object", getNameFunc : function()&#123; return function()&#123; return this.name; &#125;; &#125; &#125;; alert(object.getNameFunc()()); //The Window 常见的陷阱 看看这个： 乍一看，以为输出 0~9 ，万万没想到输出10个10？ 这里的陷阱就是：函数带()才是执行函数！ 单纯的一句 var f = function() { alert(‘Hi’); }; 是不会弹窗的，后面接一句 f(); 才会执行函数内部的代码。上面代码翻译一下就是： 为什么只垃圾回收了 result，但却不收了 i 呢？ 因为 i 还在被 function 引用着啊。好比一个餐厅，盘子总是有限的，所以服务员会去巡台回收空盘子，但还装着菜的盘子他怎么敢收？ 当然，你自己手动倒掉了盘子里面的菜（=null），那盘子就会被收走了，这就是所谓的内存回收机制。 至于 i 的值怎么还能保留，其实从文章开头一路读下来，这应该没有什么可以纠结的地方。盘子里面的菜，吃了一块不就应该少一块吗？ JavaScript闭包例子 12345678910function outerFun()&#123; var a=0; function innerFun() &#123; a++; alert(a); &#125; &#125;innerFun(); 上面的代码是错误的.innerFun()的作用域在outerFun()内部,所在outerFun()外部调用它是错误的. 改成如下,也就是闭包: Js代码 123456789101112131415161718192021function outerFun()&#123; var a=0; function innerFun() &#123; a++; alert(a); &#125; return innerFun; //注意这里&#125;var obj=outerFun();obj(); //结果为1obj(); //结果为2var obj2=outerFun();obj2(); //结果为1obj2(); //结果为2 什么是闭包: 当内部函数 在定义它的作用域 的外部 被引用时,就创建了该内部函数的闭包 ,如果内部函数引用了位于外部函数的变量,当外部函数调用完毕后,这些变量在内存不会被 释放,因为闭包需要它们. 再来看一个例子 Js代码 123456789function outerFun()&#123; var a =0; alert(a); &#125;var a=4;outerFun();alert(a); 结果是 0,4 . 因为在函数内部使用了var关键字 维护a的作用域在outFun()内部. 再看下面的代码: Js代码 1234567891011function outerFun()&#123; //没有var a =0; alert(a); &#125;var a=4;outerFun();alert(a); 结果为 0,0 真是奇怪,为什么呢? 作用域链是描述一种路径的术语,沿着该路径可以确定变量的值 .当执行a=0时,因为没有使用var关键字,因此赋值操作会沿着作用域链到var a=4; 并改变其值. -————————————————————————————————————————————————- 如果你对javascript闭包还不是很理解，那么请看下面转载的文章：(转载:http://www.felixwoo.com/archives/247) 七、什么是闭包？官方”的解释是：闭包是一个拥有许多变量和绑定了这些变量的环境的表达式（通常是一个函数），因而这些变量也是该表达式的一部分。相信很少有人能直接看懂这句话，因为他描述的太学术。其实这句话通俗的来说就是：JavaScript中所有的function都是一个闭包。不过一般来说，嵌套的function所产生的闭包更为强大，也是大部分时候我们所谓的“闭包”。看下面这段代码： 1234567function a() &#123; var i = 0; function b() &#123; alert(++i); &#125; return b;&#125;var c = a();c(); 这段代码有两个特点： 1、函数b嵌套在函数a内部； 2、函数a返回函数b。 引用关系如图： 这样在执行完var c=a()后，变量c实际上是指向了函数b，再执行c()后就会弹出一个窗口显示i的值(第一次为1)。这段代码其实就创建了一个闭包，为什么？因为函数a外的变量c引用了函数a内的函数b，就是说： 当函数a的内部函数b被函数a外的一个变量引用的时候，就创建了一个闭包。 让我们说的更透彻一些。所谓“闭包”，就是在构造函数体内定义另外的函数作为目标对象的方法函数，而这个对象的方法函数反过来引用外层函数体中的临时变量。这使得只要目标 对象在生存期内始终能保持其方法，就能间接保持原构造函数体当时用到的临时变量值。尽管最开始的构造函数调用已经结束，临时变量的名称也都消失了，但在目 标对象的方法内却始终能引用到该变量的值，而且该值只能通这种方法来访问。即使再次调用相同的构造函数，但只会生成新对象和方法，新的临时变量只是对应新 的值，和上次那次调用的是各自独立的。 八、闭包有什么作用？ 简而言之，闭包的作用就是在a执行完并返回后，闭包使得Javascript的垃圾回收机制GC不会收回a所占用的资源，因为a的内部函数b的执行需要依赖a中的变量。这是对闭包作用的非常直白的描述，不专业也不严谨，但大概意思就是这样，理解闭包需要循序渐进的过程。 在上面的例子中，由于闭包的存在使得函数a返回后，a中的i始终存在，这样每次执行c()，i都是自加1后alert出i的值。 那 么我们来想象另一种情况，如果a返回的不是函数b，情况就完全不同了。因为a执行完后，b没有被返回给a的外界，只是被a所引用，而此时a也只会被b引 用，因此函数a和b互相引用但又不被外界打扰(被外界引用)，函数a和b就会被GC回收。(关于Javascript的垃圾回收机制将在后面详细介绍) 九、闭包内的微观世界 如果要更加深入的了解闭包以及函数a和嵌套函数b的关系，我们需要引入另外几个概念：函数的执行环境(excution context)、活动对象(call object)、作用域(scope)、作用域链(scope chain)。以函数a从定义到执行的过程为例阐述这几个概念。 当定义函数a的时候，js解释器会将函数a的作用域链(scope chain)设置为定义a时a所在的“环境”，如果a是一个全局函数，则scope chain中只有window对象。 当执行函数a的时候，a会进入相应的执行环境(excution context)。 在创建执行环境的过程中，首先会为a添加一个scope属性，即a的作用域，其值就为第1步中的scope chain。即a.scope=a的作用域链。 然后执行环境会创建一个活动对象(call object)。活动对象也是一个拥有属性的对象，但它不具有原型而且不能通过JavaScript代码直接访问。创建完活动对象后，把活动对象添加到a的作用域链的最顶端。此时a的作用域链包含了两个对象：a的活动对象和window对象。 下一步是在活动对象上添加一个arguments属性，它保存着调用函数a时所传递的参数。 最后把所有函数a的形参和内部的函数b的引用也添加到a的活动对象上。在这一步中，完成了函数b的的定义，因此如同第3步，函数b的作用域链被设置为b所被定义的环境，即a的作用域。 到此，整个函数a从定义到执行的步骤就完成了。此时a返回函数b的引用给c，又函数b的作用域链包含了对函数a的活动对象的引用，也就是说b可以访问到a中定义的所有变量和函数。函数b被c引用，函数b又依赖函数a，因此函数a在返回后不会被GC回收。 当函数b执行的时候亦会像以上步骤一样。因此，执行时b的作用域链包含了3个对象：b的活动对象、a的活动对象和window对象，如下图所示： 如图所示，当在函数b中访问一个变量的时候，搜索顺序是： 先搜索自身的活动对象，如果存在则返回，如果不存在将继续搜索函数a的活动对象，依次查找，直到找到为止。 如果函数b存在prototype原型对象，则在查找完自身的活动对象后先查找自身的原型对象，再继续查找。这就是Javascript中的变量查找机制。 如果整个作用域链上都无法找到，则返回undefined。 小结，本段中提到了两个重要的词语：函数的定义与执行。文中提到函数的作用域是在定义函数时候就已经确定，而不是在执行的时候确定（参看步骤1和3）。用一段代码来说明这个问题： 123456function f(x) &#123; var g = function () &#123; return x; &#125; return g;&#125;var h = f(1);alert(h()); 这段代码中变量h指向了f中的那个匿名函数(由g返回)。 假设函数h的作用域是在执行alert(h())确定的，那么此时h的作用域链是：h的活动对象-&gt;alert的活动对象-&gt;window对象。 假设函数h的作用域是在定义时确定的，就是说h指向的那个匿名函数在定义的时候就已经确定了作用域。那么在执行的时候，h的作用域链为：h的活动对象-&gt;f的活动对象-&gt;window对象。 如果第一种假设成立，那输出值就是undefined；如果第二种假设成立，输出值则为1。 运行结果证明了第2个假设是正确的，说明函数的作用域确实是在定义这个函数的时候就已经确定了。 十、闭包的应用场景保护函数内的变量安全。以最开始的例子为例，函数a中i只有函数b才能访问，而无法通过其他途径访问到，因此保护了i的安全性。 在内存中维持一个变量。依然如前例，由于闭包，函数a中i的一直存在于内存中，因此每次执行c()，都会给i自加1。 通过保护变量的安全实现JS私有属性和私有方法（不能被外部访问） ​ 私有属性和方法在Constructor外是无法被访问的 12345678function Constructor(...) &#123; var that = this; var membername = value; function membername(...) &#123;...&#125;&#125; 以上3点是闭包最基本的应用场景，很多经典案例都源于此。 十一、Javascript的垃圾回收机制在Javascript中，如果一个对象不再被引用，那么这个对象就会被GC回收。如果两个对象互相引用，而不再被第3者所引用，那么这两个互相引用的对象也会被回收。因为函数a被b引用，b又被a外的c引用，这就是为什么函数a执行后不会被回收的原因。 十二、结语理解JavaScript的闭包是迈向高级JS程序员的必经之路，理解了其解释和运行机制才能写出更为安全和优雅的代码。]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>闭包</tag>
        <tag>funtion</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[将应用程序部署到Heroku]]></title>
    <url>%2F2017%2F07%2F22%2F%E5%B0%86%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E9%83%A8%E7%BD%B2%E5%88%B0Heroku%2F</url>
    <content type="text"><![CDATA[1.注册1.1在http://api/heroku.com/signup注册Hero帐号 1.2访问邮件中的链接并输入密码 1.3从 http://devcenter.heroku.com/articles/quickstart#step_2_install_the_heroku_toolbelt 为你的平台安装安装程序。 1.4打开终端窗口并登陆到Heroku 1heroku login 2.配置12345678910111213141516171.在app.js文件的顶部，添加如下行：var port = (process.env.PORT || 3000);2.将下列行从app.js中移除:app.listen(3000);3.用下列行替换它：app.listen(port);4.在应用程序的根目录中，添加一个名为Procfile的文件并加入如下内容：web: node app.js5.用如下命令安装依赖模块：npm install6.启动应用程序并检查其是否运行正常：node app.js 3.将应用程序提交到heroku1234567891011123.1使用如下命令创建Git库：git initgit add .git commit -m &quot;initial commit&quot;3.2使用如下命令在Heroku上创建应用程序。注意从这一命令返回的URL:heroku create --stack cedar3.3用如下命令将站点发布到Heroku：git push heroku master3.4访问之前得到的URL，可看到所部署的网站了！]]></content>
      <categories>
        <category>node.js</category>
      </categories>
      <tags>
        <tag>node.js</tag>
        <tag>Heroku</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Oracle学习笔记(六)]]></title>
    <url>%2F2017%2F07%2F20%2FOracle%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%85%AD%2F</url>
    <content type="text"><![CDATA[46.异常(1)12345678910111213141516171819declare v_temp number(4); begin select empno into v_temp from emp where deptno = 10; exception when too_many_rows then dbms_output.put_line('太多记录了'); when others then dbms_output.put_line('error'); end; (2)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475 declare v_tempnumber(4); begin select empno into v_temp from emp where empno = 2222; exception when no_data_found then dbms_output.put_line('没有该项数据'); end;----------------错误记录日志(用表记录：将系统日志存到数据库便于以后查看) ----------- 创建序列（用来处理递增的ＩＤ）： create sequence seq_errorlog_id start with 1 increment by 1; 创建日志表: create table errorlog ( id number primary key, errcode number, errmsg varchar2(1024), errdate date ); 示例程序： declare v_deptno dept.deptno%type := 10; v_errcode number; v_errmsg varchar2(1024); begin delete from dept where deptno = v_deptno; commit; exception when others then rollback; v_errcode:= SQLCODE; v_errmsg:= SQLERRM; insert into errorlog values (seq_errorlog_id.nextval, v_errcode,v_errmsg, sysdate); commit; end; 47. PL/SQL中的重点cursor(游标)和指针的概念差不多123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293declare cursorc isselect * from emp; //此处的语句不会立刻执行，而是当下面的open c的时候，才会真正去数据库中取数据 v_emp c%rowtype; begin open c; fetch c into v_emp;dbms_output.put_line(v_emp.ename); //这样会只输出一条数据 134将使用循环的方法输出每一条记录 close c; end;----------------------使用do while 循环遍历游标中的每一个数据--------------------- declare cursor c is select* from emp; v_emp c%rowtype; begin open c; loop fetch c into v_emp;(1) exit when(c%notfound); //notfound是oracle中的关键字，作用是判断是否还有下一条数据(2) dbms_output.put_line(v_emp.ename); //(1)(2)的顺序不能颠倒，否则会把最后一条结果再多打印一次。 end loop; close c; end;------------------------使用while循环，遍历游标--------------------- declare cursor c is select* from emp; v_emp emp%rowtype; begin open c; fetch c into v_emp; while(c%found) loop dbms_output.put_line(v_emp.ename); fetch c into v_emp; end loop; close c; end;s------------------------使用for 循环，遍历游标（最方便快捷的方法！）----------------- declare cursorc is select * from emp; begin for v_emp in c loop dbms_output.put_line(v_emp.ename); endloop; end; 带参数的游标（相当于函数）1234567891011121314151617declare cursor c(v_deptno emp.deptno%type, v_job emp.job%type) is select ename, sal from emp where deptno=v_deptno and job=v_job; begin forv_temp in c(30, 'CLERK') loop dbms_output.put_line(v_temp.ename); endloop;end; 可更新的游标123456789101112131415161718192021222324252627declare cursorc is select * from emp2 for update; begin for v_temp in c loop if(v_temp.sal&lt; 2000) then update emp2 set sal = sal * 2 where current of c; elsif (v_temp.sal =5000) then deletefrom emp2 where current of c; end if; end loop; commit; end; 48. store procedure存储过程(带有名字的程序块)12345678910111213141516171819202122232425262728293031323334353637383940414243createor replace procedure p is--除了这两句替代declare，下面的语句全部都一样 cursor c is select * from emp2 for update; begin for v_emp in c loop if(v_emp.deptno= 10) then updateemp2 set sal = sal +10 where current of c; elseif(v_emp.deptno =20) then updateemp2 set sal = sal + 20 where current ofc; else updateemp2 set sal = sal + 50 where current of c; endif; end loop; commit; end; 执行存储过程的两种方法： （1）exec p;(p是存储过程的名称) （2）begin p; end; / 带参数的存储过程先创建存储过程：（in标识传入参数，out标识传出参数，默认为传入参数） 12345678910111213141516171819202122232425262728293031323334353637383940414243 createor replace procedure p (v_ain number, v_b number, v_ret out number, v_temp inout number) is begin if(v_a&gt; v_b) then v_ret:= v_a; else v_ret:= v_b; endif; v_temp:= v_temp + 1; end;再调用： declare v_a number := 3; v_b number := 4; v_retnumber; v_tempnumber := 5; begin p(v_a,v_b, v_ret, v_temp); dbms_output.put_line(v_ret); dbms_output.put_line(v_temp); end; 删除存储过程​ dropprocedure p; 49. 创建函数计算个人所得税的税率12345678910111213141516171819202122232425createor replace function sal_tax (v_sal number) returnnumber is begin if(v_sal&lt; 2000) then return0.10; elsif(v_sal&lt;2750) then return0.15; else return0.20; endif; end; 50. 创建触发器（trigger）触发器不能单独的存在，必须依附在某一张表上 写主语 谓语 宾语 游戏 ​ 创建触发器的依附表： 1234567891011121314151617181920212223242526272829303132 createtable emp2_log ( enamevarchar2(30) , eactionvarchar2(20), etimedate ); create or replace trigger trigafter insert or delete orupdate on emp2 for each row --加上此句，每更新一行，触发一次，不加入则值触发一次 begin ifinserting then insertinto emp2_log values(USER, 'insert', sysdate); elsifupdating then insertinto emp2_log values(USER, 'update', sysdate); elsifdeleting then insertinto emp2_log values(USER, 'delete', sysdate); endif; end; 51.触发器用法之一：通过触发器更新约束的相关数据12345678910111213createor replace trigger trig afterupdate on dept foreach row begin updateemp set deptno =:NEW.deptno where deptno =: OLD.deptno; end; --只编译不显示的解决办法 set serveroutput on; 52.通过创建存储过程完成递归123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263 createor replace procedure p(v_pid article.pid%type,v_level binary_integer) is cursorc is select * from article where pid = v_pid; v_preStrvarchar2(1024) := ''; begin for i in 0..v_leave loop v_preStr:= v_preStr || ''; end loop; for v_article in c loop dbms_output.put_line(v_article.cont); if(v_article.isleaf= 0) then p(v_article.id); endif; endloop; end;-------------------------------查看当前用户下有哪些表--- 首先，用这个用户登录然后使用语句： select* from tab; -----------------------------用Oracle进行分页！-------------- 因为Oracle中的隐含字段rownum不支持'&gt;'所以： select* from ( selectrownum rn, t.* from ( select* from t_user where user_id &lt;&gt; 'root' )t where rownum &lt;6 )where rn &gt;3------------------------Oracle下面的清屏命令---------------- clearscreen; 或者 cle scr; -----------将创建好的guohailong的这个用户的密码改为abc-------------- alter user guohailong identified by abc --当密码使用的是数字的时候可能会不行]]></content>
      <categories>
        <category>Oracle</category>
      </categories>
      <tags>
        <tag>Oracle sql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Oracle学习笔记(五)]]></title>
    <url>%2F2017%2F07%2F19%2FOracle%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BA%94%2F</url>
    <content type="text"><![CDATA[PL_SQL(过程化SQL语言)38. 在客户端输出helloworld12345678910111213141516171819202122232425 set serveroutput on;//默认是off，设成on是让Oracle可以在客户端输出数据 begin dbms_output.put_line('helloworld'); end; /----------------pl/sql变量的赋值与输出---- declare v_name varchar2(20);//声明变量v_name变量的声明以v_开头 begin v_name:= 'myname'; dbms_output.put_line(v_name); end; / 39. pl/sql对于异常的处理(除数为0)12345678910111213141516171819 declare v_num number := 0; begin v_num:= 2/v_num; dbms_output.put_line(v_num);** exception**** when others then**** dbms_output.put_line('error');** end; / 40. 变量的声明​ binary_integer:整数，主要用来计数而不是用来表示字段类型 比number效率高 ​ number:数字类型 ​ char:定长字符串 ​ varchar2：变长字符串 ​ date：日期 ​ long：字符串，最长2GB ​ boolean：布尔类型，可以取值true，false，null//最好给一初值 12345678910111213141516171819----------变量的声明，使用 '%type'属性--------- declare v_empno number(4); v_empno2 emp.empno%type; v_empno3 v_empno2%type; begin dbms_output.put_line('Test'); end; / --使用%type属性，可以使变量的声明根据表字段的类型自动变换，省去了维护的麻烦，而且%type属性，可以用于变量身上 41.组合变量1234567891011121314151617---------------Table变量类型(相当于java里面的数组)-------------------- declare type type_table_emp_empno is table of emp.empno%type index by binary_integer; v_empnostype_table type_table_empno; begin v_empnos(0):= 7345; v_empnos(-1):=9999; dbms_output.put_line(v_empnos(-1)); end; 42. Record变量类型（相当于Java里面的类）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647 declare type type_record_dept is record ( deptno dept.deptno%type, dname dept.dname%type, loc dept.loc%type ); v_temp type_record_dept; begin v_temp.deptno:=50; v_temp.dname:='aaaa'; v_temp.loc:='bj'; dbms_output.put_line(v_temp.deptno|| ' ' || v_temp.dname); end; -----------使用 %rowtype声明record变量，直接参照表来声明record------------------- declare v_temp dept%rowtype; begin v_temp.deptno:=50; v_temp.dname:='aaaa'; v_temp.loc:='bj'; dbms_output.put_line(vtemp.deptno || '' || v temp.dname) end; ​ 43. select语句的运用(必须保证select语句有相应的返回记录)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667 declare v_ename emp.ename%type; v_sal emp.sal%type; begin select ename,sal into v_ename,v_sal from emp where empno = 7369; dbms_output.put_line(v_ename|| '' || v_sal); end;-------------------------select语句的应用（record）------------------------------ declare v_emp emp%rowtype; begin select * into v_emp from emp where empno=7369; dbms_output_line(v_emp.ename); end; ------------- insert语句的应用 ----------------------------- declare v_deptno dept.deptno%type := 50; v_dname dept.dname%type :='aaa'; v_loc dept.loc%type := 'bj'; begin insert into dept2 values(v_deptno,v_dname,v_loc); commit; end; -------------update 语句的应用------------------------------ declare v_deptno emp2.deptno%type := 50; v_count number; begin update emp2 set sal = sal/2 where deptno =v_deptno; dbms_output.put_line(sql%rowcount || ‘条记录被影响’); commit; end; 注：sql%rowcount统计上一条sql语句更新的记录条数 44.ddl语言，数据定义语言12345678910111213141516171819202122232425262728293031 begin execute immediate 'create table T (nnn varchar(30) default ''a'')'; end;------------------ifelse语句-------------------------------------- declare v_sal emp.sal%type; begin select sal into v_sal from emp where empno = 7369; if(v_sal&lt; 2000) then dbms_output.put_line('low'); els if(v_sal &gt; 2000) then dbms_output.put_line('middle'); else dbms_output.put_line('height'); end if; end; 45. 循环do while 循环1234567891011121314151617declare i binary_integer := 1; begin loop dbms_output.put_line(i); i:= i + 1; exit when (i&gt;=11); end loop; end; while 循环123456789101112131415declare j binary_integer := 1; begin while j &lt; 11 loop dbms_output.put_line(j); j:=j+1; end loop; end; for 循环123456789101112131415begin for k in 1..10 loop dbms_output.put_line(k); end loop; for k in reverse 1..10 loop dbms_output.put_line(k); end loop; end;]]></content>
      <categories>
        <category>Oracle</category>
      </categories>
      <tags>
        <tag>Oracle sql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Oracle学习笔记(四)]]></title>
    <url>%2F2017%2F07%2F18%2FOracle%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9B%9B%2F</url>
    <content type="text"><![CDATA[24.——-创建新用户——–123456789101112131、backup scott//备份 exp//导出2、create user createuser guohailong identified(认证) by guohailong default table space users quota(配额) 10M on users grant create session(给它登录到服务器的权限),create table, create view to guohailong3、import data Imp 25. ——-取消操作——–123456789101112131415161718192021222324252627282930313233343536373839404142434445464748rollback-----------事务确认语句-------- commit;//此时再执行rollback无效当正常断开连接的时候例如exit,事务自动提交。 当非正常断开连接，例如直接关闭dos窗口或关机，事务自动提交 -----表的备份 create table dept2 as select * from dept;-----插入数据 insert into dept2 values(50,'game','beijing'); ----只对某个字段插入数据 insert into dept2(deptno,dname) values(60,'game2');-----将一个表中的数据完全插入另一个表中（表结构必须一样） insert into dept2 select * from dept;-----求前五名员工的编号和名称（使用伪字段rownum 只能使用 &lt; 或 = 要使用 &gt; 必须使用子查询） select empno,ename from emp where rownum &lt;= 5;----求10名雇员以后的雇员名称-------- select ename from (select rownum r,ename from emp) where r &gt; 10;----求薪水最高的前5个人的薪水和名字--------- select ename, sal from (select ename, sal from emp order by sal desc) where rownum&lt;=5; ----求按薪水倒序排列后的第6名到第10名的员工的名字和薪水-------- selectename, sal from (select ename, sal, rownum r from (select ename, sal from emp orderby sal desc) ) where r&gt;=6 and r&lt;=10 26. ——-面试题——–​ 有3个表S，C，SC ​ S（SNO，SNAME）代表（学号，姓名） ​ C（CNO，CNAME，CTEACHER）代表（课号，课名，教师） ​ SC（SNO，CNO，SCGRADE）代表（学号，课号成绩） ​ 问题： ​ 1，找出没选过“黎明”老师的所有学生姓名。 ​ 2，列出2门以上（含2门）不及格学生姓名及平均成绩。 ​ 3，即学过1号课程有学过2号课所有学生的姓名。 ​ 答案： 1234567891011121、 select sname from s join sc on(s.sno =sc.sno) join c on (sc.cno = c.cno) where cteacher &lt;&gt; '黎明';2、 select sname where sno in (select sno from sc where scgrade &lt; 60 group by sno having count(*) &gt;=2);3、 select sname from s where sno in (select sno, from sc where cno=1 and cno in (select distinct sno from sc where cno = 2); ) 27. ——–创建表———–123456789101112131415161718192021create table stu(id number(6),name varchar2(20) constraint stu_name_mmnot null,sex number(1),age number(3),sdate date,grade number(2) default 1,class number(4),email varchar2(50) unique ); 28. 五种约束条件：非空约束、唯一约束、主键约束、外键约束、检查约束（check）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273--------------给name字段加入 非空 **约束**，并给约束一个名字，若不取，系统默认取一个------------- create table stu ( id number(6), name varchar2(20) constraint stu_name_mm not null, sex number(1), age number(3), sdate date, grade number(2) default 1, class number(4), email varchar2(50) );--------------给nameemail字段加上唯一约束两个 null值 不为重复------------- create table stu ( id number(6), name varchar2(20) constraint stu_name_mmnot null, sex number(1), age number(3), sdate date, grade number(2) default 1, class number(4), email varchar2(50) unique );--------------两个字段的组合不能重复 约束：表级约束------------- create table stu ( id number(6), name varchar2(20) constraint stu_name_mmnot null, sex number(1), age number(3), sdate date, grade number(2) default 1, class number(4), email varchar2(50)， constraint stu_name_email_uni unique(email,name) ); 29. ——-主键约束——–​ 12345678910111213141516171819202122232425create table stu ( id number(6), name varchar2(20) constraint stu_name_mmnot null, sex number(1), age number(3), sdate date, grade number(2) default 1, class number(4), email varchar2(50), constraint stu_id_pk primary key (id), constraintstu_name_email_uni unique(email, name) ); 30.—外键约束 被参考字段必须是主键—123456789101112131415161718192021222324252627282930313233343536373839create table stu(id number(6),name varchar2(20) constraint stu_name_mmnot null,sex number(1),age number(3),sdate date,grade number(2) default 1,class number(4) references class(id),email varchar2(50), constraint stu_class_fk foreign key (class) references class(id), constraint stu_id_pk primary key (id), constraint stu_name_email_uni unique(email, name) ); 红色为字段约束的写法，蓝色为表级约束的写法 createtable class ( idnumber(4) primary key, namevarchar2(20) not null ); 31. 修改表结构12345678910111213141516171819---------------添加字段-------------------------- altertable stu add(addr varchar2(29));---------------删除字段-------------------------- altertable stu drop (addr);---------------修改表字段的长度------------------ altertable stu modify (addr varchar2(50));//更改后的长度必须要能容纳原先的数据----------------删除约束条件---------------- altertable stu drop constraint 约束名-----------修改表结构添加约束条件--------------- altertable stu add constraint stu_class_fk foreign key (class) references class(id); 32. 数据字典表（有user_tables、user_views、user_constraints等等）12345678910111213141516---------------查看当前用户下面所有的表、视图、约束-----数据字典表user_tables--- select table_name from user_tables; select view_name from user_views; select constraint_name from user_constraints; 存储数据字典表的信息的表：dictionary; //该表共有两个字段 table_name comments //table_name主要存放数据字典表的名字 //comments主要是对这张数据字典表的描述 ​ 33. 索引(能优化查询效率)12345678910111213create index idx_stu_email on stu (email);// 在stu这张表的email字段上建立一个索引：idx_stu_email---------- 删除索引 ------------------ drop index index_stu_email;---------查看所有的索引---------------- select index_name from user_indexes;---------创建视图------------------- create view v$stu as select id,name,age from stu; ​ 视图的作用: 简化查询，保护我们的一些隐私数据，通过视图也可以用来更新数据，但是我们一般不这么用 缺点：要对视图进行维护 34.创建序列（sequence，oracle特有的东西，一般用来做主键）​ 12345678910111213create sequence seq;//创建序列 select seq.nextval from dual;// 查看seq序列的下一个值 drop sequence seq;//删除序列 create table article ( id number, title varchar2(1024),cont long); create sequence seq; insert into article (id,title,cont) values(seq.nextval , ‘a’, ‘b’); 35. 数据库的三范式​ （1）要有主键，列不可分 ​ （2）不能存在部分依赖：当有多个字段联合起来作为主键的时候，不是主键的字段不能部分依赖于主键中的某个字段 ​ （3）不能存在传递依赖]]></content>
      <categories>
        <category>Oracle</category>
      </categories>
      <tags>
        <tag>Oracle sql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Oracle学习笔记(三)]]></title>
    <url>%2F2017%2F07%2F18%2FOracle%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%89%2F</url>
    <content type="text"><![CDATA[12. SQL1999_table_connections123select ename, dname,grade from emp e,deptd, salgrade swhere e.deptno = d.deptno and e.sal between s.losal and s.hisal and job &lt;&gt; 'CLERK' ​ 有没有办法把过滤条件和连接条件分开来? 出于这样考虑,Sql1999标准推出来了.有许多人用的还是 旧的语法,所以得看懂这种语句. 1234567891011select ename,dname from emp,dept;(旧标准).select ename,dname from emp** cross join** dept;(1999标准)select ename,dname from emp,dept where emp.deptno=dept.deptno (旧)select ename,dname from emp join dept on(emp.deptno = dept.deptno); 1999标准.没有Where语句.select ename,dname from emp join dept using(deptno);等同上句,但不推荐使用.select ename,grade from emp e join salgrade s on(e.sal between s.losal and s.hisal); ​ join 连接语句, on过滤条件。连接，条件一眼分开。如果用Where语句较长时，连接语句和过滤语句混在一起。​ 三张表连接： 1234567slect ename, dname, grade fromemp e join dept d on(e.deptno=d.deptno)join salgrade s on(e.sal between s.losal and s.hisal)where ename not like '_A%'; ​ 把每张表连接 条件不混在一起，然后数据过滤条件全部区分开来。读起来更清晰，更容易懂一点。 123 select e1.ename,e2.ename from emp e1 join emp e2on(e1.mgr = e2.emptno); ​ 左外连接：会把左边这张表多余数据显示出来。 123 select e1.ename,e2.ename from emp e1 left joinemp e2 on(e1.mgr =e2.empno);left 后可加outer ​ 右外连接：把右边这张表多余数据显示出来。 123 select ename,dname from emp e right outer join dept don(e.deptno =d.deptno); outer可以取掉。 ​ 全外连接： 即把左边多余数据，也把右边多余数据拿出来， 123 select ename,dname from emp e full join dept don(e.deptno =d.deptno); PS：所谓的“外”连接，即把多余的数据显示出来。Outer关键字可以省略。 13. 求部门中哪些人的薪水最高123select ename, sal from empjoin (select max(sal) max_sal, deptno from emp group by deptno) ton (emp.sal = t.max_sal and emp.deptno = t.deptno) 14. 求部门平均薪水的等级123select deptno,avg_sal,grade from (select deptno,avg(sal) avg_sal from emp group by deptno)t join salgrade s on(t.avg_sal between s.losal and s.hisal) 15. 求部门平均的薪水的平均等级123select deptno,avg(grade) from (select deptno,ename, grade from emp join salgrade s on(emp.sal between s.losal and s.hisal)) tgroup by deptno 16. 哪些人是经理12select ename from emp where empno in(select mgr from emp);select ename from emp where empno in(select distinct mgr from emp); 17.不准用组函数，求薪水的最高值（面试题）12select distinct sal from emp where sal not in(select distinct e1.sal from emp e1 join emp e2 on (e1.sal&lt;e2.sal)); 18.平均薪水最高的部门编号123456select deptno,avg_sal from(select avg(sal)avg_sal,deptno from emp group by deptno)where avg_sal=(select max(avg_sal)from (select avg(sal) avg_sal,deptno from emp group by deptno)) 19.平均薪水最高的部门名称123456789 select dname from dept where deptno=( select deptno from (select avg(sal)avg_sal,deptno from emp group by deptno) where avg_sal= (select max(avg_sal)from (select avg(sal) avg_sal,deptno from emp group by deptno) ) ) 20.求平均薪水的等级最低的部门的部门名称12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455 --组函数嵌套 --如：平均薪水最高的部门编号，可以E.更简单的方法如下： select deptno,avg_sal from (select avg(sal) avg_sal,deptno from emp group by deptno) where avg_sal = (select max(avg(sal)) from emp group by deptno) 组函数最多嵌套两层 -- 分析： -- 首先求 --1.平均薪水： select avg(sal) from emp group by deptno; -- 2.平均薪水等级： 把平均薪水当做一张表，需要和另外一张表连接salgrade select deptno,grade,avg_sal from ( select deptno,avg(sal) avg_sal from emp group by deptno) t join salgrade s on(t.avg_sal between s.losal and s.hisal) -- 上面结果又可当成一张表。 -- DEPTNO GRADE AVG_SAL -------- ------- ---------- -- 30 3 1566.66667 -- 20 4 2175 -- 10 4 2916.66667 -- 3.求上表平均等级最低值 select min(grade) from ( select deptno,grade,avg_sal from (select deptno,avg(sal) avg_sal from emp group by deptno)t join salgrade s on(t.avg_sal between s.losal and s.hisa) ) -- 4.把最低值对应的2结果的那张表的对应那张表的deptno, 然后把2对应的表和另外一张表做连接。 select dname ,deptno,grade,avg_sal from ( select deptno,grade,avg_sal from (select deptno,avg(sal) avg_sal from emp group by deptno)t join salgrade s on(t.avg_sal between s.losal and s.hisal) ) t1 join dept on (t1.deptno = dept.deptno) where t1.grade = ( select deptno,grade,avg_sal from (select deptno,avg(sal) avg_sal from emp group by deptno) t join salgrade s on(t.avg_sal between s.losal and s.hisal) ) )-- 结果如下： -- DNAME DEPTNO GRADE AVG_SAL-- -------- ------- -------- ---------- SALES 30 3 1566.6667 21. 视图（视图就是一张表，一个字查询）【 ​ 默认scott账户没有创建视图的权限，可通过如下语句授权：​ 首先登陆超级管理员：conn sys/用户密码 as sysdba;​ 授权：grant create table,create view to scott;​ 再以scott账户登陆：conn scott/tiger 】 12345678910111213141516171819202122232425262728-- 20中语句有重复，可以用视图来简化。 conn sys/bjsxt as sysdba; grant create table,create view to scott; conn scott/tiger-- 创建视图： create view v$_dept_avg-sal_info as select deptno,grade,avg_sal from ( select deptno,avg(sal) avg_sal from emp group by deptno)t join salgrade s on 9t.avg_sal between s.losal and s.hisal) -- 然后 select * from v$_dept_avg-sal_info -- 结果如下：-- DEPTNO GRADE AVG_SAL-- -------- ------- ------------ 30 3 1566.66667-- 20 4 2175-- 10 4 2916.66667-- 然后G中查询可以简化成： select dname,t1.deptno,grade,avg_sal from v$_dept_avg-sal_info t1 join dept on t1.deptno =dept.deptno) where t1.grade= ( select min(grade) from v$_dept_avg-sal_info t1 ) 22. 求比普通员工最高薪水还要高的经理人的名称1234567select ename, sal from emp where empno in (select distinct mgr from emp where mgr is not null) and sal &gt; ( select max(sal) from emp where empno not in (select distinct mgr from emp where mgr is not null) ) 23. 面试题：比较效率理论上前一句效率高，但实际上可能Oracle可能会自动对代码优化，所以不见得后一句就会慢。 12select * from emp where deptno = 10 and ename like '%A%'; --效率高，因为将过滤力度大的放在前面select * from emp where ename like '%A% and deptno = 10;]]></content>
      <categories>
        <category>Oracle</category>
      </categories>
      <tags>
        <tag>Oracle sql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Oracle学习笔记(二)]]></title>
    <url>%2F2017%2F07%2F17%2FOracle%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[8. Group by语句//需求:现在想求每个部门的平均薪水. 12345678910111213 select avg(sal) from emp group by deptno; select deptno avg(sal) from emp group by deptno; select deptno,job,max(sal) from emp group by deptno,job; 求薪水值最高的人的名字.select ename,max(sal) from emp;出错,因为max只有一个值,但等于max值的人可能好几个,不能匹配.应如下求:select ename from emp where sal=(select max(sal) from emp);Group by语句应注意,出现在select中的字段,如果没出现在组函数中,必须出现在Group by语句中. 9. Having 对分组结果筛选1Where是对单条纪录进行筛选,Having是对分组结果进行筛选. 12345678910select avg(sal),deptno from emp group by deptno having avg(sal)&gt;2000;查询工资大于1200雇员,按部门编号进行分组,分组后平均薪水大于1500,按工薪倒充排列.select * from emp where sal&gt;1200group by deptnohaving avg(sal)&gt;1500order by avg(sal) desc; 10. 字查询​ 谁挣的钱最多(谁:这个人的名字, 钱最多) 1select 语句中嵌套select 语句,可以在where,from后. ​ 问哪些人工资,在平均工资之上. 1select ename,sal from emp where sal&gt;(select avg(sal) from emp); 1234567891011//查找每个部门挣钱最多的那个人的名字.select ename ,deptno from emp where sal in(select max(sal) from ename group by deptno) //查询会多值.//应该如下:select max(sal),deptno from emp group by deptno;//当成一个表.语句如下:select ename, sal from emp join(select max(sal) max_sal,deptno from emp groupby deptno) t on(emp.sal=t.max_sal and emp.deptno=t.deptno); //每个部门的平均薪水的等级. //分析:首先求平均薪水(当成表),把平均薪水和另外一张表连接. 11. self_table_connection把某个人的名字以及他的经理人的名字求出来(经理人及这个人在表中同处一行) 分析:首先求出这个人的名字,取他的编号,然后从另一张表与其相对应编号,然后找到经理的名字. 1select e1.ename ,e2.ename from emp e1,emp e2 where e1.mgr= e2.empno. //empno编号和MGR都是编号.]]></content>
      <categories>
        <category>Oracle</category>
      </categories>
      <tags>
        <tag>Oracle</tag>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Oracle学习笔记(一)]]></title>
    <url>%2F2017%2F07%2F16%2FOracle%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%80%2F</url>
    <content type="text"><![CDATA[前言12sqlplus sys/所设定的密码 as sysdba(用管理员登陆)alter user scott account unlock;(解锁scott账户) 1. table structure12描述某一张表：desc 表名select * from 表名 2. select 语句1计算数据可以用空表：比如：select 2*3 from dual 1select ename,sal*12 annual_sal from emp;与select ename,sal*12 "annual sal" from emp;区别，加双引号保持原大小写。不加全变大写。 1select ename || "abcd" 如果连接字符串中含有单引号，用两个单引号代替一个单引号。(||代表连接符) 3. distinct123456select deptno from emp;select distinct deptno from emp;select distinct deptno from emp;select distinct deptno ,job from emp去掉deptno,job两者组合的重复。更多的项，就是这么多项的组合的不重复组合。 4. where12345678select * from emp where deptno =10;select * from emp where deptno &lt;&gt;10;不等于10 select * from emp where ename ='bike';select ename,sal from emp where sal between 800 and 1500 (&gt;=800 and &lt;=1500)空值处理:select ename,sal,comm from emp where comm is (not) null;select ename,sal,comm from emp where ename ( not)in ('smith','king','abc');select ename from emp where ename like '_A%';_代表一个字母,%代表0个或多个字母. 如果查询%可用转义字符.\%. 还可以用escape '$'比如:select ename from emp where ename like '%$a%' escape '$'; 5. orderby123select * from dept; select * from dept order by dept desc;(默认:asc)select ename,sal,deptno from emp order by deptno asc,ename desc; 6. sql function11234567891011121314151617181920212223242526272829303132333435363738394041select ename,sal*12 annual_sal from empwhere ename not like '_A%' and sal&gt;800order by sal desc;select lower(ename) from emp;select ename from emp where lower(ename) like '_a%';等同于select ename from emp where ename like '_a%' or ename like '_A%';select substr(ename,2,3) from emp;从第二字符截,一共截三个字符.select chr(65) from dual 结果为:Aselect ascii('a') from dual 结果为:65select round(23.652,1) from dual; 结果为: 23.7select round(23.652,-1) from dual; 20 select to_char(sal,'$99_999_999') from emp;select to_char(sal,'L99_999_999') from emp;人民币符号,L:代表本地符号这个需要掌握牢:select birthdate from emp;显示为:BIRTHDATE----------------17-12月-80----------------改为:select to_char(birthdate,'YYYY-MM-DD HH:MI:SS') from emp;显示: BIRTHDATE-------------------1980-12-17 12:00:00-------------------select to_char(sysdate,'YYYY-MM-DD HH24:MI:SS') from dual; //也可以改为:HH12TO_CHAR(SYSDATE,'YY-------------------2017-07-15 14:46:14 123to_date函数:select ename,birthdate from emp where birthdate &gt; to_date('1981-2-20 12:34:56','YYYY-MM-DD HH24:MI:SS');如果直接写 birthdate&gt;'1981-2-20 12:34:56'会出现格式不匹配,因为表中的格式为: DD-MM月-YY. 123456789select sal from emp where sal&gt;888.88 无错.但select sal from emp where sal&gt;$1,250,00;会出现无效字符错误. 改为:select sal from emp where sal&gt;to_number('$1,250.00','$9,999.99');s把空值改为0select ename,sal*12+nvl(comm,0) from emp;这样可以防止comm为空时,sal*12相加也为空的情况. 7. Group function 组函数1max,min,avg ,count,sum函数 1select to_char(avg(sal),'99999999,99') from emp; 1234567select round(avg(sal),2) from emp;结果:2073.21 select count(*) from emp where deptno=10;select count(ename) from emp where deptno=10; count某个字段,如果这个字段不为空就算一个.select count(distinct deptno) from emp;select sum(sal) from emp;]]></content>
      <categories>
        <category>Oracle</category>
      </categories>
      <tags>
        <tag>Oracle sql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java读书笔记-Thread类]]></title>
    <url>%2F2017%2F07%2F14%2Fjava%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-Thread%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[一、线程的三个常用方法 二、线程死锁图解 Thread1锁住了上面的对象，等待锁住下面的对象来完成执行过程。但是下面的对象被Thread2锁住了，它也等着锁住上面的对象来完成执行，因此陷入了死锁。 三、死锁小程序12345678910111213141516171819202122232425262728293031323334353637383940414243public class TestDeadLock implements Runnable &#123; public int flag = 1; static Object o1 = new Object(), o2 = new Object(); public void run() &#123; System.out.println("flag=" + flag); if(flag == 1) &#123; synchronized(o1) &#123; try &#123; Thread.sleep(500); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; synchronized(o2) &#123; System.out.println("1"); &#125; &#125; &#125; if(flag == 0) &#123; synchronized(o2) &#123; try &#123; Thread.sleep(500); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; synchronized(o1) &#123; System.out.println("0"); &#125; &#125; &#125; &#125; public static void main(String[] args) &#123; TestDeadLock td1 = new TestDeadLock(); TestDeadLock td2 = new TestDeadLock(); td1.flag = 1; td2.flag = 0; Thread t1 = new Thread(td1); Thread t2 = new Thread(td2); t1.start(); t2.start(); &#125;&#125; 四、面试题下面举个小例子： 1234567891011121314151617181920212223242526272829303132public class TT implements Runnable &#123; int b = 100; public synchronized void m1() throws Exception&#123; //Thread.sleep(2000); b = 1000; Thread.sleep(5000); System.out.println("b = " + b); &#125; public void m2() throws Exception &#123; Thread.sleep(2500); b = 2000; &#125; public void run() &#123; try &#123; m1(); &#125; catch(Exception e) &#123; e.printStackTrace(); &#125; &#125; public static void main(String[] args) throws Exception &#123; TT tt = new TT(); Thread t = new Thread(tt); t.start(); tt.m2(); System.out.println(tt.b); &#125;&#125; 上面的输出结果是：2000 五、wait()跟sleep()区别1)wait时别的线程可以访问锁定对象(调用wait方法的时候必须锁定该对象) 2)sleep时别的线程也不可以访问锁定对象 2)Thread.sleep()与Object.wait()二者都可以暂停当前线程，释放CPU控制权，主要的区别在于Object.wait()在释放CPU同时，释放了对象锁的控制，而在同步块中的Thread.sleep()方法并不释放锁，仅释放CPU控制权。 六、wait()跟notify()方法 1)wait()方法与notify()必须要与synchronized(resource)一起使用。(也就是wait与notify针对已经获取了resource锁的线程进行操作，从语法角度来说就是Obj.wait(),Obj.notify必须在synchronized(Obj){...}语句块内。) 2) wait和notify方法均可释放对象的锁，但wait同时释放CPU控制权，即它后面的代码停止执行，线程进入阻塞状态，而notify方法不立刻释放CPU控制权，而是在相应的synchronized(){}语句块执行结束，再自动释放锁。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>Thread</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java读书笔记-IO类-编程小问题]]></title>
    <url>%2F2017%2F07%2F13%2Fjava%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-IO%E7%B1%BB-%E7%BC%96%E7%A8%8B%E5%B0%8F%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最近在重新复习下java SE的内容，把一下小问题记录下来。 一、Java流式输入输出原理图 二、流的分类 三、节点流类型 总结以stream结尾的是字节流，以reader或writer结尾的是字符流。 一、字节流文件复制12345678910111213141516171819202122import java.io.*;public class TestFileOutputStream &#123; public static void main(String[] args) &#123; int b = 0; FileInputStream in = null; FileOutputStream out = null; try &#123; in = new FileInputStream("d:/share/java/HelloWorld.java"); out = new FileOutputStream("d:/share/java/io/HW.java"); while((b=in.read())!=-1)&#123; out.write(b); &#125; in.close(); out.close(); &#125; catch (FileNotFoundException e2) &#123; System.out.println("找不到指定文件"); System.exit(-1); &#125; catch (IOException e1) &#123; System.out.println("文件复制错误"); System.exit(-1); &#125; System.out.println("文件已复制"); &#125;&#125; 二、BufferedWriter和BufferedReader图解如果只是用FileWriter的话只能每次写入一个字符，而在外面再包装一层BufferedWriter的话一次可以写入一个缓冲区的内容。 三、OutputStreamWriter工作原理如果只是用FileWriter的话只能每次写入一个字节，而在外面再包装一层BufferedWriter的话一次可以写入一个字符串的内容。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>IO</tag>
        <tag>编程小问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java读书笔记-常用类-编程小问题]]></title>
    <url>%2F2017%2F07%2F11%2Fjava%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E5%B8%B8%E7%94%A8%E7%B1%BB-%E7%BC%96%E7%A8%8B%E5%B0%8F%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最近在重新复习下java SE中常用类的内容，把一下小问题记录下来。 一、用Java编写一个程序，输出一个字符串中的大写英文字母数，小写英文字母数以及非英文字母数。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import java.util.regex.*;public class TestString &#123; public static void main(String[] args) &#123; //方法一 //String s = "AaaaABBBBcc&amp;^%adfsfdCCOOkk99876 _haHA"; //int lCount = 0, uCount = 0, oCount = 0; /* for(int i=0; i&lt;s.length(); i++) &#123; char c = s.charAt(i); if(c &gt;= 'a' &amp;&amp; c &lt;= 'z') &#123; lCount ++; &#125; else if (c &gt;='A' &amp;&amp; c &lt;= 'Z') &#123; uCount ++; &#125; else &#123; oCount ++; &#125; &#125; */ //方法二 /* String sL = "abcdefghijklmnopqrstuvwxyz"; String sU = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"; for(int i=0; i&lt;s.length(); i++) &#123; char c = s.charAt(i); if(sL.indexOf(c) != -1) &#123; lCount ++; &#125; else if (sU.indexOf(c) != -1) &#123; uCount ++; &#125; else &#123; oCount ++; &#125; &#125; */ //方法三 for(int i=0; i&lt;s.length(); i++) &#123; char c = s.charAt(i); if(Character.isLowerCase(c)) &#123; lCount ++; &#125; else if (Character.isUpperCase(c)) &#123; uCount ++; &#125; else &#123; oCount ++; &#125; &#125; System.out.println(lCount + " " + uCount + " " + oCount); 二、将“1,2;3,4,5;6,7,8”这个字符串分解为二维数组。123456789101112131415161718192021public class ArrayParser &#123; public static void main(String[] args)&#123; double[][] d; String = "1,2;3,4,5;6,7,8"; String[] sFirst = s.split(";"); d = new double[sFirst.length][]; for(int i = 0; i &lt; sFirst.length; i++)&#123; String[] sSecond = sFirst[i].split(","); d[i] = new double[sSecond.length]; for(int j = 0; j &lt; sSecong.length; j++)&#123; d[i][j] = Double.parseDouble(sSecond[j]); &#125; &#125; for(int i = 0; i &lt; d.length; i++)&#123; for(int j = 0; j &lt; d[i].length; j++)&#123; System.out.print(d[i][j] + " "); &#125; System.out.println(); &#125; &#125;&#125; 三、利用递归列出目录结构12345678910111213141516171819202122232425import java.io.*;public class FileList &#123; public static void main(String[] args) &#123; File f = new File("d:/A"); System.out.println(f.getName()); tree(f, 1); &#125; private static void tree(File f, int level) &#123; String preStr = ""; for(int i=0; i&lt;level; i++) &#123; preStr += " "; &#125; File childs = f.listFiles(); for(int i=0; i&lt;childs.length; i++) &#123; System.out.println(preStr + childs[i].getName()); if(childs[i].isDirectory()) &#123; tree(childs[i], level + 1); &#125; &#125; &#125;&#125; 四、编写一个方法，输出在一个字符串中，指定字符串出现的次数123456789101112131415 String s = "sunjavahpjavaokjavajjavahahajavajavagoodjava"; String sToFind = "java"; int count = 0; int index = -1; while((index = s.indexOf(sToFind)) != -1) &#123; s = s.substring(index + sToFind.length()); count ++; &#125; System.out.println(count);&#125;]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>class</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[别再乱用jQuery return false]]></title>
    <url>%2F2017%2F05%2F14%2F%E5%88%AB%E5%86%8D%E4%B9%B1%E7%94%A8jQuery%20return%20false%2F</url>
    <content type="text"><![CDATA[前言​ event.preventDefault()方法是用于取消事件的默认行为，但此方法并不被ie支持，在ie下需要用window.event.returnValue = false; 来实现。这不是jQuery的方法，是JS本身自带的。 event.preventDefault()​ 该方法将通知 Web 浏览器不要执行与事件关联的默认动作（如果存在这样的动作）。例如，如果 type 属性是 “submit”，在事件传播的任意阶段可以调用任意的事件句柄，通过调用该方法，可以阻止提交表单。注意，如果 Event 对象的 cancelable 属性是 fasle，那么就没有默认动作，或者不能阻止默认动作。无论哪种情况，调用该方法都没有作用。 event.stopPropagation()​ 该方法将停止事件的冒泡，阻止它被分派到其他 Document 节点。在事件冒泡的任何阶段都可以调用它。注意，虽然该方法不能阻止同一个 Document 节点上的其他事件句柄被调用，但是它可以阻止把事件分派到其他节点。event是DOM的事件方法，所以不是单独使用，比如指定DOM。 测试在jQuery代码中，我们常见用return false来阻止浏览器的默认行为。例如点击链接，浏览器默认打开一个新窗口/标签，为了阻止浏览器的默认行为，我们往往这样操作： 1234$("a.toggle").click(function() &#123; $("#mydiv").toggle(); return false; &#125;); 这段代码的作用是通过点击toggle来隐藏或显示#mydiv，并阻止浏览器继续访问href指定链接。测试如下： click toggle 点击上一行的toggle，这段文字将被显示或隐藏。 return false的作用return false达到了我们想要的目的，但这并不是阻止浏览器执行默认行为的正确方法。调用return false，它实际完成了3件事： 1.event.preventDefault()2.event.stopPropagation()3.停止回调函数执行并立即返回。我们真正的目的是event.preventDefault()，后两者可不是我们想要的。JavaScript事件有两种，一种称为事件冒泡（event bubbling），一种称为事件捕捉（event capturing）。事件冒泡指事件在初始DOM上触发，通过DOM树往上在每一级父元素上触发；当事件向下冒泡时，我们则称之为事件捕获。 测试因为return false多做了两件事，由此为代码埋下隐患。下面有一个简单的例子，点击一个链接，加载新的页面内容到当前页面： 1234567891011121314151617&lt;div class="post"&gt; &lt;a href="/js/loadp1.txt"&gt;Click here to load page1&lt;/a&gt; &lt;div class="content"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="post"&gt; &lt;a href="/js/loadp2.txt"&gt;Click here to load page2&lt;/a&gt; &lt;div class="content"&gt; &lt;/div&gt; &lt;/div&gt; $("div.post a").click(function() &#123; var href = $(this).attr("href"); $(this).next().load(href); return false; &#125;); 测试如下： Click here to load page1 Click here to load page2 ​ 点击链接就能加载页面内容到当前页，一切都OK。现在我们想要加一个新功能，例如论坛帖子的浏览，只有当前点击的帖子内容才会显示，其他帖子都隐藏。为此我们需要为div.post加一个click()事件处理： 1234$("div.post").click(function()&#123; $("div.post .content").hide(); // hide all content $(this).children(".content").show(); // show this one &#125;); ​ 添加完这段代码后，我们发现它不生效，缘故是因为$(&quot;div.post a&quot;).click(function() { return false; });，由于return false执行了event.stopPropagation()，因此事件不能冒泡到上一级DOM，即$(&quot;div.post&quot;).click()不会被事件触发。要达成我们的任务，应该把return false替换为event.preventDefault()： 12345$("div.post a").click(function(e) &#123; var href = $(this).attr("href"); $(this).next().load(href); e.preventDefault(); &#125;); 测试修改后的代码： Click here to load page1 Click here to load page2 return false 和 live/delegate如果把return false和live/delegate事件混用，情况就更糟糕了： 12345678$("a").click(function()&#123; // do something return false; &#125;); $("a").live("click", function()&#123; // this won't fire &#125;); 如果确实需要阻止事件冒泡，也应该显式地调用： 12345678$("div.post").click(function()&#123; // do something &#125;); $("div.post a").click(function(e)&#123; // 浏览器跳转到新页面（默认行为） // 但阻止事件冒泡，即不会执行$("div.post").click() e.stopPropagation(); &#125;); event.stoplmmediatePropagetion()​ event.stopPropagation()用于阻止事件冒泡，jQuery中还有另一个函数：event.stopImmediatePropagation()，它用于阻止一个事件的继续执行，即使当前对象上还绑定了其他处理函数： 12345678910111213141516$("div a").click(function()&#123; // do something &#125;); $("div a").click(function(e)&#123; // stop immediate propagation e.stopImmediatePropagation(); &#125;); $("div a").click(function()&#123; // never fires &#125;); $("div a").click(function()&#123; // never fires &#125;); 总结​ 最后结论是：理解return false，尽量避免使用它，请用event.preventDefault()替代return false。]]></content>
      <categories>
        <category>javascript</category>
        <category>jQuery</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery读书笔记]]></title>
    <url>%2F2017%2F05%2F01%2FjQuery%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[最近在学习jQuery,顺便做了一点笔记，防止以后要寻找的时候找不到。 1)$(“form :input”) 返回form中的所有表单对象，包括textarea、select、button等 $(“form input”)返回form中的所有input标签对象 $(“#form1:input”)表示id为#form1的input form input 是属于层级选择器(将每一个选择器匹配到的元素合并后一起返回) 2)121. &lt;div id = "id#b"&gt;bb&lt;/div&gt; 2. &lt;div id = "id[1]"&gt;cc&lt;/div&gt; 上述div不能用普通方式来获取，例如 121. $("#id#b"); 2. $("#id[1]"); 而应该用转义字符： 121. $("#id\#b"); 2. $("#id\[1\]"); 3)12345671. $(document).ready(function()&#123; 2. //... 3. &#125;); 4. 可以简写为 5. $(function()&#123; 6. //... 7. &#125;) 4)123456781. &lt;div class="test"&gt; 2. &lt;div style="display:none;"&gt;aa&lt;/div&gt; 3. &lt;div style="display:none;"&gt;bb&lt;/div&gt; 4. &lt;div style="display:none;"&gt;cc&lt;/div&gt; 5. &lt;div class="test" style="display:none;"&gt;dd&lt;/div&gt; 6. &lt;/div&gt; 7. &lt;div class="test" style="display:none;"&gt;ee&lt;/div&gt; 8. &lt;div class="test" style="display:none;"&gt;ff&lt;/div&gt; 下面用jquery选取： 123456789101. $(function()&#123; 2. //注意区分类似这样的选择器 3. //虽然一个空格，却截然不同的效果. 4. var t_a = ('.test :hidden'); 5. var t_b = ('.test:hidden'); 6. var len_a = $t_a.length; 7. var len_b = $t_b.length; 8. ("&lt;p&gt;('.test :hidden')的长度为"+len_a+"&lt;/p&gt;").appendTo("body"); //4 9. ("&lt;p&gt;('.test:hidden')的长度为"+len_b+"&lt;/p&gt;").appendTo("body"); //3 10. &#125;) 原因是： var $t_a = $(“.test :hidden”); 以上代码是选取class为”test”的元素里面的隐藏元素 而代码： var $t_b = $(“.test:hidden”); 这是选取隐藏的class为“test”的元素 5)detach()和remove()一样，也是从DOM中去掉匹配的元素。但是这个方法不会把匹配的元素从jQuery对象中删除，因而可以在将来再使用这些匹配的元素，与remove不同的是，所以绑定的事件、附加的数据等都会保留下来。 6)$(this).clone(true).appendTo(“body”); //注意参数true 在clone()方法中传递了一个参数true，它的含义是复制元素的同事复制元素中所绑定的事件，因而该元素的副本也同样具有复制功能。 7)在css()方法中，如果属性中带有“-”符号，例如font-size属性，如果在设置这些属性的值得时候不带引号，那么就要用驼峰式写法，例如： $(“p”).css({fontSize : “30px” , backgroundColor : “#888888”}); 如果加上了引号，既可以写成”font-size”,也可以写成“fontSize”。 8)show()方法和hide()方法会同时修改元素的多个样式属性，即高度、宽度和不透明度；fadeOut()和fadeIn()方法智慧修改元素的不透明度；slideDown()方法和slideUp()方法智慧改变元素的高度。 9)1234567891011121. $("button:eq(1)").click(function () &#123; 2. $("#panel").stop();//停止当前动画，继续下一个动画 3. &#125;); 4. $("button:eq(2)").click(function () &#123; 5. $("#panel").stop(true);//清除元素的所有动画 6. &#125;); 7. $("button:eq(3)").click(function () &#123; 8. $("#panel").stop(false,true);//让当前动画直接到达末状态 ，继续下一个动画 9. &#125;); 10. $("button:eq(4)").click(function () &#123; 11. $("#panel").stop(true,true);//清除元素的所有动画，让当前动画直接到达末状态 12. &#125;); 10)animate回调函数 12345$("#panel").click(function () &#123; $(this).animate(&#123;left: "400px", height: "200px", opacity: "1"&#125;, 3000) .animate(&#123;top: "200px", width: "200px"&#125;, 3000, function () &#123; $(this).css("border", "5px solid blue"); &#125;) 11)用attr()和prop()访问对象的属性的原则： 第一个原则：只添加属性名称该属性就会生效应该使用prop()； 第一个原则：只存在true/false的属性应该使用prop()。 按照官方说明，如果是设置disable和checked这些属性，应使用prop()方法，而不是使用attr()方法。（例如在某些浏览器里，只要写了disabled属性就可以，有些则要写：disabled = “disabled”。）]]></content>
      <categories>
        <category>javascript</category>
        <category>jQuery</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
        <tag>javascript</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript冒泡事件的作用效果]]></title>
    <url>%2F2017%2F04%2F22%2Fjavascript%E5%86%92%E6%B3%A1%E4%BA%8B%E4%BB%B6%E7%9A%84%E4%BD%9C%E7%94%A8%E6%95%88%E6%9E%9C%2F</url>
    <content type="text"><![CDATA[​ 这段时间在学习js，忽然发现了冒泡事件挺有趣的，故研究后来跟各位分享一下效果。 话不多说，直接上代码： 代码123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="body"&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=""&gt;home&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=""&gt;About&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;script&gt; function stopBubble(e)&#123; if(e &amp;&amp; e.stopPropagation)&#123;//如果不是IE浏览器 e.stopPropagation(); &#125;else&#123;//是IE浏览器 window.event.cancelBubble=true; &#125; &#125; var all = document.getElementsByTagName("*"); for(var i =0;i&lt;all.length;i++)&#123; all[i].onmouseover = function(e)&#123;//鼠标悬停在元素上 this.style.border="1px solid red"; stopBubble(e); &#125;; all[i].onmouseout=function(e)&#123;//鼠标离开 this.style.border="0px"; stopBubble(e);//阻止冒泡 &#125;; &#125; &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 总结​ 上面是一个简单的例子,当鼠标悬停在元素之上,我们为这个元素加上红色边框,如果离开了再去掉这个红色边框, ​ 如果不加 这个 阻止冒泡的方法,每次都会给父类增加红色边框,大家 可以试验一下.一试便知!]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>冒泡事件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello Hexo]]></title>
    <url>%2F2017%2F01%2F23%2Fhello-hexo%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>Hexo教程</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于解决VS2015不能用fscanf而老是提示用fscanf_s的方法]]></title>
    <url>%2F2016%2F12%2F17%2F%E5%85%B3%E4%BA%8E%E8%A7%A3%E5%86%B3VS2015%E4%B8%8D%E8%83%BD%E7%94%A8fscanf%E8%80%8C%E8%80%81%E6%98%AF%E6%8F%90%E7%A4%BA%E7%94%A8fscanf-s%E7%9A%84%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[前言​ 由于笔者之前用的是dev还有code block，没怎么用过VS2015这个软件，所以发现有些东西不太一样，在下面跟大家分享一下。 问题​ 在处理文件输入的时候，我本来是想用fscanf函数，但是编译的时候老是说fscanf函数不安全，建议改成fscanf_s函数。但是fscanf_s函数我不会用，找了挺久的资料，终于知道解决方法了。 解决方法方法一：在程序最前面加#define _CRT_SECURE_NO_DEPRECATE； 方法二：在程序最前面加#define _CRT_SECURE_NO_WARNINGS； 方法三：在程序最前面加#pragma warning(disable:4996)； 方法四：把scanf改为scanf_s；. 方法五：无需在程序最前面加那行代码，只需在新建项目时取消勾选“SDL检查”即可； 方法六：若项目已建立好，在项目属性里关闭SDL也行； 方法七：在工程项目设置一下就行；将报错那个宏定义放到 项目属性 – C/C++– 预处理器 – 预处理器定义； 方法八：在 项目属性 – c/c++ – 命令行 添加：/D _CRT_SECURE_NO_WARNINGS 就行了。]]></content>
      <categories>
        <category>编译器问题</category>
      </categories>
      <tags>
        <tag>Visual Studio</tag>
        <tag>fscanf_s</tag>
      </tags>
  </entry>
</search>