<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[VMwave Workstation12虚拟机安装OS X 10.11所遇到的各种问题集合(详细版)]]></title>
    <url>%2F2017%2F07%2F24%2F10-11%E6%89%80%E9%81%87%E5%88%B0%E7%9A%84%E5%90%84%E7%A7%8D%E9%97%AE%E9%A2%98%E9%9B%86%E5%90%88-%E8%AF%A6%E7%BB%86%E7%89%88%2F</url>
    <content type="text"><![CDATA[一、前言最近笔者闲着无聊，由于一直挺仰慕mac大法，所以想装个mac系统来玩玩。虽然说过程不是很难，但是出现的各种小问题还是挺多的，所以在这里跟大家分享一下我的解决方法。 1.首先，当然是安装工具： Mac OS X 10.11 镜像文件（链接：http://pan.baidu.com/s/1pL8HE59 密码：cq4d）（此镜像为网络收集，如果觉得有问题自己找谢谢。） unlocker208文件（链接：http://pan.baidu.com/s/1bpftVjT 密码：dp2g） VMware Workstation12（http://blog.sina.com.cn/s/blog_af49f8090102wqmw.html） 2.详细教程请查看：http://jingyan.baidu.com/article/363872ec206a356e4ba16f30.html 在这里我就不再赘述。 二、所遇到的问题下面来看看我安装后遇到的各种问题： 1) VMware上MAC虚拟机不能上网问题首先最大的问题当然就是没网啦，别急，且听我慢慢道来： 解决方法/步骤1.从本机中选择打开连接网络，选择本地连接。如果是无线网可以选择无线网。 2.选择属性，点击共享按钮。 3.将internet连接共享下面两个选项都选中，然后在家庭网络连接选择VMware Network Adapter VMnet1。 4.在安装的虚拟机中选择虚拟机-&gt;设置选项。 5.点击网络适配器，将网络连接改成仅主机模式（Host-only），然后在右侧选择主机模式，点击确定。 6.进入Mac系统，选择设置，进入网络设置 7.配置Ipv4选择设置DHCP，点击应用即可开始上网。2)OS X 10.11 El Capitan 无法连接Apple store 和登录Apple ID的问题1.step 1强制退出Apple store进程 2. step 2打开terminal终端（在launch中搜索终端），输入以下命令： 123sudo pkill -9 -f Account sudo rm $HOME/Library/Accounts/* 进行此操作时需要提供管理员密码，输入密码敲回车就行了。 3.step 3完成前面两步你已经可以进入apple store了，但是你发现你的apple ID无法登陆： This action cant be Completed! 这时你可以terminal终端输入以下命令： 12345sudo mkdir -p /Users/Shared sudo chown root:wheel /Users/Shared sudo chmod -R 1777 /Users/Shared 至此，你的Apple ID就可以在Apple store上Login了。 3)苹果ID注册最后一步总是显示 如需帮助，请联系iTunes支持由于我的apple id是刚刚注册的，登陆apple store后提示我还没有完善资料什么的，所以我就去填资料 填完资料发现老是出现上面的那一句，继续不了。 所以我又开始了尝试 1.首先在iTunes软件上面注册Apple ID帐号时，注意要把提供付款方式选择为“银联UnionPay”，目前因为iTunes软件版本更新了不能像以前那样不绑定银行卡就可以注册Apple ID帐号。 2.然后填写银行卡以及输入银行预留手机号码。(注意：手机号码一定是要和银行卡绑定在一起的才可以使用。) 3.接下来在帐单寄送地址下方依次将个人的姓、名、街道地址、所在地区、邮编、省份、手机号码填写正确完整。 4.点击创建Apple ID，进入下一步。 5.然后收取绑定银行的短信验证码输入里面进行验证。 填入验证码就可以完美解决，我也试过用银行卡的方式，但是还是不行，最后尝试了银联这个就OK了。 三、补充对了，补充一下，可能安装后会发现虚拟机没办法占全屏，只要安装VMwave Tools既可以完美解决，至于卡顿问题，我笔记本是8G内存，我分了4G在虚拟机，相对来说比较不卡，也可以下载一个叫做beamoff的工具,在mac osx下解压即可消除卡顿的感觉。 下载链接 : http://download.csdn.NET/detail/u013803262/9702291 具体解决方法参考：http://blog.csdn.net/u013803262/article/details/53467693 好了，以上就是我装mac虚拟机所遇到的比较难缠的问题，分享给大家一下。]]></content>
      <categories>
        <category>装系统</category>
      </categories>
      <tags>
        <tag>VMwave</tag>
        <tag>OS X 10.11</tag>
        <tag>虚拟机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[将应用程序部署到Heroku]]></title>
    <url>%2F2017%2F07%2F22%2F%E5%B0%86%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E9%83%A8%E7%BD%B2%E5%88%B0Heroku%2F</url>
    <content type="text"><![CDATA[1.注册1.1在http://api/heroku.com/signup注册Hero帐号 1.2访问邮件中的链接并输入密码 1.3从 http://devcenter.heroku.com/articles/quickstart#step_2_install_the_heroku_toolbelt 为你的平台安装安装程序。 1.4打开终端窗口并登陆到Heroku 1heroku login 2.配置12345678910111213141516171.在app.js文件的顶部，添加如下行：var port = (process.env.PORT || 3000);2.将下列行从app.js中移除:app.listen(3000);3.用下列行替换它：app.listen(port);4.在应用程序的根目录中，添加一个名为Procfile的文件并加入如下内容：web: node app.js5.用如下命令安装依赖模块：npm install6.启动应用程序并检查其是否运行正常：node app.js 3.将应用程序提交到heroku1234567891011123.1使用如下命令创建Git库：git initgit add .git commit -m &quot;initial commit&quot;3.2使用如下命令在Heroku上创建应用程序。注意从这一命令返回的URL:heroku create --stack cedar3.3用如下命令将站点发布到Heroku：git push heroku master3.4访问之前得到的URL，可看到所部署的网站了！]]></content>
      <categories>
        <category>node.js</category>
      </categories>
      <tags>
        <tag>Heroku</tag>
        <tag>node.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Oracle学习笔记(六)]]></title>
    <url>%2F2017%2F07%2F20%2FOracle%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%85%AD%2F</url>
    <content type="text"><![CDATA[46.异常(1)12345678910111213141516171819declare v_temp number(4); begin select empno into v_temp from emp where deptno = 10; exception when too_many_rows then dbms_output.put_line('太多记录了'); when others then dbms_output.put_line('error'); end; (2)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475 declare v_tempnumber(4); begin select empno into v_temp from emp where empno = 2222; exception when no_data_found then dbms_output.put_line('没有该项数据'); end;----------------错误记录日志(用表记录：将系统日志存到数据库便于以后查看) ----------- 创建序列（用来处理递增的ＩＤ）： create sequence seq_errorlog_id start with 1 increment by 1; 创建日志表: create table errorlog ( id number primary key, errcode number, errmsg varchar2(1024), errdate date ); 示例程序： declare v_deptno dept.deptno%type := 10; v_errcode number; v_errmsg varchar2(1024); begin delete from dept where deptno = v_deptno; commit; exception when others then rollback; v_errcode:= SQLCODE; v_errmsg:= SQLERRM; insert into errorlog values (seq_errorlog_id.nextval, v_errcode,v_errmsg, sysdate); commit; end; 47. PL/SQL中的重点cursor(游标)和指针的概念差不多123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293declare cursorc isselect * from emp; //此处的语句不会立刻执行，而是当下面的open c的时候，才会真正去数据库中取数据 v_emp c%rowtype; begin open c; fetch c into v_emp;dbms_output.put_line(v_emp.ename); //这样会只输出一条数据 134将使用循环的方法输出每一条记录 close c; end;----------------------使用do while 循环遍历游标中的每一个数据--------------------- declare cursor c is select* from emp; v_emp c%rowtype; begin open c; loop fetch c into v_emp;(1) exit when(c%notfound); //notfound是oracle中的关键字，作用是判断是否还有下一条数据(2) dbms_output.put_line(v_emp.ename); //(1)(2)的顺序不能颠倒，否则会把最后一条结果再多打印一次。 end loop; close c; end;------------------------使用while循环，遍历游标--------------------- declare cursor c is select* from emp; v_emp emp%rowtype; begin open c; fetch c into v_emp; while(c%found) loop dbms_output.put_line(v_emp.ename); fetch c into v_emp; end loop; close c; end;s------------------------使用for 循环，遍历游标（最方便快捷的方法！）----------------- declare cursorc is select * from emp; begin for v_emp in c loop dbms_output.put_line(v_emp.ename); endloop; end; 带参数的游标（相当于函数）1234567891011121314151617declare cursor c(v_deptno emp.deptno%type, v_job emp.job%type) is select ename, sal from emp where deptno=v_deptno and job=v_job; begin forv_temp in c(30, 'CLERK') loop dbms_output.put_line(v_temp.ename); endloop;end; 可更新的游标123456789101112131415161718192021222324252627declare cursorc is select * from emp2 for update; begin for v_temp in c loop if(v_temp.sal&lt; 2000) then update emp2 set sal = sal * 2 where current of c; elsif (v_temp.sal =5000) then deletefrom emp2 where current of c; end if; end loop; commit; end; 48. store procedure存储过程(带有名字的程序块)12345678910111213141516171819202122232425262728293031323334353637383940414243createor replace procedure p is--除了这两句替代declare，下面的语句全部都一样 cursor c is select * from emp2 for update; begin for v_emp in c loop if(v_emp.deptno= 10) then updateemp2 set sal = sal +10 where current of c; elseif(v_emp.deptno =20) then updateemp2 set sal = sal + 20 where current ofc; else updateemp2 set sal = sal + 50 where current of c; endif; end loop; commit; end; 执行存储过程的两种方法： （1）exec p;(p是存储过程的名称) （2）begin p; end; / 带参数的存储过程先创建存储过程：（in标识传入参数，out标识传出参数，默认为传入参数） 12345678910111213141516171819202122232425262728293031323334353637383940414243 createor replace procedure p (v_ain number, v_b number, v_ret out number, v_temp inout number) is begin if(v_a&gt; v_b) then v_ret:= v_a; else v_ret:= v_b; endif; v_temp:= v_temp + 1; end;再调用： declare v_a number := 3; v_b number := 4; v_retnumber; v_tempnumber := 5; begin p(v_a,v_b, v_ret, v_temp); dbms_output.put_line(v_ret); dbms_output.put_line(v_temp); end; 删除存储过程​ dropprocedure p; 49. 创建函数计算个人所得税的税率12345678910111213141516171819202122232425createor replace function sal_tax (v_sal number) returnnumber is begin if(v_sal&lt; 2000) then return0.10; elsif(v_sal&lt;2750) then return0.15; else return0.20; endif; end; 50. 创建触发器（trigger）触发器不能单独的存在，必须依附在某一张表上 写主语 谓语 宾语 游戏 ​ 创建触发器的依附表： 1234567891011121314151617181920212223242526272829303132 createtable emp2_log ( enamevarchar2(30) , eactionvarchar2(20), etimedate ); create or replace trigger trigafter insert or delete orupdate on emp2 for each row --加上此句，每更新一行，触发一次，不加入则值触发一次 begin ifinserting then insertinto emp2_log values(USER, 'insert', sysdate); elsifupdating then insertinto emp2_log values(USER, 'update', sysdate); elsifdeleting then insertinto emp2_log values(USER, 'delete', sysdate); endif; end; 51.触发器用法之一：通过触发器更新约束的相关数据12345678910111213createor replace trigger trig afterupdate on dept foreach row begin updateemp set deptno =:NEW.deptno where deptno =: OLD.deptno; end; --只编译不显示的解决办法 set serveroutput on; 52.通过创建存储过程完成递归123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263 createor replace procedure p(v_pid article.pid%type,v_level binary_integer) is cursorc is select * from article where pid = v_pid; v_preStrvarchar2(1024) := ''; begin for i in 0..v_leave loop v_preStr:= v_preStr || ''; end loop; for v_article in c loop dbms_output.put_line(v_article.cont); if(v_article.isleaf= 0) then p(v_article.id); endif; endloop; end;-------------------------------查看当前用户下有哪些表--- 首先，用这个用户登录然后使用语句： select* from tab; -----------------------------用Oracle进行分页！-------------- 因为Oracle中的隐含字段rownum不支持'&gt;'所以： select* from ( selectrownum rn, t.* from ( select* from t_user where user_id &lt;&gt; 'root' )t where rownum &lt;6 )where rn &gt;3------------------------Oracle下面的清屏命令---------------- clearscreen; 或者 cle scr; -----------将创建好的guohailong的这个用户的密码改为abc-------------- alter user guohailong identified by abc --当密码使用的是数字的时候可能会不行]]></content>
      <categories>
        <category>Oracle</category>
      </categories>
      <tags>
        <tag>Oracle sql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Oracle学习笔记(五)]]></title>
    <url>%2F2017%2F07%2F19%2FOracle%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BA%94%2F</url>
    <content type="text"><![CDATA[PL_SQL(过程化SQL语言)38. 在客户端输出helloworld12345678910111213141516171819202122232425 set serveroutput on;//默认是off，设成on是让Oracle可以在客户端输出数据 begin dbms_output.put_line('helloworld'); end; /----------------pl/sql变量的赋值与输出---- declare v_name varchar2(20);//声明变量v_name变量的声明以v_开头 begin v_name:= 'myname'; dbms_output.put_line(v_name); end; / 39. pl/sql对于异常的处理(除数为0)12345678910111213141516171819 declare v_num number := 0; begin v_num:= 2/v_num; dbms_output.put_line(v_num);** exception**** when others then**** dbms_output.put_line('error');** end; / 40. 变量的声明​ binary_integer:整数，主要用来计数而不是用来表示字段类型 比number效率高 ​ number:数字类型 ​ char:定长字符串 ​ varchar2：变长字符串 ​ date：日期 ​ long：字符串，最长2GB ​ boolean：布尔类型，可以取值true，false，null//最好给一初值 12345678910111213141516171819----------变量的声明，使用 '%type'属性--------- declare v_empno number(4); v_empno2 emp.empno%type; v_empno3 v_empno2%type; begin dbms_output.put_line('Test'); end; / --使用%type属性，可以使变量的声明根据表字段的类型自动变换，省去了维护的麻烦，而且%type属性，可以用于变量身上 41.组合变量1234567891011121314151617---------------Table变量类型(相当于java里面的数组)-------------------- declare type type_table_emp_empno is table of emp.empno%type index by binary_integer; v_empnostype_table type_table_empno; begin v_empnos(0):= 7345; v_empnos(-1):=9999; dbms_output.put_line(v_empnos(-1)); end; 42. Record变量类型（相当于Java里面的类）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647 declare type type_record_dept is record ( deptno dept.deptno%type, dname dept.dname%type, loc dept.loc%type ); v_temp type_record_dept; begin v_temp.deptno:=50; v_temp.dname:='aaaa'; v_temp.loc:='bj'; dbms_output.put_line(v_temp.deptno|| ' ' || v_temp.dname); end; -----------使用 %rowtype声明record变量，直接参照表来声明record------------------- declare v_temp dept%rowtype; begin v_temp.deptno:=50; v_temp.dname:='aaaa'; v_temp.loc:='bj'; dbms_output.put_line(vtemp.deptno || '' || v temp.dname) end; ​ 43. select语句的运用(必须保证select语句有相应的返回记录)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667 declare v_ename emp.ename%type; v_sal emp.sal%type; begin select ename,sal into v_ename,v_sal from emp where empno = 7369; dbms_output.put_line(v_ename|| '' || v_sal); end;-------------------------select语句的应用（record）------------------------------ declare v_emp emp%rowtype; begin select * into v_emp from emp where empno=7369; dbms_output_line(v_emp.ename); end; ------------- insert语句的应用 ----------------------------- declare v_deptno dept.deptno%type := 50; v_dname dept.dname%type :='aaa'; v_loc dept.loc%type := 'bj'; begin insert into dept2 values(v_deptno,v_dname,v_loc); commit; end; -------------update 语句的应用------------------------------ declare v_deptno emp2.deptno%type := 50; v_count number; begin update emp2 set sal = sal/2 where deptno =v_deptno; dbms_output.put_line(sql%rowcount || ‘条记录被影响’); commit; end; 注：sql%rowcount统计上一条sql语句更新的记录条数 44.ddl语言，数据定义语言12345678910111213141516171819202122232425262728293031 begin execute immediate 'create table T (nnn varchar(30) default ''a'')'; end;------------------ifelse语句-------------------------------------- declare v_sal emp.sal%type; begin select sal into v_sal from emp where empno = 7369; if(v_sal&lt; 2000) then dbms_output.put_line('low'); els if(v_sal &gt; 2000) then dbms_output.put_line('middle'); else dbms_output.put_line('height'); end if; end; 45. 循环do while 循环1234567891011121314151617declare i binary_integer := 1; begin loop dbms_output.put_line(i); i:= i + 1; exit when (i&gt;=11); end loop; end; while 循环123456789101112131415declare j binary_integer := 1; begin while j &lt; 11 loop dbms_output.put_line(j); j:=j+1; end loop; end; for 循环123456789101112131415begin for k in 1..10 loop dbms_output.put_line(k); end loop; for k in reverse 1..10 loop dbms_output.put_line(k); end loop; end;]]></content>
      <categories>
        <category>Oracle</category>
      </categories>
      <tags>
        <tag>Oracle sql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Oracle学习笔记(四)]]></title>
    <url>%2F2017%2F07%2F18%2FOracle%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9B%9B%2F</url>
    <content type="text"><![CDATA[24.——-创建新用户——–123456789101112131、backup scott//备份 exp//导出2、create user createuser guohailong identified(认证) by guohailong default table space users quota(配额) 10M on users grant create session(给它登录到服务器的权限),create table, create view to guohailong3、import data Imp 25. ——-取消操作——–123456789101112131415161718192021222324252627282930313233343536373839404142434445464748rollback-----------事务确认语句-------- commit;//此时再执行rollback无效当正常断开连接的时候例如exit,事务自动提交。 当非正常断开连接，例如直接关闭dos窗口或关机，事务自动提交 -----表的备份 create table dept2 as select * from dept;-----插入数据 insert into dept2 values(50,'game','beijing'); ----只对某个字段插入数据 insert into dept2(deptno,dname) values(60,'game2');-----将一个表中的数据完全插入另一个表中（表结构必须一样） insert into dept2 select * from dept;-----求前五名员工的编号和名称（使用伪字段rownum 只能使用 &lt; 或 = 要使用 &gt; 必须使用子查询） select empno,ename from emp where rownum &lt;= 5;----求10名雇员以后的雇员名称-------- select ename from (select rownum r,ename from emp) where r &gt; 10;----求薪水最高的前5个人的薪水和名字--------- select ename, sal from (select ename, sal from emp order by sal desc) where rownum&lt;=5; ----求按薪水倒序排列后的第6名到第10名的员工的名字和薪水-------- selectename, sal from (select ename, sal, rownum r from (select ename, sal from emp orderby sal desc) ) where r&gt;=6 and r&lt;=10 26. ——-面试题——–​ 有3个表S，C，SC ​ S（SNO，SNAME）代表（学号，姓名） ​ C（CNO，CNAME，CTEACHER）代表（课号，课名，教师） ​ SC（SNO，CNO，SCGRADE）代表（学号，课号成绩） ​ 问题： ​ 1，找出没选过“黎明”老师的所有学生姓名。 ​ 2，列出2门以上（含2门）不及格学生姓名及平均成绩。 ​ 3，即学过1号课程有学过2号课所有学生的姓名。 ​ 答案： 1234567891011121、 select sname from s join sc on(s.sno =sc.sno) join c on (sc.cno = c.cno) where cteacher &lt;&gt; '黎明';2、 select sname where sno in (select sno from sc where scgrade &lt; 60 group by sno having count(*) &gt;=2);3、 select sname from s where sno in (select sno, from sc where cno=1 and cno in (select distinct sno from sc where cno = 2); ) 27. ——–创建表———–123456789101112131415161718192021create table stu(id number(6),name varchar2(20) constraint stu_name_mmnot null,sex number(1),age number(3),sdate date,grade number(2) default 1,class number(4),email varchar2(50) unique ); 28. 五种约束条件：非空约束、唯一约束、主键约束、外键约束、检查约束（check）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273--------------给name字段加入 非空 **约束**，并给约束一个名字，若不取，系统默认取一个------------- create table stu ( id number(6), name varchar2(20) constraint stu_name_mm not null, sex number(1), age number(3), sdate date, grade number(2) default 1, class number(4), email varchar2(50) );--------------给nameemail字段加上唯一约束两个 null值 不为重复------------- create table stu ( id number(6), name varchar2(20) constraint stu_name_mmnot null, sex number(1), age number(3), sdate date, grade number(2) default 1, class number(4), email varchar2(50) unique );--------------两个字段的组合不能重复 约束：表级约束------------- create table stu ( id number(6), name varchar2(20) constraint stu_name_mmnot null, sex number(1), age number(3), sdate date, grade number(2) default 1, class number(4), email varchar2(50)， constraint stu_name_email_uni unique(email,name) ); 29. ——-主键约束——–​ 12345678910111213141516171819202122232425create table stu ( id number(6), name varchar2(20) constraint stu_name_mmnot null, sex number(1), age number(3), sdate date, grade number(2) default 1, class number(4), email varchar2(50), constraint stu_id_pk primary key (id), constraintstu_name_email_uni unique(email, name) ); 30.—外键约束 被参考字段必须是主键—123456789101112131415161718192021222324252627282930313233343536373839create table stu(id number(6),name varchar2(20) constraint stu_name_mmnot null,sex number(1),age number(3),sdate date,grade number(2) default 1,class number(4) references class(id),email varchar2(50), constraint stu_class_fk foreign key (class) references class(id), constraint stu_id_pk primary key (id), constraint stu_name_email_uni unique(email, name) ); 红色为字段约束的写法，蓝色为表级约束的写法 createtable class ( idnumber(4) primary key, namevarchar2(20) not null ); 31. 修改表结构12345678910111213141516171819---------------添加字段-------------------------- altertable stu add(addr varchar2(29));---------------删除字段-------------------------- altertable stu drop (addr);---------------修改表字段的长度------------------ altertable stu modify (addr varchar2(50));//更改后的长度必须要能容纳原先的数据----------------删除约束条件---------------- altertable stu drop constraint 约束名-----------修改表结构添加约束条件--------------- altertable stu add constraint stu_class_fk foreign key (class) references class(id); 32. 数据字典表（有user_tables、user_views、user_constraints等等）12345678910111213141516---------------查看当前用户下面所有的表、视图、约束-----数据字典表user_tables--- select table_name from user_tables; select view_name from user_views; select constraint_name from user_constraints; 存储数据字典表的信息的表：dictionary; //该表共有两个字段 table_name comments //table_name主要存放数据字典表的名字 //comments主要是对这张数据字典表的描述 ​ 33. 索引(能优化查询效率)12345678910111213create index idx_stu_email on stu (email);// 在stu这张表的email字段上建立一个索引：idx_stu_email---------- 删除索引 ------------------ drop index index_stu_email;---------查看所有的索引---------------- select index_name from user_indexes;---------创建视图------------------- create view v$stu as select id,name,age from stu; ​ 视图的作用: 简化查询，保护我们的一些隐私数据，通过视图也可以用来更新数据，但是我们一般不这么用 缺点：要对视图进行维护 34.创建序列（sequence，oracle特有的东西，一般用来做主键）​ 12345678910111213create sequence seq;//创建序列 select seq.nextval from dual;// 查看seq序列的下一个值 drop sequence seq;//删除序列 create table article ( id number, title varchar2(1024),cont long); create sequence seq; insert into article (id,title,cont) values(seq.nextval , ‘a’, ‘b’); 35. 数据库的三范式​ （1）要有主键，列不可分 ​ （2）不能存在部分依赖：当有多个字段联合起来作为主键的时候，不是主键的字段不能部分依赖于主键中的某个字段 ​ （3）不能存在传递依赖]]></content>
      <categories>
        <category>Oracle</category>
      </categories>
      <tags>
        <tag>Oracle sql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Oracle学习笔记(三)]]></title>
    <url>%2F2017%2F07%2F18%2FOracle%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%89%2F</url>
    <content type="text"><![CDATA[12. SQL1999_table_connections123select ename, dname,grade from emp e,deptd, salgrade swhere e.deptno = d.deptno and e.sal between s.losal and s.hisal and job &lt;&gt; 'CLERK' ​ 有没有办法把过滤条件和连接条件分开来? 出于这样考虑,Sql1999标准推出来了.有许多人用的还是 旧的语法,所以得看懂这种语句. 1234567891011select ename,dname from emp,dept;(旧标准).select ename,dname from emp** cross join** dept;(1999标准)select ename,dname from emp,dept where emp.deptno=dept.deptno (旧)select ename,dname from emp join dept on(emp.deptno = dept.deptno); 1999标准.没有Where语句.select ename,dname from emp join dept using(deptno);等同上句,但不推荐使用.select ename,grade from emp e join salgrade s on(e.sal between s.losal and s.hisal); ​ join 连接语句, on过滤条件。连接，条件一眼分开。如果用Where语句较长时，连接语句和过滤语句混在一起。​ 三张表连接： 1234567slect ename, dname, grade fromemp e join dept d on(e.deptno=d.deptno)join salgrade s on(e.sal between s.losal and s.hisal)where ename not like '_A%'; ​ 把每张表连接 条件不混在一起，然后数据过滤条件全部区分开来。读起来更清晰，更容易懂一点。 123 select e1.ename,e2.ename from emp e1 join emp e2on(e1.mgr = e2.emptno); ​ 左外连接：会把左边这张表多余数据显示出来。 123 select e1.ename,e2.ename from emp e1 left joinemp e2 on(e1.mgr =e2.empno);left 后可加outer ​ 右外连接：把右边这张表多余数据显示出来。 123 select ename,dname from emp e right outer join dept don(e.deptno =d.deptno); outer可以取掉。 ​ 全外连接： 即把左边多余数据，也把右边多余数据拿出来， 123 select ename,dname from emp e full join dept don(e.deptno =d.deptno); PS：所谓的“外”连接，即把多余的数据显示出来。Outer关键字可以省略。 13. 求部门中哪些人的薪水最高123select ename, sal from empjoin (select max(sal) max_sal, deptno from emp group by deptno) ton (emp.sal = t.max_sal and emp.deptno = t.deptno) 14. 求部门平均薪水的等级123select deptno,avg_sal,grade from (select deptno,avg(sal) avg_sal from emp group by deptno)t join salgrade s on(t.avg_sal between s.losal and s.hisal) 15. 求部门平均的薪水的平均等级123select deptno,avg(grade) from (select deptno,ename, grade from emp join salgrade s on(emp.sal between s.losal and s.hisal)) tgroup by deptno 16. 哪些人是经理12select ename from emp where empno in(select mgr from emp);select ename from emp where empno in(select distinct mgr from emp); 17.不准用组函数，求薪水的最高值（面试题）12select distinct sal from emp where sal not in(select distinct e1.sal from emp e1 join emp e2 on (e1.sal&lt;e2.sal)); 18.平均薪水最高的部门编号123456select deptno,avg_sal from(select avg(sal)avg_sal,deptno from emp group by deptno)where avg_sal=(select max(avg_sal)from (select avg(sal) avg_sal,deptno from emp group by deptno)) 19.平均薪水最高的部门名称123456789 select dname from dept where deptno=( select deptno from (select avg(sal)avg_sal,deptno from emp group by deptno) where avg_sal= (select max(avg_sal)from (select avg(sal) avg_sal,deptno from emp group by deptno) ) ) 20.求平均薪水的等级最低的部门的部门名称12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455 --组函数嵌套 --如：平均薪水最高的部门编号，可以E.更简单的方法如下： select deptno,avg_sal from (select avg(sal) avg_sal,deptno from emp group by deptno) where avg_sal = (select max(avg(sal)) from emp group by deptno) 组函数最多嵌套两层 -- 分析： -- 首先求 --1.平均薪水： select avg(sal) from emp group by deptno; -- 2.平均薪水等级： 把平均薪水当做一张表，需要和另外一张表连接salgrade select deptno,grade,avg_sal from ( select deptno,avg(sal) avg_sal from emp group by deptno) t join salgrade s on(t.avg_sal between s.losal and s.hisal) -- 上面结果又可当成一张表。 -- DEPTNO GRADE AVG_SAL -------- ------- ---------- -- 30 3 1566.66667 -- 20 4 2175 -- 10 4 2916.66667 -- 3.求上表平均等级最低值 select min(grade) from ( select deptno,grade,avg_sal from (select deptno,avg(sal) avg_sal from emp group by deptno)t join salgrade s on(t.avg_sal between s.losal and s.hisa) ) -- 4.把最低值对应的2结果的那张表的对应那张表的deptno, 然后把2对应的表和另外一张表做连接。 select dname ,deptno,grade,avg_sal from ( select deptno,grade,avg_sal from (select deptno,avg(sal) avg_sal from emp group by deptno)t join salgrade s on(t.avg_sal between s.losal and s.hisal) ) t1 join dept on (t1.deptno = dept.deptno) where t1.grade = ( select deptno,grade,avg_sal from (select deptno,avg(sal) avg_sal from emp group by deptno) t join salgrade s on(t.avg_sal between s.losal and s.hisal) ) )-- 结果如下： -- DNAME DEPTNO GRADE AVG_SAL-- -------- ------- -------- ---------- SALES 30 3 1566.6667 21. 视图（视图就是一张表，一个字查询）【 ​ 默认scott账户没有创建视图的权限，可通过如下语句授权：​ 首先登陆超级管理员：conn sys/用户密码 as sysdba;​ 授权：grant create table,create view to scott;​ 再以scott账户登陆：conn scott/tiger 】 12345678910111213141516171819202122232425262728-- 20中语句有重复，可以用视图来简化。 conn sys/bjsxt as sysdba; grant create table,create view to scott; conn scott/tiger-- 创建视图： create view v$_dept_avg-sal_info as select deptno,grade,avg_sal from ( select deptno,avg(sal) avg_sal from emp group by deptno)t join salgrade s on 9t.avg_sal between s.losal and s.hisal) -- 然后 select * from v$_dept_avg-sal_info -- 结果如下：-- DEPTNO GRADE AVG_SAL-- -------- ------- ------------ 30 3 1566.66667-- 20 4 2175-- 10 4 2916.66667-- 然后G中查询可以简化成： select dname,t1.deptno,grade,avg_sal from v$_dept_avg-sal_info t1 join dept on t1.deptno =dept.deptno) where t1.grade= ( select min(grade) from v$_dept_avg-sal_info t1 ) 22. 求比普通员工最高薪水还要高的经理人的名称1234567select ename, sal from emp where empno in (select distinct mgr from emp where mgr is not null) and sal &gt; ( select max(sal) from emp where empno not in (select distinct mgr from emp where mgr is not null) ) 23. 面试题：比较效率理论上前一句效率高，但实际上可能Oracle可能会自动对代码优化，所以不见得后一句就会慢。 12select * from emp where deptno = 10 and ename like '%A%'; --效率高，因为将过滤力度大的放在前面select * from emp where ename like '%A% and deptno = 10;]]></content>
      <categories>
        <category>Oracle</category>
      </categories>
      <tags>
        <tag>Oracle sql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Oracle学习笔记(二)]]></title>
    <url>%2F2017%2F07%2F17%2FOracle%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[8. Group by语句//需求:现在想求每个部门的平均薪水. 12345678910111213 select avg(sal) from emp group by deptno; select deptno avg(sal) from emp group by deptno; select deptno,job,max(sal) from emp group by deptno,job; 求薪水值最高的人的名字.select ename,max(sal) from emp;出错,因为max只有一个值,但等于max值的人可能好几个,不能匹配.应如下求:select ename from emp where sal=(select max(sal) from emp);Group by语句应注意,出现在select中的字段,如果没出现在组函数中,必须出现在Group by语句中. 9. Having 对分组结果筛选1Where是对单条纪录进行筛选,Having是对分组结果进行筛选. 12345678910select avg(sal),deptno from emp group by deptno having avg(sal)&gt;2000;查询工资大于1200雇员,按部门编号进行分组,分组后平均薪水大于1500,按工薪倒充排列.select * from emp where sal&gt;1200group by deptnohaving avg(sal)&gt;1500order by avg(sal) desc; 10. 字查询​ 谁挣的钱最多(谁:这个人的名字, 钱最多) 1select 语句中嵌套select 语句,可以在where,from后. ​ 问哪些人工资,在平均工资之上. 1select ename,sal from emp where sal&gt;(select avg(sal) from emp); 1234567891011//查找每个部门挣钱最多的那个人的名字.select ename ,deptno from emp where sal in(select max(sal) from ename group by deptno) //查询会多值.//应该如下:select max(sal),deptno from emp group by deptno;//当成一个表.语句如下:select ename, sal from emp join(select max(sal) max_sal,deptno from emp groupby deptno) t on(emp.sal=t.max_sal and emp.deptno=t.deptno); //每个部门的平均薪水的等级. //分析:首先求平均薪水(当成表),把平均薪水和另外一张表连接. 11. self_table_connection把某个人的名字以及他的经理人的名字求出来(经理人及这个人在表中同处一行) 分析:首先求出这个人的名字,取他的编号,然后从另一张表与其相对应编号,然后找到经理的名字. 1select e1.ename ,e2.ename from emp e1,emp e2 where e1.mgr= e2.empno. //empno编号和MGR都是编号.]]></content>
      <categories>
        <category>Oracle</category>
      </categories>
      <tags>
        <tag>Oracle</tag>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Oracle学习笔记(一)]]></title>
    <url>%2F2017%2F07%2F16%2FOracle%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%80%2F</url>
    <content type="text"><![CDATA[前言12sqlplus sys/所设定的密码 as sysdba(用管理员登陆)alter user scott account unlock;(解锁scott账户) 1. table structure12描述某一张表：desc 表名select * from 表名 2. select 语句1计算数据可以用空表：比如：select 2*3 from dual 1select ename,sal*12 annual_sal from emp;与select ename,sal*12 "annual sal" from emp;区别，加双引号保持原大小写。不加全变大写。 1select ename || "abcd" 如果连接字符串中含有单引号，用两个单引号代替一个单引号。(||代表连接符) 3. distinct123456select deptno from emp;select distinct deptno from emp;select distinct deptno from emp;select distinct deptno ,job from emp去掉deptno,job两者组合的重复。更多的项，就是这么多项的组合的不重复组合。 4. where12345678select * from emp where deptno =10;select * from emp where deptno &lt;&gt;10;不等于10 select * from emp where ename ='bike';select ename,sal from emp where sal between 800 and 1500 (&gt;=800 and &lt;=1500)空值处理:select ename,sal,comm from emp where comm is (not) null;select ename,sal,comm from emp where ename ( not)in ('smith','king','abc');select ename from emp where ename like '_A%';_代表一个字母,%代表0个或多个字母. 如果查询%可用转义字符.\%. 还可以用escape '$'比如:select ename from emp where ename like '%$a%' escape '$'; 5. orderby123select * from dept; select * from dept order by dept desc;(默认:asc)select ename,sal,deptno from emp order by deptno asc,ename desc; 6. sql function11234567891011121314151617181920212223242526272829303132333435363738394041select ename,sal*12 annual_sal from empwhere ename not like '_A%' and sal&gt;800order by sal desc;select lower(ename) from emp;select ename from emp where lower(ename) like '_a%';等同于select ename from emp where ename like '_a%' or ename like '_A%';select substr(ename,2,3) from emp;从第二字符截,一共截三个字符.select chr(65) from dual 结果为:Aselect ascii('a') from dual 结果为:65select round(23.652,1) from dual; 结果为: 23.7select round(23.652,-1) from dual; 20 select to_char(sal,'$99_999_999') from emp;select to_char(sal,'L99_999_999') from emp;人民币符号,L:代表本地符号这个需要掌握牢:select birthdate from emp;显示为:BIRTHDATE----------------17-12月-80----------------改为:select to_char(birthdate,'YYYY-MM-DD HH:MI:SS') from emp;显示: BIRTHDATE-------------------1980-12-17 12:00:00-------------------select to_char(sysdate,'YYYY-MM-DD HH24:MI:SS') from dual; //也可以改为:HH12TO_CHAR(SYSDATE,'YY-------------------2017-07-15 14:46:14 123to_date函数:select ename,birthdate from emp where birthdate &gt; to_date('1981-2-20 12:34:56','YYYY-MM-DD HH24:MI:SS');如果直接写 birthdate&gt;'1981-2-20 12:34:56'会出现格式不匹配,因为表中的格式为: DD-MM月-YY. 123456789select sal from emp where sal&gt;888.88 无错.但select sal from emp where sal&gt;$1,250,00;会出现无效字符错误. 改为:select sal from emp where sal&gt;to_number('$1,250.00','$9,999.99');s把空值改为0select ename,sal*12+nvl(comm,0) from emp;这样可以防止comm为空时,sal*12相加也为空的情况. 7. Group function 组函数1max,min,avg ,count,sum函数 1select to_char(avg(sal),'99999999,99') from emp; 1234567select round(avg(sal),2) from emp;结果:2073.21 select count(*) from emp where deptno=10;select count(ename) from emp where deptno=10; count某个字段,如果这个字段不为空就算一个.select count(distinct deptno) from emp;select sum(sal) from emp;]]></content>
      <categories>
        <category>Oracle</category>
      </categories>
      <tags>
        <tag>Oracle sql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java读书笔记-Thread类]]></title>
    <url>%2F2017%2F07%2F14%2Fjava%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-Thread%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[一、线程的三个常用方法 二、线程死锁图解 Thread1锁住了上面的对象，等待锁住下面的对象来完成执行过程。但是下面的对象被Thread2锁住了，它也等着锁住上面的对象来完成执行，因此陷入了死锁。 三、死锁小程序12345678910111213141516171819202122232425262728293031323334353637383940414243public class TestDeadLock implements Runnable &#123; public int flag = 1; static Object o1 = new Object(), o2 = new Object(); public void run() &#123; System.out.println("flag=" + flag); if(flag == 1) &#123; synchronized(o1) &#123; try &#123; Thread.sleep(500); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; synchronized(o2) &#123; System.out.println("1"); &#125; &#125; &#125; if(flag == 0) &#123; synchronized(o2) &#123; try &#123; Thread.sleep(500); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; synchronized(o1) &#123; System.out.println("0"); &#125; &#125; &#125; &#125; public static void main(String[] args) &#123; TestDeadLock td1 = new TestDeadLock(); TestDeadLock td2 = new TestDeadLock(); td1.flag = 1; td2.flag = 0; Thread t1 = new Thread(td1); Thread t2 = new Thread(td2); t1.start(); t2.start(); &#125;&#125; 四、面试题下面举个小例子： 1234567891011121314151617181920212223242526272829303132public class TT implements Runnable &#123; int b = 100; public synchronized void m1() throws Exception&#123; //Thread.sleep(2000); b = 1000; Thread.sleep(5000); System.out.println("b = " + b); &#125; public void m2() throws Exception &#123; Thread.sleep(2500); b = 2000; &#125; public void run() &#123; try &#123; m1(); &#125; catch(Exception e) &#123; e.printStackTrace(); &#125; &#125; public static void main(String[] args) throws Exception &#123; TT tt = new TT(); Thread t = new Thread(tt); t.start(); tt.m2(); System.out.println(tt.b); &#125;&#125; 上面的输出结果是：2000 五、wait()跟sleep()区别1)wait时别的线程可以访问锁定对象(调用wait方法的时候必须锁定该对象) 2)sleep时别的线程也不可以访问锁定对象 2)Thread.sleep()与Object.wait()二者都可以暂停当前线程，释放CPU控制权，主要的区别在于Object.wait()在释放CPU同时，释放了对象锁的控制，而在同步块中的Thread.sleep()方法并不释放锁，仅释放CPU控制权。 六、wait()跟notify()方法 1)wait()方法与notify()必须要与synchronized(resource)一起使用。(也就是wait与notify针对已经获取了resource锁的线程进行操作，从语法角度来说就是Obj.wait(),Obj.notify必须在synchronized(Obj){...}语句块内。) 2) wait和notify方法均可释放对象的锁，但wait同时释放CPU控制权，即它后面的代码停止执行，线程进入阻塞状态，而notify方法不立刻释放CPU控制权，而是在相应的synchronized(){}语句块执行结束，再自动释放锁。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>Thread</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello Hexo]]></title>
    <url>%2F2017%2F01%2F23%2Fhello-hexo%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>Hexo教程</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>教程</tag>
      </tags>
  </entry>
</search>