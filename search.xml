<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[C语言实现顺序表的基本操作]]></title>
    <url>%2F2017%2F08%2F09%2FC%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[前言 ​ 数据结构老师给了几个接口，叫我们自己去实现顺序表的功能，感想就是顺序表实现起来比链表容易，但是还是要花费挺长的时间来构思，这一次的收获还是挺多的。 编译环境 ​ VS 2015 所用语言 ​ C 实现功能顺序表的初始化及创建 顺序表的遍历 顺序表的增删查改 代码顺序表.h1234567891011121314151617181920212223242526#include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; #include&lt;malloc.h&gt; #define LIST_INIT_SIZE 100 #define LISTINCREMENT 10 #define TRUE 1 #define FLASE 0 typedef int Elemtype; typedef int Status; /*接口定义 Status InitList_Sq(SqList &amp;L,int size,int inc); void CreateList_Sq(SqList &amp;L); void print_Sq(SqList &amp;L); int Search_Sq(SqList L, Elemtype e); Status DestroyList_Sq(SqList &amp;L); Status ClearList_Sq(SqList &amp;L); Status ListEmpty_Sq(SqList L); int ListLength_Sq(SqList L); Status GetElem_Sq(SqList L, int i, Elemtype &amp;e); Status PutElem_Sq(SqList &amp;L, int i, Elemtype e); Status Append_Sq(SqList &amp;L, Elemtype e); Status DeleteLast_Sq(SqList &amp;L, Elemtype &amp;e); */ 源代码.h123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134#include "顺序表.h" //定义顺序表类型 typedef struct &#123; Elemtype *elem; int length; int listsize; int increment; &#125;SqList; //初始化顺序表 Status InitList_Sq(SqList &amp;L,int size,int inc) &#123; L.elem = (Elemtype *)malloc(size * sizeof(Elemtype)); L.length = 0; L.listsize = size; L.increment = inc; return TRUE; &#125; //创建顺序表 Status CreateList_Sq(SqList &amp;L) &#123; int i; printf("请输入你要创建的顺序表元素个数：\n"); scanf_s("%d", &amp;L.length); if (L.length &gt;= L.listsize) &#123; L.elem = (Elemtype *)realloc(L.elem, (L.listsize + L.increment) * sizeof(Elemtype)); &#125; if (!L.elem) &#123; return FLASE; &#125; printf("请输入你要创建的顺序表：\n"); for (i = 0; i&lt;L.length; i++) &#123; scanf_s("%d", &amp;L.elem[i]); &#125; &#125; //遍历顺序表 void print_Sq(SqList &amp;L) &#123; int i; for (i = 0; i&lt;L.length; i++) &#123; printf("%4d", L.elem[i]); &#125; &#125; //查找元素的位置 int Search_Sq(SqList L, Elemtype e) &#123; int i = 0; while (L.elem[i] != e&amp;&amp;i&lt;L.length) &#123; i++; &#125; if (i&gt;L.length) return -1; else return i + 1;//因为C语言是从下标为0开始的，当i=0时表示第一个元素 &#125; //销毁顺序表 Status DestroyList_Sq(SqList &amp;L) &#123; if (L.elem == NULL) return -1; else free(L.elem); printf("\n销毁成功\n"); return TRUE; &#125; //清空顺序表 Status ClearList_Sq(SqList &amp;L) &#123; if (L.elem == NULL) exit(0); int i; Elemtype *p_elem = L.elem; for (i = 0; i&lt;L.length; i++) &#123; *L.elem = NULL; L.elem++; &#125; L.elem = p_elem; &#125; //判断顺序表是否为空 Status ListEmpty_Sq(SqList L) &#123; int i; Elemtype* p_elem = L.elem; for (i = 0; i&lt;L.length; i++) &#123; if (*L.elem != 0) &#123; L.elem = p_elem; return FLASE; &#125; L.elem++; &#125; return TRUE; &#125; //求顺序表的长度 int ListLength_Sq(SqList L) &#123; return L.length; &#125; //用e返回顺序表L中第i个元素的值 Status GetElem_Sq(SqList L, int i, Elemtype &amp;e) &#123; int j; Elemtype* p_elem = L.elem; if (i&lt;1 || i&gt;L.length) return FLASE; for (j = 1; j &lt;= i; j++) L.elem++; e = *L.elem; L.elem = p_elem; return TRUE; &#125; //将顺序表L中第i个元素赋值为e Status PutElem_Sq(SqList &amp;L, int i, Elemtype e) &#123; L.elem[i - 1] = e; return TRUE; &#125; //在顺序表L表尾添加元素e Status Append_Sq(SqList &amp;L, Elemtype e) &#123; L.elem[L.length] = e; L.length++; L.listsize += L.increment; return TRUE; &#125; //删除顺序表L表尾元素 Status DeleteLast_Sq(SqList &amp;L, Elemtype &amp;e) &#123; e = L.elem[L.length - 1]; L.length--; return TRUE; &#125; 主函数.c1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include "顺序表.h" #include "源代码.h" //--------------------主函数入口-------------------- int main()&#123; SqList L; int size, inc; int e; int a; int length; int i; int temp; int j=10; int ee; printf("\n--------------------顺序表初始化------------------\n"); printf("请输入顺序表的长度size以及扩容量：\n"); scanf_s("%d %d", &amp;size, &amp;inc); InitList_Sq(L, size, inc); CreateList_Sq(L); printf("\n--------------------判断是否为空------------------\n"); if(ListEmpty_Sq(L))&#123; printf("该顺序表为空\n"); &#125; else printf("该顺序表不为空\n"); printf("\n--------------------遍历顺序表--------------------\n"); printf("此时顺序表为：\n"); print_Sq(L); printf("\n--------------------查找元素----------------------\n"); printf("\n请输入要查找的元素：\n"); scanf_s("%d",&amp;e); a = Search_Sq(L, e); printf("%d为第%d位：\n",e,a); printf("\n--------------------输出长度----------------------\n"); length = ListLength_Sq(L); printf("顺序表的长度为%d\n",length); printf("\n----------将顺序表L中第i个元素赋值为temp----------\n"); printf("请输入第i个元素的i值和temp值：\n"); scanf_s("%d %d",&amp;i,&amp;temp); PutElem_Sq(L, i, temp); printf("\n此时顺序表为：\n"); print_Sq(L); printf("\n---------------在顺序表表尾添加元素---------------\n"); Append_Sq(L, j); printf("\n此时顺序表为：\n"); print_Sq(L); printf("\n---------------在顺序表表尾删除元素---------------\n"); DeleteLast_Sq(L, ee); printf("\n被删除的元素为%d\n",ee); printf("此时顺序表为：\n"); print_Sq(L); printf("\n-------------------清空顺序表---------------------\n"); ClearList_Sq(L); if(ListEmpty_Sq(L))&#123; printf("\n清空成功\n"); &#125; printf("\n------------------销毁顺序表----------------------\n"); DestroyList_Sq(L); getchar(); getchar(); return 0; &#125; 总结​ 经过这次的实践，较为深刻的理解了顺序表的结构以及基本操作。]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>Sequerce</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node.js读书笔记]]></title>
    <url>%2F2017%2F08%2F07%2FNode-js%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[一些NPM常用命令 NPM提供了很多命令，例如install和publish，使用npm help可查看所有命令。 使用npm help &lt;command&gt;可查看某条命令的详细帮助，例如npm help install。 在package.json所在目录下使用npm install . -g可先在本地安装当前命令行程序，可用于发布前的本地测试。 使用npm update &lt;package&gt;可以把当前目录下node_modules子目录里边的对应模块更新至最新版本。 使用npm update &lt;package&gt; -g可以把全局安装的对应命令行程序更新至最新版。 使用npm cache clear可以清空NPM本地缓存，用于对付使用相同版本号发布新版本代码的人。 使用npm unpublish &lt;package&gt;@&lt;version&gt;可以撤销发布自己发布过的某个版本代码。 文件操作小文件拷贝1234567891011var fs = require('fs');function copy(src, dst) &#123; fs.writeFileSync(dst, fs.readFileSync(src));&#125;function main(argv) &#123; copy(argv[0], argv[1]);&#125;main(process.argv.slice(2)); 豆知识： process是一个全局变量，可通过process.argv获得命令行参数。由于argv[0]固定等于NodeJS执行程序的绝对路径，argv[1]固定等于主模块的绝对路径，因此第一个命令行参数从argv[2]这个位置开始。 大文件拷贝1234567891011var fs = require('fs');function copy(src, dst) &#123; fs.createReadStream(src).pipe(fs.createWriteStream(dst));&#125;function main(argv) &#123; copy(argv[0], argv[1]);&#125;main(process.argv.slice(2)); 防止数据流内部的缓存爆仓12345678910111213141516var rs = fs.createReadStream(src);var ws = fs.createWriteStream(dst);rs.on('data', function (chunk) &#123; if (ws.write(chunk) === false) &#123; rs.pause(); &#125;&#125;);rs.on('end', function () &#123; ws.end();&#125;);ws.on('drain', function () &#123; rs.resume();&#125;); 如果写入速度跟不上读取速度的话，只写数据流内部的缓存会爆仓。我们可以根据.write方法的返回值来判断传入的数据是写入目标了，还是临时放在了缓存了，并根据drain事件来判断什么时候只写数据流已经将缓存中的数据写入目标，可以传入下一个待写数据了。 遍历文件目录同步遍历1234567891011efunction travel(dir, callback) &#123; fs.readdirSync(dir).forEach(function (file) &#123; var pathname = path.join(dir, file); if (fs.statSync(pathname).isDirectory()) &#123; travel(pathname, callback); &#125; else &#123; callback(pathname); &#125; &#125;);&#125; 异步遍历1234567891011121314151617181920212223function travel(dir, callback, finish) &#123; fs.readdir(dir, function (err, files) &#123; (function next(i) &#123; if (i &lt; files.length) &#123; var pathname = path.join(dir, files[i]); fs.stat(pathname, function (err, stats) &#123; if (stats.isDirectory()) &#123; travel(pathname, callback, function () &#123; next(i + 1); &#125;); &#125; else &#123; callback(pathname, function () &#123; next(i + 1); &#125;); &#125; &#125;); &#125; else &#123; finish &amp;&amp; finish(); &#125; &#125;(0)); &#125;);&#125;]]></content>
      <categories>
        <category>node.js</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>node.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node.js 循环的陷阱]]></title>
    <url>%2F2017%2F08%2F03%2F%E5%BE%AA%E7%8E%AF%E7%9A%84%E9%99%B7%E9%98%B1%2F</url>
    <content type="text"><![CDATA[前言&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Node.js 的异步机制由事件和回调函数实现，一开始接触可能会感觉违反常规，但习惯以后就会发现还是很简单的。然而这之中其实暗藏了不少陷阱，一个很容易遇到的问题就是循环中的回调函数，初学者经常容易陷入这个圈套。 例1让我们从一个例子开始说明这个问题。//forloop.js 123456789var fs = require('fs'); var files = ['a.txt', 'b.txt', 'c.txt']; for (var i = 0; i &lt; files.length; i++) &#123; fs.readFile(files[i], 'utf-8', function(err, contents) &#123; console.log(files[i] + ': ' + contents); &#125;); &#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这段代码的功能很直观，就是依次读取文件 a.txt、b.txt、c.txt，并输出文件名和内容。假设这三个文件的内容分别是 AAA、BBB 和 CCC，那么我们期望的输出结果就是： 12345a.txt: AAA b.txt: BBB c.txt: CCC 可是我们运行这段代码的结果是怎样的呢？竟然是这样的结果： 12345undefined: AAA undefined: BBB undefined: CCC &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个结果说明文件内容正确输出了，而文件名却不对，也就意味着， contents 的结果是正确的，但 files[i] 的值是 undefined 。这怎么可能呢，文件名不正确却能读取文件内容？ 例2既然难以直观地理解，我们就把 files[i] 分解并打印出来看看，在读取文件的回调函数中分别输出 files 、 i 和 files[i] 。 123456789101112//forloopi.js var fs = require('fs'); var files = ['a.txt', 'b.txt', 'c.txt']; for (var i = 0; i &lt; files.length; i++) &#123; fs.readFile(files[i], 'utf-8', function(err, contents) &#123; console.log(files); console.log(i); console.log(files[i]); &#125;); &#125; 运行修改后的代码，结果如下： 123456789[ 'a.txt', 'b.txt', 'c.txt' ] 3 undefined [ 'a.txt', 'b.txt', 'c.txt' ] 3 undefined [ 'a.txt', 'b.txt', 'c.txt' ] 3 undefined &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;看到这里是不是有点启发了呢？三次输出的 i 的值都是 3，超出了 files 数组的下标范围，因此 files[i] 的值就是 undefined 了。这种情况通常会在 for 循环结束时发生，例如 for (var i = 0; i &lt; files.length; i++) ，退出循环时 i 的值就是 files.length 的值。既然 i 的值是 3，那么说明了事实上 fs.readFile 的回调函数中访问到的 i 值都是循环退出以后的，因此不能分辨。而 files[i] 作为 fs.readFile 的第一个参数在循环中就传递了，所以文件可以被定位到，而且可以显示出文件的内容。 现在问题就明朗了：原因是3次读取文件的回调函数事实上是同一个实例，其中引用到的 i 值是上面循环执行结束后的值，因此不能分辨。 例3如何解决这个问题呢？我们可以利用 JavaScript 函数式编程的特性，手动建立一个闭包： 123456789101112//forloopclosure.js var fs = require('fs'); var files = ['a.txt', 'b.txt', 'c.txt']; for (var i = 0; i &lt; files.length; i++) &#123; (function(i) &#123; fs.readFile(files[i], 'utf-8', function(err, contents) &#123; console.log(files[i] + ': ' + contents); &#125;); &#125;)(i); &#125; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上面代码在 for 循环体中建立了一个匿名函数，将循环迭代变量 i 作为函数的参数传递并调用。由于运行时闭包的存在，该匿名函数中定义的变量（包括参数表）在它内部的函数（ fs.readFile 的回调函数）执行完毕之前都不会释放，因此我们在其中访问到的 i 就分别是不同闭包实例，这个实例是在循环体执行的过程中创建的，保留了不同的值。 事实上以上这种写法并不常见，因为它降低了程序的可读性，故不推荐使用。 例4大多数情况下我们可以用数组的 forEach 方法解决这个问题： 12345678910//callbackforeach.js var fs = require('fs'); var files = ['a.txt', 'b.txt', 'c.txt']; files.forEach(function(filename) &#123; fs.readFile(filename, 'utf-8', function(err, contents) &#123; console.log(filename + ': ' + contents); &#125;); &#125;);]]></content>
      <categories>
        <category>node.js</category>
      </categories>
      <tags>
        <tag>node.js</tag>
        <tag>异步机制</tag>
        <tag>循环</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何解决node.js中fs.rename文件跨域问题]]></title>
    <url>%2F2017%2F07%2F31%2F%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3node-js%E4%B8%ADfs-rename%E6%96%87%E4%BB%B6%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[前言&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最近在学习node.js，今天在写一个文件上传的功能，调用fs.rename上传文件时程序报了错。 具体如下： 123Error: EXDEV: cross-device link not permitted, rename 'C:\Users\Simple_Y\AppData\Local\Temp\12920-ww17q9.vtx0mb1emi.jpg' -&gt; 'E:\杨宇杰_备份2\光盘资源\Node.js实战\code\8\photo_app\public\photos\281295.jpg' at Error (native) 大致意思应该是说不能跨盘符上传文件，涉及到权限问题。 问题代码下面贴出我的代码(部分)： 12345678exports.submit = function (dir) &#123; return function(req, res, next)&#123; var img = req.files.photo.image; var name = req.body.photo.name || img.name; var path = join(dir, img.name); //fs.rename(img.path, path, function(err)&#123; //if (err) return next(err); 解决办法经过百度，终于找到了解决办法： 将上面的注释掉的两行代码换成下面的代码 1234567891011121314151617fs.readFile(img.path, function (err, data) &#123; if (err) throw err; console.log('File read!'); // Write the file fs.writeFile(path, data, function (err) &#123; if (err) throw err; res.write('File uploaded and moved!'); res.end(); console.log('File written!'); &#125;); // Delete the file fs.unlink(img.path, function (err) &#123; if (err) throw err; console.log('File deleted!'); &#125;); 结尾至此，运行程序，问题完美解决。 感谢万能的百度！ 参考链接：https://stackoverflow.com/questions/37153666/error-exdev-cross-device-link-not-permitted-rename-tmp-on-ubuntu-16-04-lts]]></content>
      <categories>
        <category>node.js</category>
      </categories>
      <tags>
        <tag>node.js</tag>
        <tag>fs.rename</tag>
        <tag>文件跨域</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何理解javascript中的闭包]]></title>
    <url>%2F2017%2F07%2F24%2F%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3javascript%E4%B8%AD%E7%9A%84%E9%97%AD%E5%8C%85%2F</url>
    <content type="text"><![CDATA[闭包（closure）是Javascript语言的一个难点，也是它的特色，很多高级应用都要依靠闭包实现。 一、变量的作用域要理解闭包，首先必须理解Javascript特殊的变量作用域。 变量的作用域无非就是两种：全局变量和局部变量。 Javascript语言的特殊之处，就在于函数内部可以直接读取全局变量。 Js代码 123456var n=999; function f1()&#123; alert(n); &#125; f1(); // 999 另一方面，在函数外部自然无法读取函数内的局部变量。 Js代码 12345function f1()&#123; var n=999; &#125; alert(n); // error 这里有一个地方需要注意，函数内部声明变量的时候，一定要使用var命令。如果不用的话，你实际上声明了一个全局变量！ Js代码 1234567 function f1()&#123; n=999; &#125; f1(); alert(n); // 999 二、如何从外部读取局部变量？出于种种原因，我们有时候需要得到函数内的局部变量。但是，前面已经说过了，正常情况下，这是办不到的，只有通过变通方法才能实现。 那就是在函数的内部，再定义一个函数。 Js代码 123456 function f1()&#123; n=999; function f2()&#123; alert(n); // 999 &#125; &#125; 在上面的代码中，函数f2就被包括在函数f1内部，这时f1内部的所有局部变量，对f2都是可见的。但是反过来就不行，f2内部的局部变量，对f1 就是不可见的。这就是Javascript语言特有的“链式作用域”结构（chain scope）， 子对象会一级一级地向上寻找所有父对象的变量。所以，父对象的所有变量，对子对象都是可见的，反之则不成立。 既然f2可以读取f1中的局部变量，那么只要把f2作为返回值，我们不就可以在f1外部读取它的内部变量了吗！ Js代码 12345678910 function f1()&#123; n=999; function f2()&#123; alert(n); &#125; return f2; &#125; var result=f1(); result(); // 999 三、闭包的概念上一节代码中的f2函数，就是闭包。 各种专业文献上的“闭包”（closure）定义非常抽象，很难看懂。我的理解是，闭包就是能够读取其他函数内部变量的函数。 由于在Javascript语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成“定义在一个函数内部的函数”。 所以，在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。 四、闭包的用途闭包可以用在许多地方。它的最大用处有两个，一个是前面提到的可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中。 怎么来理解这句话呢？请看下面的代码。 Js代码 12345678910111213141516 function f1()&#123; var n=999; nAdd=function()&#123;n+=1&#125; function f2()&#123; alert(n); &#125; return f2; &#125; var result=f1(); result(); // 999 nAdd(); result(); // 1000 在这段代码中，result实际上就是闭包f2函数。它一共运行了两次，第一次的值是999，第二次的值是1000。这证明了，函数f1中的局部变量n一直保存在内存中，并没有在f1调用后被自动清除。 为什么会这样呢？原因就在于f1是f2的父函数，而f2被赋给了一个全局变量，这导致f2始终在内存中，而f2的存在依赖于f1，因此f1也始终在内存中，不会在调用结束后，被垃圾回收机制（garbage collection）回收。 这段代码中另一个值得注意的地方，就是“nAdd=function(){n+=1}”这一行，首先在nAdd前面没有使用var关键字，因此 nAdd是一个全局变量，而不是局部变量。其次，nAdd的值是一个匿名函数（anonymous function），而这个 匿名函数本身也是一个闭包，所以nAdd相当于是一个setter，可以在函数外部对函数内部的局部变量进行操作。 五、使用闭包的注意点1）由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。 2）闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便 改变父函数内部变量的值。 六、思考题如果你能理解下面代码的运行结果，应该就算理解闭包的运行机制了。 Js代码 123456789101112 var name = "The Window"; var object = &#123; name : "My Object", getNameFunc : function()&#123; return function()&#123; return this.name; &#125;; &#125; &#125;; alert(object.getNameFunc()()); //The Window 常见的陷阱 看看这个： 乍一看，以为输出 0~9 ，万万没想到输出10个10？ 这里的陷阱就是：函数带()才是执行函数！ 单纯的一句 var f = function() { alert(‘Hi’); }; 是不会弹窗的，后面接一句 f(); 才会执行函数内部的代码。上面代码翻译一下就是： 为什么只垃圾回收了 result，但却不收了 i 呢？ 因为 i 还在被 function 引用着啊。好比一个餐厅，盘子总是有限的，所以服务员会去巡台回收空盘子，但还装着菜的盘子他怎么敢收？ 当然，你自己手动倒掉了盘子里面的菜（=null），那盘子就会被收走了，这就是所谓的内存回收机制。 至于 i 的值怎么还能保留，其实从文章开头一路读下来，这应该没有什么可以纠结的地方。盘子里面的菜，吃了一块不就应该少一块吗？ JavaScript闭包例子 12345678910function outerFun()&#123; var a=0; function innerFun() &#123; a++; alert(a); &#125; &#125;innerFun(); 上面的代码是错误的.innerFun()的作用域在outerFun()内部,所在outerFun()外部调用它是错误的. 改成如下,也就是闭包: Js代码 123456789101112131415161718192021function outerFun()&#123; var a=0; function innerFun() &#123; a++; alert(a); &#125; return innerFun; //注意这里&#125;var obj=outerFun();obj(); //结果为1obj(); //结果为2var obj2=outerFun();obj2(); //结果为1obj2(); //结果为2 什么是闭包: 当内部函数 在定义它的作用域 的外部 被引用时,就创建了该内部函数的闭包 ,如果内部函数引用了位于外部函数的变量,当外部函数调用完毕后,这些变量在内存不会被 释放,因为闭包需要它们. 再来看一个例子 Js代码 123456789function outerFun()&#123; var a =0; alert(a); &#125;var a=4;outerFun();alert(a); 结果是 0,4 . 因为在函数内部使用了var关键字 维护a的作用域在outFun()内部. 再看下面的代码: Js代码 1234567891011function outerFun()&#123; //没有var a =0; alert(a); &#125;var a=4;outerFun();alert(a); 结果为 0,0 真是奇怪,为什么呢? 作用域链是描述一种路径的术语,沿着该路径可以确定变量的值 .当执行a=0时,因为没有使用var关键字,因此赋值操作会沿着作用域链到var a=4; 并改变其值. -————————————————————————————————————————————————- 如果你对javascript闭包还不是很理解，那么请看下面转载的文章：(转载:http://www.felixwoo.com/archives/247) 七、什么是闭包？官方”的解释是：闭包是一个拥有许多变量和绑定了这些变量的环境的表达式（通常是一个函数），因而这些变量也是该表达式的一部分。相信很少有人能直接看懂这句话，因为他描述的太学术。其实这句话通俗的来说就是：JavaScript中所有的function都是一个闭包。不过一般来说，嵌套的function所产生的闭包更为强大，也是大部分时候我们所谓的“闭包”。看下面这段代码： 1234567function a() &#123; var i = 0; function b() &#123; alert(++i); &#125; return b;&#125;var c = a();c(); 这段代码有两个特点： 1、函数b嵌套在函数a内部； 2、函数a返回函数b。 引用关系如图： 这样在执行完var c=a()后，变量c实际上是指向了函数b，再执行c()后就会弹出一个窗口显示i的值(第一次为1)。这段代码其实就创建了一个闭包，为什么？因为函数a外的变量c引用了函数a内的函数b，就是说： 当函数a的内部函数b被函数a外的一个变量引用的时候，就创建了一个闭包。 让我们说的更透彻一些。所谓“闭包”，就是在构造函数体内定义另外的函数作为目标对象的方法函数，而这个对象的方法函数反过来引用外层函数体中的临时变量。这使得只要目标 对象在生存期内始终能保持其方法，就能间接保持原构造函数体当时用到的临时变量值。尽管最开始的构造函数调用已经结束，临时变量的名称也都消失了，但在目 标对象的方法内却始终能引用到该变量的值，而且该值只能通这种方法来访问。即使再次调用相同的构造函数，但只会生成新对象和方法，新的临时变量只是对应新 的值，和上次那次调用的是各自独立的。 八、闭包有什么作用？ 简而言之，闭包的作用就是在a执行完并返回后，闭包使得Javascript的垃圾回收机制GC不会收回a所占用的资源，因为a的内部函数b的执行需要依赖a中的变量。这是对闭包作用的非常直白的描述，不专业也不严谨，但大概意思就是这样，理解闭包需要循序渐进的过程。 在上面的例子中，由于闭包的存在使得函数a返回后，a中的i始终存在，这样每次执行c()，i都是自加1后alert出i的值。 那 么我们来想象另一种情况，如果a返回的不是函数b，情况就完全不同了。因为a执行完后，b没有被返回给a的外界，只是被a所引用，而此时a也只会被b引 用，因此函数a和b互相引用但又不被外界打扰(被外界引用)，函数a和b就会被GC回收。(关于Javascript的垃圾回收机制将在后面详细介绍) 九、闭包内的微观世界 如果要更加深入的了解闭包以及函数a和嵌套函数b的关系，我们需要引入另外几个概念：函数的执行环境(excution context)、活动对象(call object)、作用域(scope)、作用域链(scope chain)。以函数a从定义到执行的过程为例阐述这几个概念。 当定义函数a的时候，js解释器会将函数a的作用域链(scope chain)设置为定义a时a所在的“环境”，如果a是一个全局函数，则scope chain中只有window对象。 当执行函数a的时候，a会进入相应的执行环境(excution context)。 在创建执行环境的过程中，首先会为a添加一个scope属性，即a的作用域，其值就为第1步中的scope chain。即a.scope=a的作用域链。 然后执行环境会创建一个活动对象(call object)。活动对象也是一个拥有属性的对象，但它不具有原型而且不能通过JavaScript代码直接访问。创建完活动对象后，把活动对象添加到a的作用域链的最顶端。此时a的作用域链包含了两个对象：a的活动对象和window对象。 下一步是在活动对象上添加一个arguments属性，它保存着调用函数a时所传递的参数。 最后把所有函数a的形参和内部的函数b的引用也添加到a的活动对象上。在这一步中，完成了函数b的的定义，因此如同第3步，函数b的作用域链被设置为b所被定义的环境，即a的作用域。 到此，整个函数a从定义到执行的步骤就完成了。此时a返回函数b的引用给c，又函数b的作用域链包含了对函数a的活动对象的引用，也就是说b可以访问到a中定义的所有变量和函数。函数b被c引用，函数b又依赖函数a，因此函数a在返回后不会被GC回收。 当函数b执行的时候亦会像以上步骤一样。因此，执行时b的作用域链包含了3个对象：b的活动对象、a的活动对象和window对象，如下图所示： 如图所示，当在函数b中访问一个变量的时候，搜索顺序是： 先搜索自身的活动对象，如果存在则返回，如果不存在将继续搜索函数a的活动对象，依次查找，直到找到为止。 如果函数b存在prototype原型对象，则在查找完自身的活动对象后先查找自身的原型对象，再继续查找。这就是Javascript中的变量查找机制。 如果整个作用域链上都无法找到，则返回undefined。 小结，本段中提到了两个重要的词语：函数的定义与执行。文中提到函数的作用域是在定义函数时候就已经确定，而不是在执行的时候确定（参看步骤1和3）。用一段代码来说明这个问题： 123456function f(x) &#123; var g = function () &#123; return x; &#125; return g;&#125;var h = f(1);alert(h()); 这段代码中变量h指向了f中的那个匿名函数(由g返回)。 假设函数h的作用域是在执行alert(h())确定的，那么此时h的作用域链是：h的活动对象-&gt;alert的活动对象-&gt;window对象。 假设函数h的作用域是在定义时确定的，就是说h指向的那个匿名函数在定义的时候就已经确定了作用域。那么在执行的时候，h的作用域链为：h的活动对象-&gt;f的活动对象-&gt;window对象。 如果第一种假设成立，那输出值就是undefined；如果第二种假设成立，输出值则为1。 运行结果证明了第2个假设是正确的，说明函数的作用域确实是在定义这个函数的时候就已经确定了。 十、闭包的应用场景保护函数内的变量安全。以最开始的例子为例，函数a中i只有函数b才能访问，而无法通过其他途径访问到，因此保护了i的安全性。 在内存中维持一个变量。依然如前例，由于闭包，函数a中i的一直存在于内存中，因此每次执行c()，都会给i自加1。 通过保护变量的安全实现JS私有属性和私有方法（不能被外部访问） ​ 私有属性和方法在Constructor外是无法被访问的 12345678function Constructor(...) &#123; var that = this; var membername = value; function membername(...) &#123;...&#125;&#125; 以上3点是闭包最基本的应用场景，很多经典案例都源于此。 十一、Javascript的垃圾回收机制在Javascript中，如果一个对象不再被引用，那么这个对象就会被GC回收。如果两个对象互相引用，而不再被第3者所引用，那么这两个互相引用的对象也会被回收。因为函数a被b引用，b又被a外的c引用，这就是为什么函数a执行后不会被回收的原因。 十二、结语理解JavaScript的闭包是迈向高级JS程序员的必经之路，理解了其解释和运行机制才能写出更为安全和优雅的代码。]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>闭包</tag>
        <tag>funtion</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VMwave Workstation12虚拟机安装OS X 10.11所遇到的各种问题集合(详细版)]]></title>
    <url>%2F2017%2F07%2F24%2F10-11%E6%89%80%E9%81%87%E5%88%B0%E7%9A%84%E5%90%84%E7%A7%8D%E9%97%AE%E9%A2%98%E9%9B%86%E5%90%88-%E8%AF%A6%E7%BB%86%E7%89%88%2F</url>
    <content type="text"><![CDATA[一、前言最近笔者闲着无聊，由于一直挺仰慕mac大法，所以想装个mac系统来玩玩。虽然说过程不是很难，但是出现的各种小问题还是挺多的，所以在这里跟大家分享一下我的解决方法。 1.首先，当然是安装工具： Mac OS X 10.11 镜像文件（链接：http://pan.baidu.com/s/1pL8HE59 密码：cq4d）（此镜像为网络收集，如果觉得有问题自己找谢谢。） unlocker208文件（链接：http://pan.baidu.com/s/1bpftVjT 密码：dp2g） VMware Workstation12（http://blog.sina.com.cn/s/blog_af49f8090102wqmw.html） 2.详细教程请查看：http://jingyan.baidu.com/article/363872ec206a356e4ba16f30.html 在这里我就不再赘述。 二、所遇到的问题下面来看看我安装后遇到的各种问题： 1) VMware上MAC虚拟机不能上网问题首先最大的问题当然就是没网啦，别急，且听我慢慢道来： 解决方法/步骤1.从本机中选择打开连接网络，选择本地连接。如果是无线网可以选择无线网。 2.选择属性，点击共享按钮。 3.将internet连接共享下面两个选项都选中，然后在家庭网络连接选择VMware Network Adapter VMnet1。 4.在安装的虚拟机中选择虚拟机-&gt;设置选项。 5.点击网络适配器，将网络连接改成仅主机模式（Host-only），然后在右侧选择主机模式，点击确定。 6.进入Mac系统，选择设置，进入网络设置 7.配置Ipv4选择设置DHCP，点击应用即可开始上网。2)OS X 10.11 El Capitan 无法连接Apple store 和登录Apple ID的问题1.step 1强制退出Apple store进程 2. step 2打开terminal终端（在launch中搜索终端），输入以下命令： 123sudo pkill -9 -f Account sudo rm $HOME/Library/Accounts/* 进行此操作时需要提供管理员密码，输入密码敲回车就行了。 3.step 3完成前面两步你已经可以进入apple store了，但是你发现你的apple ID无法登陆： This action cant be Completed! 这时你可以terminal终端输入以下命令： 12345sudo mkdir -p /Users/Shared sudo chown root:wheel /Users/Shared sudo chmod -R 1777 /Users/Shared 至此，你的Apple ID就可以在Apple store上Login了。 3)苹果ID注册最后一步总是显示 如需帮助，请联系iTunes支持由于我的apple id是刚刚注册的，登陆apple store后提示我还没有完善资料什么的，所以我就去填资料 填完资料发现老是出现上面的那一句，继续不了。 所以我又开始了尝试 1.首先在iTunes软件上面注册Apple ID帐号时，注意要把提供付款方式选择为“银联UnionPay”，目前因为iTunes软件版本更新了不能像以前那样不绑定银行卡就可以注册Apple ID帐号。 2.然后填写银行卡以及输入银行预留手机号码。(注意：手机号码一定是要和银行卡绑定在一起的才可以使用。) 3.接下来在帐单寄送地址下方依次将个人的姓、名、街道地址、所在地区、邮编、省份、手机号码填写正确完整。 4.点击创建Apple ID，进入下一步。 5.然后收取绑定银行的短信验证码输入里面进行验证。 填入验证码就可以完美解决，我也试过用银行卡的方式，但是还是不行，最后尝试了银联这个就OK了。 三、补充对了，补充一下，可能安装后会发现虚拟机没办法占全屏，只要安装VMwave Tools既可以完美解决，至于卡顿问题，我笔记本是8G内存，我分了4G在虚拟机，相对来说比较不卡，也可以下载一个叫做beamoff的工具,在mac osx下解压即可消除卡顿的感觉。 下载链接 : http://download.csdn.NET/detail/u013803262/9702291 具体解决方法参考：http://blog.csdn.net/u013803262/article/details/53467693 好了，以上就是我装mac虚拟机所遇到的比较难缠的问题，分享给大家一下。]]></content>
      <categories>
        <category>装系统</category>
      </categories>
      <tags>
        <tag>VMwave</tag>
        <tag>OS X 10.11</tag>
        <tag>虚拟机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[将应用程序部署到Heroku]]></title>
    <url>%2F2017%2F07%2F22%2F%E5%B0%86%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E9%83%A8%E7%BD%B2%E5%88%B0Heroku%2F</url>
    <content type="text"><![CDATA[1.注册1.1在http://api/heroku.com/signup注册Hero帐号 1.2访问邮件中的链接并输入密码 1.3从 http://devcenter.heroku.com/articles/quickstart#step_2_install_the_heroku_toolbelt 为你的平台安装安装程序。 1.4打开终端窗口并登陆到Heroku 1heroku login 2.配置12345678910111213141516171.在app.js文件的顶部，添加如下行：var port = (process.env.PORT || 3000);2.将下列行从app.js中移除:app.listen(3000);3.用下列行替换它：app.listen(port);4.在应用程序的根目录中，添加一个名为Procfile的文件并加入如下内容：web: node app.js5.用如下命令安装依赖模块：npm install6.启动应用程序并检查其是否运行正常：node app.js 3.将应用程序提交到heroku1234567891011123.1使用如下命令创建Git库：git initgit add .git commit -m &quot;initial commit&quot;3.2使用如下命令在Heroku上创建应用程序。注意从这一命令返回的URL:heroku create --stack cedar3.3用如下命令将站点发布到Heroku：git push heroku master3.4访问之前得到的URL，可看到所部署的网站了！]]></content>
      <categories>
        <category>node.js</category>
      </categories>
      <tags>
        <tag>node.js</tag>
        <tag>Heroku</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Oracle学习笔记(六)]]></title>
    <url>%2F2017%2F07%2F20%2FOracle%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%85%AD%2F</url>
    <content type="text"><![CDATA[46.异常(1)12345678910111213141516171819declare v_temp number(4); begin select empno into v_temp from emp where deptno = 10; exception when too_many_rows then dbms_output.put_line('太多记录了'); when others then dbms_output.put_line('error'); end; (2)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475 declare v_tempnumber(4); begin select empno into v_temp from emp where empno = 2222; exception when no_data_found then dbms_output.put_line('没有该项数据'); end;----------------错误记录日志(用表记录：将系统日志存到数据库便于以后查看) ----------- 创建序列（用来处理递增的ＩＤ）： create sequence seq_errorlog_id start with 1 increment by 1; 创建日志表: create table errorlog ( id number primary key, errcode number, errmsg varchar2(1024), errdate date ); 示例程序： declare v_deptno dept.deptno%type := 10; v_errcode number; v_errmsg varchar2(1024); begin delete from dept where deptno = v_deptno; commit; exception when others then rollback; v_errcode:= SQLCODE; v_errmsg:= SQLERRM; insert into errorlog values (seq_errorlog_id.nextval, v_errcode,v_errmsg, sysdate); commit; end; 47. PL/SQL中的重点cursor(游标)和指针的概念差不多123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293declare cursorc isselect * from emp; //此处的语句不会立刻执行，而是当下面的open c的时候，才会真正去数据库中取数据 v_emp c%rowtype; begin open c; fetch c into v_emp;dbms_output.put_line(v_emp.ename); //这样会只输出一条数据 134将使用循环的方法输出每一条记录 close c; end;----------------------使用do while 循环遍历游标中的每一个数据--------------------- declare cursor c is select* from emp; v_emp c%rowtype; begin open c; loop fetch c into v_emp;(1) exit when(c%notfound); //notfound是oracle中的关键字，作用是判断是否还有下一条数据(2) dbms_output.put_line(v_emp.ename); //(1)(2)的顺序不能颠倒，否则会把最后一条结果再多打印一次。 end loop; close c; end;------------------------使用while循环，遍历游标--------------------- declare cursor c is select* from emp; v_emp emp%rowtype; begin open c; fetch c into v_emp; while(c%found) loop dbms_output.put_line(v_emp.ename); fetch c into v_emp; end loop; close c; end;s------------------------使用for 循环，遍历游标（最方便快捷的方法！）----------------- declare cursorc is select * from emp; begin for v_emp in c loop dbms_output.put_line(v_emp.ename); endloop; end; 带参数的游标（相当于函数）1234567891011121314151617declare cursor c(v_deptno emp.deptno%type, v_job emp.job%type) is select ename, sal from emp where deptno=v_deptno and job=v_job; begin forv_temp in c(30, 'CLERK') loop dbms_output.put_line(v_temp.ename); endloop;end; 可更新的游标123456789101112131415161718192021222324252627declare cursorc is select * from emp2 for update; begin for v_temp in c loop if(v_temp.sal&lt; 2000) then update emp2 set sal = sal * 2 where current of c; elsif (v_temp.sal =5000) then deletefrom emp2 where current of c; end if; end loop; commit; end; 48. store procedure存储过程(带有名字的程序块)12345678910111213141516171819202122232425262728293031323334353637383940414243createor replace procedure p is--除了这两句替代declare，下面的语句全部都一样 cursor c is select * from emp2 for update; begin for v_emp in c loop if(v_emp.deptno= 10) then updateemp2 set sal = sal +10 where current of c; elseif(v_emp.deptno =20) then updateemp2 set sal = sal + 20 where current ofc; else updateemp2 set sal = sal + 50 where current of c; endif; end loop; commit; end; 执行存储过程的两种方法： （1）exec p;(p是存储过程的名称) （2）begin p; end; / 带参数的存储过程先创建存储过程：（in标识传入参数，out标识传出参数，默认为传入参数） 12345678910111213141516171819202122232425262728293031323334353637383940414243 createor replace procedure p (v_ain number, v_b number, v_ret out number, v_temp inout number) is begin if(v_a&gt; v_b) then v_ret:= v_a; else v_ret:= v_b; endif; v_temp:= v_temp + 1; end;再调用： declare v_a number := 3; v_b number := 4; v_retnumber; v_tempnumber := 5; begin p(v_a,v_b, v_ret, v_temp); dbms_output.put_line(v_ret); dbms_output.put_line(v_temp); end; 删除存储过程​ dropprocedure p; 49. 创建函数计算个人所得税的税率12345678910111213141516171819202122232425createor replace function sal_tax (v_sal number) returnnumber is begin if(v_sal&lt; 2000) then return0.10; elsif(v_sal&lt;2750) then return0.15; else return0.20; endif; end; 50. 创建触发器（trigger）触发器不能单独的存在，必须依附在某一张表上 写主语 谓语 宾语 游戏 ​ 创建触发器的依附表： 1234567891011121314151617181920212223242526272829303132 createtable emp2_log ( enamevarchar2(30) , eactionvarchar2(20), etimedate ); create or replace trigger trigafter insert or delete orupdate on emp2 for each row --加上此句，每更新一行，触发一次，不加入则值触发一次 begin ifinserting then insertinto emp2_log values(USER, 'insert', sysdate); elsifupdating then insertinto emp2_log values(USER, 'update', sysdate); elsifdeleting then insertinto emp2_log values(USER, 'delete', sysdate); endif; end; 51.触发器用法之一：通过触发器更新约束的相关数据12345678910111213createor replace trigger trig afterupdate on dept foreach row begin updateemp set deptno =:NEW.deptno where deptno =: OLD.deptno; end; --只编译不显示的解决办法 set serveroutput on; 52.通过创建存储过程完成递归123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263 createor replace procedure p(v_pid article.pid%type,v_level binary_integer) is cursorc is select * from article where pid = v_pid; v_preStrvarchar2(1024) := ''; begin for i in 0..v_leave loop v_preStr:= v_preStr || ''; end loop; for v_article in c loop dbms_output.put_line(v_article.cont); if(v_article.isleaf= 0) then p(v_article.id); endif; endloop; end;-------------------------------查看当前用户下有哪些表--- 首先，用这个用户登录然后使用语句： select* from tab; -----------------------------用Oracle进行分页！-------------- 因为Oracle中的隐含字段rownum不支持'&gt;'所以： select* from ( selectrownum rn, t.* from ( select* from t_user where user_id &lt;&gt; 'root' )t where rownum &lt;6 )where rn &gt;3------------------------Oracle下面的清屏命令---------------- clearscreen; 或者 cle scr; -----------将创建好的guohailong的这个用户的密码改为abc-------------- alter user guohailong identified by abc --当密码使用的是数字的时候可能会不行]]></content>
      <categories>
        <category>Oracle</category>
      </categories>
      <tags>
        <tag>Oracle sql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Oracle学习笔记(五)]]></title>
    <url>%2F2017%2F07%2F19%2FOracle%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BA%94%2F</url>
    <content type="text"><![CDATA[PL_SQL(过程化SQL语言)38. 在客户端输出helloworld12345678910111213141516171819202122232425 set serveroutput on;//默认是off，设成on是让Oracle可以在客户端输出数据 begin dbms_output.put_line('helloworld'); end; /----------------pl/sql变量的赋值与输出---- declare v_name varchar2(20);//声明变量v_name变量的声明以v_开头 begin v_name:= 'myname'; dbms_output.put_line(v_name); end; / 39. pl/sql对于异常的处理(除数为0)12345678910111213141516171819 declare v_num number := 0; begin v_num:= 2/v_num; dbms_output.put_line(v_num);** exception**** when others then**** dbms_output.put_line('error');** end; / 40. 变量的声明​ binary_integer:整数，主要用来计数而不是用来表示字段类型 比number效率高 ​ number:数字类型 ​ char:定长字符串 ​ varchar2：变长字符串 ​ date：日期 ​ long：字符串，最长2GB ​ boolean：布尔类型，可以取值true，false，null//最好给一初值 12345678910111213141516171819----------变量的声明，使用 '%type'属性--------- declare v_empno number(4); v_empno2 emp.empno%type; v_empno3 v_empno2%type; begin dbms_output.put_line('Test'); end; / --使用%type属性，可以使变量的声明根据表字段的类型自动变换，省去了维护的麻烦，而且%type属性，可以用于变量身上 41.组合变量1234567891011121314151617---------------Table变量类型(相当于java里面的数组)-------------------- declare type type_table_emp_empno is table of emp.empno%type index by binary_integer; v_empnostype_table type_table_empno; begin v_empnos(0):= 7345; v_empnos(-1):=9999; dbms_output.put_line(v_empnos(-1)); end; 42. Record变量类型（相当于Java里面的类）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647 declare type type_record_dept is record ( deptno dept.deptno%type, dname dept.dname%type, loc dept.loc%type ); v_temp type_record_dept; begin v_temp.deptno:=50; v_temp.dname:='aaaa'; v_temp.loc:='bj'; dbms_output.put_line(v_temp.deptno|| ' ' || v_temp.dname); end; -----------使用 %rowtype声明record变量，直接参照表来声明record------------------- declare v_temp dept%rowtype; begin v_temp.deptno:=50; v_temp.dname:='aaaa'; v_temp.loc:='bj'; dbms_output.put_line(vtemp.deptno || '' || v temp.dname) end; ​ 43. select语句的运用(必须保证select语句有相应的返回记录)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667 declare v_ename emp.ename%type; v_sal emp.sal%type; begin select ename,sal into v_ename,v_sal from emp where empno = 7369; dbms_output.put_line(v_ename|| '' || v_sal); end;-------------------------select语句的应用（record）------------------------------ declare v_emp emp%rowtype; begin select * into v_emp from emp where empno=7369; dbms_output_line(v_emp.ename); end; ------------- insert语句的应用 ----------------------------- declare v_deptno dept.deptno%type := 50; v_dname dept.dname%type :='aaa'; v_loc dept.loc%type := 'bj'; begin insert into dept2 values(v_deptno,v_dname,v_loc); commit; end; -------------update 语句的应用------------------------------ declare v_deptno emp2.deptno%type := 50; v_count number; begin update emp2 set sal = sal/2 where deptno =v_deptno; dbms_output.put_line(sql%rowcount || ‘条记录被影响’); commit; end; 注：sql%rowcount统计上一条sql语句更新的记录条数 44.ddl语言，数据定义语言12345678910111213141516171819202122232425262728293031 begin execute immediate 'create table T (nnn varchar(30) default ''a'')'; end;------------------ifelse语句-------------------------------------- declare v_sal emp.sal%type; begin select sal into v_sal from emp where empno = 7369; if(v_sal&lt; 2000) then dbms_output.put_line('low'); els if(v_sal &gt; 2000) then dbms_output.put_line('middle'); else dbms_output.put_line('height'); end if; end; 45. 循环do while 循环1234567891011121314151617declare i binary_integer := 1; begin loop dbms_output.put_line(i); i:= i + 1; exit when (i&gt;=11); end loop; end; while 循环123456789101112131415declare j binary_integer := 1; begin while j &lt; 11 loop dbms_output.put_line(j); j:=j+1; end loop; end; for 循环123456789101112131415begin for k in 1..10 loop dbms_output.put_line(k); end loop; for k in reverse 1..10 loop dbms_output.put_line(k); end loop; end;]]></content>
      <categories>
        <category>Oracle</category>
      </categories>
      <tags>
        <tag>Oracle sql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Oracle学习笔记(四)]]></title>
    <url>%2F2017%2F07%2F18%2FOracle%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9B%9B%2F</url>
    <content type="text"><![CDATA[24.——-创建新用户——–123456789101112131、backup scott//备份 exp//导出2、create user createuser guohailong identified(认证) by guohailong default table space users quota(配额) 10M on users grant create session(给它登录到服务器的权限),create table, create view to guohailong3、import data Imp 25. ——-取消操作——–123456789101112131415161718192021222324252627282930313233343536373839404142434445464748rollback-----------事务确认语句-------- commit;//此时再执行rollback无效当正常断开连接的时候例如exit,事务自动提交。 当非正常断开连接，例如直接关闭dos窗口或关机，事务自动提交 -----表的备份 create table dept2 as select * from dept;-----插入数据 insert into dept2 values(50,'game','beijing'); ----只对某个字段插入数据 insert into dept2(deptno,dname) values(60,'game2');-----将一个表中的数据完全插入另一个表中（表结构必须一样） insert into dept2 select * from dept;-----求前五名员工的编号和名称（使用伪字段rownum 只能使用 &lt; 或 = 要使用 &gt; 必须使用子查询） select empno,ename from emp where rownum &lt;= 5;----求10名雇员以后的雇员名称-------- select ename from (select rownum r,ename from emp) where r &gt; 10;----求薪水最高的前5个人的薪水和名字--------- select ename, sal from (select ename, sal from emp order by sal desc) where rownum&lt;=5; ----求按薪水倒序排列后的第6名到第10名的员工的名字和薪水-------- selectename, sal from (select ename, sal, rownum r from (select ename, sal from emp orderby sal desc) ) where r&gt;=6 and r&lt;=10 26. ——-面试题——–​ 有3个表S，C，SC ​ S（SNO，SNAME）代表（学号，姓名） ​ C（CNO，CNAME，CTEACHER）代表（课号，课名，教师） ​ SC（SNO，CNO，SCGRADE）代表（学号，课号成绩） ​ 问题： ​ 1，找出没选过“黎明”老师的所有学生姓名。 ​ 2，列出2门以上（含2门）不及格学生姓名及平均成绩。 ​ 3，即学过1号课程有学过2号课所有学生的姓名。 ​ 答案： 1234567891011121、 select sname from s join sc on(s.sno =sc.sno) join c on (sc.cno = c.cno) where cteacher &lt;&gt; '黎明';2、 select sname where sno in (select sno from sc where scgrade &lt; 60 group by sno having count(*) &gt;=2);3、 select sname from s where sno in (select sno, from sc where cno=1 and cno in (select distinct sno from sc where cno = 2); ) 27. ——–创建表———–123456789101112131415161718192021create table stu(id number(6),name varchar2(20) constraint stu_name_mmnot null,sex number(1),age number(3),sdate date,grade number(2) default 1,class number(4),email varchar2(50) unique ); 28. 五种约束条件：非空约束、唯一约束、主键约束、外键约束、检查约束（check）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273--------------给name字段加入 非空 **约束**，并给约束一个名字，若不取，系统默认取一个------------- create table stu ( id number(6), name varchar2(20) constraint stu_name_mm not null, sex number(1), age number(3), sdate date, grade number(2) default 1, class number(4), email varchar2(50) );--------------给nameemail字段加上唯一约束两个 null值 不为重复------------- create table stu ( id number(6), name varchar2(20) constraint stu_name_mmnot null, sex number(1), age number(3), sdate date, grade number(2) default 1, class number(4), email varchar2(50) unique );--------------两个字段的组合不能重复 约束：表级约束------------- create table stu ( id number(6), name varchar2(20) constraint stu_name_mmnot null, sex number(1), age number(3), sdate date, grade number(2) default 1, class number(4), email varchar2(50)， constraint stu_name_email_uni unique(email,name) ); 29. ——-主键约束——–​ 12345678910111213141516171819202122232425create table stu ( id number(6), name varchar2(20) constraint stu_name_mmnot null, sex number(1), age number(3), sdate date, grade number(2) default 1, class number(4), email varchar2(50), constraint stu_id_pk primary key (id), constraintstu_name_email_uni unique(email, name) ); 30.—外键约束 被参考字段必须是主键—123456789101112131415161718192021222324252627282930313233343536373839create table stu(id number(6),name varchar2(20) constraint stu_name_mmnot null,sex number(1),age number(3),sdate date,grade number(2) default 1,class number(4) references class(id),email varchar2(50), constraint stu_class_fk foreign key (class) references class(id), constraint stu_id_pk primary key (id), constraint stu_name_email_uni unique(email, name) ); 红色为字段约束的写法，蓝色为表级约束的写法 createtable class ( idnumber(4) primary key, namevarchar2(20) not null ); 31. 修改表结构12345678910111213141516171819---------------添加字段-------------------------- altertable stu add(addr varchar2(29));---------------删除字段-------------------------- altertable stu drop (addr);---------------修改表字段的长度------------------ altertable stu modify (addr varchar2(50));//更改后的长度必须要能容纳原先的数据----------------删除约束条件---------------- altertable stu drop constraint 约束名-----------修改表结构添加约束条件--------------- altertable stu add constraint stu_class_fk foreign key (class) references class(id); 32. 数据字典表（有user_tables、user_views、user_constraints等等）12345678910111213141516---------------查看当前用户下面所有的表、视图、约束-----数据字典表user_tables--- select table_name from user_tables; select view_name from user_views; select constraint_name from user_constraints; 存储数据字典表的信息的表：dictionary; //该表共有两个字段 table_name comments //table_name主要存放数据字典表的名字 //comments主要是对这张数据字典表的描述 ​ 33. 索引(能优化查询效率)12345678910111213create index idx_stu_email on stu (email);// 在stu这张表的email字段上建立一个索引：idx_stu_email---------- 删除索引 ------------------ drop index index_stu_email;---------查看所有的索引---------------- select index_name from user_indexes;---------创建视图------------------- create view v$stu as select id,name,age from stu; ​ 视图的作用: 简化查询，保护我们的一些隐私数据，通过视图也可以用来更新数据，但是我们一般不这么用 缺点：要对视图进行维护 34.创建序列（sequence，oracle特有的东西，一般用来做主键）​ 12345678910111213create sequence seq;//创建序列 select seq.nextval from dual;// 查看seq序列的下一个值 drop sequence seq;//删除序列 create table article ( id number, title varchar2(1024),cont long); create sequence seq; insert into article (id,title,cont) values(seq.nextval , ‘a’, ‘b’); 35. 数据库的三范式​ （1）要有主键，列不可分 ​ （2）不能存在部分依赖：当有多个字段联合起来作为主键的时候，不是主键的字段不能部分依赖于主键中的某个字段 ​ （3）不能存在传递依赖]]></content>
      <categories>
        <category>Oracle</category>
      </categories>
      <tags>
        <tag>Oracle sql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Oracle学习笔记(三)]]></title>
    <url>%2F2017%2F07%2F18%2FOracle%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%89%2F</url>
    <content type="text"><![CDATA[12. SQL1999_table_connections123select ename, dname,grade from emp e,deptd, salgrade swhere e.deptno = d.deptno and e.sal between s.losal and s.hisal and job &lt;&gt; 'CLERK' ​ 有没有办法把过滤条件和连接条件分开来? 出于这样考虑,Sql1999标准推出来了.有许多人用的还是 旧的语法,所以得看懂这种语句. 1234567891011select ename,dname from emp,dept;(旧标准).select ename,dname from emp** cross join** dept;(1999标准)select ename,dname from emp,dept where emp.deptno=dept.deptno (旧)select ename,dname from emp join dept on(emp.deptno = dept.deptno); 1999标准.没有Where语句.select ename,dname from emp join dept using(deptno);等同上句,但不推荐使用.select ename,grade from emp e join salgrade s on(e.sal between s.losal and s.hisal); ​ join 连接语句, on过滤条件。连接，条件一眼分开。如果用Where语句较长时，连接语句和过滤语句混在一起。​ 三张表连接： 1234567slect ename, dname, grade fromemp e join dept d on(e.deptno=d.deptno)join salgrade s on(e.sal between s.losal and s.hisal)where ename not like '_A%'; ​ 把每张表连接 条件不混在一起，然后数据过滤条件全部区分开来。读起来更清晰，更容易懂一点。 123 select e1.ename,e2.ename from emp e1 join emp e2on(e1.mgr = e2.emptno); ​ 左外连接：会把左边这张表多余数据显示出来。 123 select e1.ename,e2.ename from emp e1 left joinemp e2 on(e1.mgr =e2.empno);left 后可加outer ​ 右外连接：把右边这张表多余数据显示出来。 123 select ename,dname from emp e right outer join dept don(e.deptno =d.deptno); outer可以取掉。 ​ 全外连接： 即把左边多余数据，也把右边多余数据拿出来， 123 select ename,dname from emp e full join dept don(e.deptno =d.deptno); PS：所谓的“外”连接，即把多余的数据显示出来。Outer关键字可以省略。 13. 求部门中哪些人的薪水最高123select ename, sal from empjoin (select max(sal) max_sal, deptno from emp group by deptno) ton (emp.sal = t.max_sal and emp.deptno = t.deptno) 14. 求部门平均薪水的等级123select deptno,avg_sal,grade from (select deptno,avg(sal) avg_sal from emp group by deptno)t join salgrade s on(t.avg_sal between s.losal and s.hisal) 15. 求部门平均的薪水的平均等级123select deptno,avg(grade) from (select deptno,ename, grade from emp join salgrade s on(emp.sal between s.losal and s.hisal)) tgroup by deptno 16. 哪些人是经理12select ename from emp where empno in(select mgr from emp);select ename from emp where empno in(select distinct mgr from emp); 17.不准用组函数，求薪水的最高值（面试题）12select distinct sal from emp where sal not in(select distinct e1.sal from emp e1 join emp e2 on (e1.sal&lt;e2.sal)); 18.平均薪水最高的部门编号123456select deptno,avg_sal from(select avg(sal)avg_sal,deptno from emp group by deptno)where avg_sal=(select max(avg_sal)from (select avg(sal) avg_sal,deptno from emp group by deptno)) 19.平均薪水最高的部门名称123456789 select dname from dept where deptno=( select deptno from (select avg(sal)avg_sal,deptno from emp group by deptno) where avg_sal= (select max(avg_sal)from (select avg(sal) avg_sal,deptno from emp group by deptno) ) ) 20.求平均薪水的等级最低的部门的部门名称12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455 --组函数嵌套 --如：平均薪水最高的部门编号，可以E.更简单的方法如下： select deptno,avg_sal from (select avg(sal) avg_sal,deptno from emp group by deptno) where avg_sal = (select max(avg(sal)) from emp group by deptno) 组函数最多嵌套两层 -- 分析： -- 首先求 --1.平均薪水： select avg(sal) from emp group by deptno; -- 2.平均薪水等级： 把平均薪水当做一张表，需要和另外一张表连接salgrade select deptno,grade,avg_sal from ( select deptno,avg(sal) avg_sal from emp group by deptno) t join salgrade s on(t.avg_sal between s.losal and s.hisal) -- 上面结果又可当成一张表。 -- DEPTNO GRADE AVG_SAL -------- ------- ---------- -- 30 3 1566.66667 -- 20 4 2175 -- 10 4 2916.66667 -- 3.求上表平均等级最低值 select min(grade) from ( select deptno,grade,avg_sal from (select deptno,avg(sal) avg_sal from emp group by deptno)t join salgrade s on(t.avg_sal between s.losal and s.hisa) ) -- 4.把最低值对应的2结果的那张表的对应那张表的deptno, 然后把2对应的表和另外一张表做连接。 select dname ,deptno,grade,avg_sal from ( select deptno,grade,avg_sal from (select deptno,avg(sal) avg_sal from emp group by deptno)t join salgrade s on(t.avg_sal between s.losal and s.hisal) ) t1 join dept on (t1.deptno = dept.deptno) where t1.grade = ( select deptno,grade,avg_sal from (select deptno,avg(sal) avg_sal from emp group by deptno) t join salgrade s on(t.avg_sal between s.losal and s.hisal) ) )-- 结果如下： -- DNAME DEPTNO GRADE AVG_SAL-- -------- ------- -------- ---------- SALES 30 3 1566.6667 21. 视图（视图就是一张表，一个字查询）【 ​ 默认scott账户没有创建视图的权限，可通过如下语句授权：​ 首先登陆超级管理员：conn sys/用户密码 as sysdba;​ 授权：grant create table,create view to scott;​ 再以scott账户登陆：conn scott/tiger 】 12345678910111213141516171819202122232425262728-- 20中语句有重复，可以用视图来简化。 conn sys/bjsxt as sysdba; grant create table,create view to scott; conn scott/tiger-- 创建视图： create view v$_dept_avg-sal_info as select deptno,grade,avg_sal from ( select deptno,avg(sal) avg_sal from emp group by deptno)t join salgrade s on 9t.avg_sal between s.losal and s.hisal) -- 然后 select * from v$_dept_avg-sal_info -- 结果如下：-- DEPTNO GRADE AVG_SAL-- -------- ------- ------------ 30 3 1566.66667-- 20 4 2175-- 10 4 2916.66667-- 然后G中查询可以简化成： select dname,t1.deptno,grade,avg_sal from v$_dept_avg-sal_info t1 join dept on t1.deptno =dept.deptno) where t1.grade= ( select min(grade) from v$_dept_avg-sal_info t1 ) 22. 求比普通员工最高薪水还要高的经理人的名称1234567select ename, sal from emp where empno in (select distinct mgr from emp where mgr is not null) and sal &gt; ( select max(sal) from emp where empno not in (select distinct mgr from emp where mgr is not null) ) 23. 面试题：比较效率理论上前一句效率高，但实际上可能Oracle可能会自动对代码优化，所以不见得后一句就会慢。 12select * from emp where deptno = 10 and ename like '%A%'; --效率高，因为将过滤力度大的放在前面select * from emp where ename like '%A% and deptno = 10;]]></content>
      <categories>
        <category>Oracle</category>
      </categories>
      <tags>
        <tag>Oracle sql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Oracle学习笔记(二)]]></title>
    <url>%2F2017%2F07%2F17%2FOracle%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[8. Group by语句//需求:现在想求每个部门的平均薪水. 12345678910111213 select avg(sal) from emp group by deptno; select deptno avg(sal) from emp group by deptno; select deptno,job,max(sal) from emp group by deptno,job; 求薪水值最高的人的名字.select ename,max(sal) from emp;出错,因为max只有一个值,但等于max值的人可能好几个,不能匹配.应如下求:select ename from emp where sal=(select max(sal) from emp);Group by语句应注意,出现在select中的字段,如果没出现在组函数中,必须出现在Group by语句中. 9. Having 对分组结果筛选1Where是对单条纪录进行筛选,Having是对分组结果进行筛选. 12345678910select avg(sal),deptno from emp group by deptno having avg(sal)&gt;2000;查询工资大于1200雇员,按部门编号进行分组,分组后平均薪水大于1500,按工薪倒充排列.select * from emp where sal&gt;1200group by deptnohaving avg(sal)&gt;1500order by avg(sal) desc; 10. 字查询​ 谁挣的钱最多(谁:这个人的名字, 钱最多) 1select 语句中嵌套select 语句,可以在where,from后. ​ 问哪些人工资,在平均工资之上. 1select ename,sal from emp where sal&gt;(select avg(sal) from emp); 1234567891011//查找每个部门挣钱最多的那个人的名字.select ename ,deptno from emp where sal in(select max(sal) from ename group by deptno) //查询会多值.//应该如下:select max(sal),deptno from emp group by deptno;//当成一个表.语句如下:select ename, sal from emp join(select max(sal) max_sal,deptno from emp groupby deptno) t on(emp.sal=t.max_sal and emp.deptno=t.deptno); //每个部门的平均薪水的等级. //分析:首先求平均薪水(当成表),把平均薪水和另外一张表连接. 11. self_table_connection把某个人的名字以及他的经理人的名字求出来(经理人及这个人在表中同处一行) 分析:首先求出这个人的名字,取他的编号,然后从另一张表与其相对应编号,然后找到经理的名字. 1select e1.ename ,e2.ename from emp e1,emp e2 where e1.mgr= e2.empno. //empno编号和MGR都是编号.]]></content>
      <categories>
        <category>Oracle</category>
      </categories>
      <tags>
        <tag>Oracle</tag>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Oracle学习笔记(一)]]></title>
    <url>%2F2017%2F07%2F16%2FOracle%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%80%2F</url>
    <content type="text"><![CDATA[前言12sqlplus sys/所设定的密码 as sysdba(用管理员登陆)alter user scott account unlock;(解锁scott账户) 1. table structure12描述某一张表：desc 表名select * from 表名 2. select 语句1计算数据可以用空表：比如：select 2*3 from dual 1select ename,sal*12 annual_sal from emp;与select ename,sal*12 "annual sal" from emp;区别，加双引号保持原大小写。不加全变大写。 1select ename || "abcd" 如果连接字符串中含有单引号，用两个单引号代替一个单引号。(||代表连接符) 3. distinct123456select deptno from emp;select distinct deptno from emp;select distinct deptno from emp;select distinct deptno ,job from emp去掉deptno,job两者组合的重复。更多的项，就是这么多项的组合的不重复组合。 4. where12345678select * from emp where deptno =10;select * from emp where deptno &lt;&gt;10;不等于10 select * from emp where ename ='bike';select ename,sal from emp where sal between 800 and 1500 (&gt;=800 and &lt;=1500)空值处理:select ename,sal,comm from emp where comm is (not) null;select ename,sal,comm from emp where ename ( not)in ('smith','king','abc');select ename from emp where ename like '_A%';_代表一个字母,%代表0个或多个字母. 如果查询%可用转义字符.\%. 还可以用escape '$'比如:select ename from emp where ename like '%$a%' escape '$'; 5. orderby123select * from dept; select * from dept order by dept desc;(默认:asc)select ename,sal,deptno from emp order by deptno asc,ename desc; 6. sql function11234567891011121314151617181920212223242526272829303132333435363738394041select ename,sal*12 annual_sal from empwhere ename not like '_A%' and sal&gt;800order by sal desc;select lower(ename) from emp;select ename from emp where lower(ename) like '_a%';等同于select ename from emp where ename like '_a%' or ename like '_A%';select substr(ename,2,3) from emp;从第二字符截,一共截三个字符.select chr(65) from dual 结果为:Aselect ascii('a') from dual 结果为:65select round(23.652,1) from dual; 结果为: 23.7select round(23.652,-1) from dual; 20 select to_char(sal,'$99_999_999') from emp;select to_char(sal,'L99_999_999') from emp;人民币符号,L:代表本地符号这个需要掌握牢:select birthdate from emp;显示为:BIRTHDATE----------------17-12月-80----------------改为:select to_char(birthdate,'YYYY-MM-DD HH:MI:SS') from emp;显示: BIRTHDATE-------------------1980-12-17 12:00:00-------------------select to_char(sysdate,'YYYY-MM-DD HH24:MI:SS') from dual; //也可以改为:HH12TO_CHAR(SYSDATE,'YY-------------------2017-07-15 14:46:14 123to_date函数:select ename,birthdate from emp where birthdate &gt; to_date('1981-2-20 12:34:56','YYYY-MM-DD HH24:MI:SS');如果直接写 birthdate&gt;'1981-2-20 12:34:56'会出现格式不匹配,因为表中的格式为: DD-MM月-YY. 123456789select sal from emp where sal&gt;888.88 无错.但select sal from emp where sal&gt;$1,250,00;会出现无效字符错误. 改为:select sal from emp where sal&gt;to_number('$1,250.00','$9,999.99');s把空值改为0select ename,sal*12+nvl(comm,0) from emp;这样可以防止comm为空时,sal*12相加也为空的情况. 7. Group function 组函数1max,min,avg ,count,sum函数 1select to_char(avg(sal),'99999999,99') from emp; 1234567select round(avg(sal),2) from emp;结果:2073.21 select count(*) from emp where deptno=10;select count(ename) from emp where deptno=10; count某个字段,如果这个字段不为空就算一个.select count(distinct deptno) from emp;select sum(sal) from emp;]]></content>
      <categories>
        <category>Oracle</category>
      </categories>
      <tags>
        <tag>Oracle sql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java读书笔记-Thread类]]></title>
    <url>%2F2017%2F07%2F14%2Fjava%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-Thread%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[一、线程的三个常用方法 二、线程死锁图解 Thread1锁住了上面的对象，等待锁住下面的对象来完成执行过程。但是下面的对象被Thread2锁住了，它也等着锁住上面的对象来完成执行，因此陷入了死锁。 三、死锁小程序12345678910111213141516171819202122232425262728293031323334353637383940414243public class TestDeadLock implements Runnable &#123; public int flag = 1; static Object o1 = new Object(), o2 = new Object(); public void run() &#123; System.out.println("flag=" + flag); if(flag == 1) &#123; synchronized(o1) &#123; try &#123; Thread.sleep(500); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; synchronized(o2) &#123; System.out.println("1"); &#125; &#125; &#125; if(flag == 0) &#123; synchronized(o2) &#123; try &#123; Thread.sleep(500); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; synchronized(o1) &#123; System.out.println("0"); &#125; &#125; &#125; &#125; public static void main(String[] args) &#123; TestDeadLock td1 = new TestDeadLock(); TestDeadLock td2 = new TestDeadLock(); td1.flag = 1; td2.flag = 0; Thread t1 = new Thread(td1); Thread t2 = new Thread(td2); t1.start(); t2.start(); &#125;&#125; 四、面试题下面举个小例子： 1234567891011121314151617181920212223242526272829303132public class TT implements Runnable &#123; int b = 100; public synchronized void m1() throws Exception&#123; //Thread.sleep(2000); b = 1000; Thread.sleep(5000); System.out.println("b = " + b); &#125; public void m2() throws Exception &#123; Thread.sleep(2500); b = 2000; &#125; public void run() &#123; try &#123; m1(); &#125; catch(Exception e) &#123; e.printStackTrace(); &#125; &#125; public static void main(String[] args) throws Exception &#123; TT tt = new TT(); Thread t = new Thread(tt); t.start(); tt.m2(); System.out.println(tt.b); &#125;&#125; 上面的输出结果是：2000 五、wait()跟sleep()区别1)wait时别的线程可以访问锁定对象(调用wait方法的时候必须锁定该对象) 2)sleep时别的线程也不可以访问锁定对象 2)Thread.sleep()与Object.wait()二者都可以暂停当前线程，释放CPU控制权，主要的区别在于Object.wait()在释放CPU同时，释放了对象锁的控制，而在同步块中的Thread.sleep()方法并不释放锁，仅释放CPU控制权。 六、wait()跟notify()方法 1)wait()方法与notify()必须要与synchronized(resource)一起使用。(也就是wait与notify针对已经获取了resource锁的线程进行操作，从语法角度来说就是Obj.wait(),Obj.notify必须在synchronized(Obj){...}语句块内。) 2) wait和notify方法均可释放对象的锁，但wait同时释放CPU控制权，即它后面的代码停止执行，线程进入阻塞状态，而notify方法不立刻释放CPU控制权，而是在相应的synchronized(){}语句块执行结束，再自动释放锁。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>Thread</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java读书笔记-IO类-编程小问题]]></title>
    <url>%2F2017%2F07%2F13%2Fjava%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-IO%E7%B1%BB-%E7%BC%96%E7%A8%8B%E5%B0%8F%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最近在重新复习下java SE的内容，把一下小问题记录下来。 一、Java流式输入输出原理图 二、流的分类 三、节点流类型 总结以stream结尾的是字节流，以reader或writer结尾的是字符流。 一、字节流文件复制12345678910111213141516171819202122import java.io.*;public class TestFileOutputStream &#123; public static void main(String[] args) &#123; int b = 0; FileInputStream in = null; FileOutputStream out = null; try &#123; in = new FileInputStream("d:/share/java/HelloWorld.java"); out = new FileOutputStream("d:/share/java/io/HW.java"); while((b=in.read())!=-1)&#123; out.write(b); &#125; in.close(); out.close(); &#125; catch (FileNotFoundException e2) &#123; System.out.println("找不到指定文件"); System.exit(-1); &#125; catch (IOException e1) &#123; System.out.println("文件复制错误"); System.exit(-1); &#125; System.out.println("文件已复制"); &#125;&#125; 二、BufferedWriter和BufferedReader图解如果只是用FileWriter的话只能每次写入一个字符，而在外面再包装一层BufferedWriter的话一次可以写入一个缓冲区的内容。 三、OutputStreamWriter工作原理如果只是用FileWriter的话只能每次写入一个字节，而在外面再包装一层BufferedWriter的话一次可以写入一个字符串的内容。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>IO</tag>
        <tag>编程小问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java读书笔记-常用类-编程小问题]]></title>
    <url>%2F2017%2F07%2F11%2Fjava%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E5%B8%B8%E7%94%A8%E7%B1%BB-%E7%BC%96%E7%A8%8B%E5%B0%8F%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最近在重新复习下java SE中常用类的内容，把一下小问题记录下来。 一、用Java编写一个程序，输出一个字符串中的大写英文字母数，小写英文字母数以及非英文字母数。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import java.util.regex.*;public class TestString &#123; public static void main(String[] args) &#123; //方法一 //String s = "AaaaABBBBcc&amp;^%adfsfdCCOOkk99876 _haHA"; //int lCount = 0, uCount = 0, oCount = 0; /* for(int i=0; i&lt;s.length(); i++) &#123; char c = s.charAt(i); if(c &gt;= 'a' &amp;&amp; c &lt;= 'z') &#123; lCount ++; &#125; else if (c &gt;='A' &amp;&amp; c &lt;= 'Z') &#123; uCount ++; &#125; else &#123; oCount ++; &#125; &#125; */ //方法二 /* String sL = "abcdefghijklmnopqrstuvwxyz"; String sU = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"; for(int i=0; i&lt;s.length(); i++) &#123; char c = s.charAt(i); if(sL.indexOf(c) != -1) &#123; lCount ++; &#125; else if (sU.indexOf(c) != -1) &#123; uCount ++; &#125; else &#123; oCount ++; &#125; &#125; */ //方法三 for(int i=0; i&lt;s.length(); i++) &#123; char c = s.charAt(i); if(Character.isLowerCase(c)) &#123; lCount ++; &#125; else if (Character.isUpperCase(c)) &#123; uCount ++; &#125; else &#123; oCount ++; &#125; &#125; System.out.println(lCount + " " + uCount + " " + oCount); 二、将“1,2;3,4,5;6,7,8”这个字符串分解为二维数组。123456789101112131415161718192021public class ArrayParser &#123; public static void main(String[] args)&#123; double[][] d; String = "1,2;3,4,5;6,7,8"; String[] sFirst = s.split(";"); d = new double[sFirst.length][]; for(int i = 0; i &lt; sFirst.length; i++)&#123; String[] sSecond = sFirst[i].split(","); d[i] = new double[sSecond.length]; for(int j = 0; j &lt; sSecong.length; j++)&#123; d[i][j] = Double.parseDouble(sSecond[j]); &#125; &#125; for(int i = 0; i &lt; d.length; i++)&#123; for(int j = 0; j &lt; d[i].length; j++)&#123; System.out.print(d[i][j] + " "); &#125; System.out.println(); &#125; &#125;&#125; 三、利用递归列出目录结构12345678910111213141516171819202122232425import java.io.*;public class FileList &#123; public static void main(String[] args) &#123; File f = new File("d:/A"); System.out.println(f.getName()); tree(f, 1); &#125; private static void tree(File f, int level) &#123; String preStr = ""; for(int i=0; i&lt;level; i++) &#123; preStr += " "; &#125; File childs = f.listFiles(); for(int i=0; i&lt;childs.length; i++) &#123; System.out.println(preStr + childs[i].getName()); if(childs[i].isDirectory()) &#123; tree(childs[i], level + 1); &#125; &#125; &#125;&#125; 四、编写一个方法，输出在一个字符串中，指定字符串出现的次数123456789101112131415 String s = "sunjavahpjavaokjavajjavahahajavajavagoodjava"; String sToFind = "java"; int count = 0; int index = -1; while((index = s.indexOf(sToFind)) != -1) &#123; s = s.substring(index + sToFind.length()); count ++; &#125; System.out.println(count);&#125;]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>class</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[别再乱用jQuery return false]]></title>
    <url>%2F2017%2F05%2F14%2F%E5%88%AB%E5%86%8D%E4%B9%B1%E7%94%A8jQuery%20return%20false%2F</url>
    <content type="text"><![CDATA[前言​ event.preventDefault()方法是用于取消事件的默认行为，但此方法并不被ie支持，在ie下需要用window.event.returnValue = false; 来实现。这不是jQuery的方法，是JS本身自带的。 event.preventDefault()​ 该方法将通知 Web 浏览器不要执行与事件关联的默认动作（如果存在这样的动作）。例如，如果 type 属性是 “submit”，在事件传播的任意阶段可以调用任意的事件句柄，通过调用该方法，可以阻止提交表单。注意，如果 Event 对象的 cancelable 属性是 fasle，那么就没有默认动作，或者不能阻止默认动作。无论哪种情况，调用该方法都没有作用。 event.stopPropagation()​ 该方法将停止事件的冒泡，阻止它被分派到其他 Document 节点。在事件冒泡的任何阶段都可以调用它。注意，虽然该方法不能阻止同一个 Document 节点上的其他事件句柄被调用，但是它可以阻止把事件分派到其他节点。event是DOM的事件方法，所以不是单独使用，比如指定DOM。 测试在jQuery代码中，我们常见用return false来阻止浏览器的默认行为。例如点击链接，浏览器默认打开一个新窗口/标签，为了阻止浏览器的默认行为，我们往往这样操作： 1234$("a.toggle").click(function() &#123; $("#mydiv").toggle(); return false; &#125;); 这段代码的作用是通过点击toggle来隐藏或显示#mydiv，并阻止浏览器继续访问href指定链接。测试如下： click toggle 点击上一行的toggle，这段文字将被显示或隐藏。 return false的作用return false达到了我们想要的目的，但这并不是阻止浏览器执行默认行为的正确方法。调用return false，它实际完成了3件事： 1.event.preventDefault()2.event.stopPropagation()3.停止回调函数执行并立即返回。我们真正的目的是event.preventDefault()，后两者可不是我们想要的。JavaScript事件有两种，一种称为事件冒泡（event bubbling），一种称为事件捕捉（event capturing）。事件冒泡指事件在初始DOM上触发，通过DOM树往上在每一级父元素上触发；当事件向下冒泡时，我们则称之为事件捕获。 测试因为return false多做了两件事，由此为代码埋下隐患。下面有一个简单的例子，点击一个链接，加载新的页面内容到当前页面： 1234567891011121314151617&lt;div class="post"&gt; &lt;a href="/js/loadp1.txt"&gt;Click here to load page1&lt;/a&gt; &lt;div class="content"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="post"&gt; &lt;a href="/js/loadp2.txt"&gt;Click here to load page2&lt;/a&gt; &lt;div class="content"&gt; &lt;/div&gt; &lt;/div&gt; $("div.post a").click(function() &#123; var href = $(this).attr("href"); $(this).next().load(href); return false; &#125;); 测试如下： Click here to load page1 Click here to load page2 ​ 点击链接就能加载页面内容到当前页，一切都OK。现在我们想要加一个新功能，例如论坛帖子的浏览，只有当前点击的帖子内容才会显示，其他帖子都隐藏。为此我们需要为div.post加一个click()事件处理： 1234$("div.post").click(function()&#123; $("div.post .content").hide(); // hide all content $(this).children(".content").show(); // show this one &#125;); ​ 添加完这段代码后，我们发现它不生效，缘故是因为$(&quot;div.post a&quot;).click(function() { return false; });，由于return false执行了event.stopPropagation()，因此事件不能冒泡到上一级DOM，即$(&quot;div.post&quot;).click()不会被事件触发。要达成我们的任务，应该把return false替换为event.preventDefault()： 12345$("div.post a").click(function(e) &#123; var href = $(this).attr("href"); $(this).next().load(href); e.preventDefault(); &#125;); 测试修改后的代码： Click here to load page1 Click here to load page2 return false 和 live/delegate如果把return false和live/delegate事件混用，情况就更糟糕了： 12345678$("a").click(function()&#123; // do something return false; &#125;); $("a").live("click", function()&#123; // this won't fire &#125;); 如果确实需要阻止事件冒泡，也应该显式地调用： 12345678$("div.post").click(function()&#123; // do something &#125;); $("div.post a").click(function(e)&#123; // 浏览器跳转到新页面（默认行为） // 但阻止事件冒泡，即不会执行$("div.post").click() e.stopPropagation(); &#125;); event.stoplmmediatePropagetion()​ event.stopPropagation()用于阻止事件冒泡，jQuery中还有另一个函数：event.stopImmediatePropagation()，它用于阻止一个事件的继续执行，即使当前对象上还绑定了其他处理函数： 12345678910111213141516$("div a").click(function()&#123; // do something &#125;); $("div a").click(function(e)&#123; // stop immediate propagation e.stopImmediatePropagation(); &#125;); $("div a").click(function()&#123; // never fires &#125;); $("div a").click(function()&#123; // never fires &#125;); 总结​ 最后结论是：理解return false，尽量避免使用它，请用event.preventDefault()替代return false。]]></content>
      <categories>
        <category>javascript</category>
        <category>jQuery</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery读书笔记]]></title>
    <url>%2F2017%2F05%2F01%2FjQuery%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[最近在学习jQuery,顺便做了一点笔记，防止以后要寻找的时候找不到。 1)$(“form :input”) 返回form中的所有表单对象，包括textarea、select、button等 $(“form input”)返回form中的所有input标签对象 $(“#form1:input”)表示id为#form1的input form input 是属于层级选择器(将每一个选择器匹配到的元素合并后一起返回) 2)121. &lt;div id = "id#b"&gt;bb&lt;/div&gt; 2. &lt;div id = "id[1]"&gt;cc&lt;/div&gt; 上述div不能用普通方式来获取，例如 121. $("#id#b"); 2. $("#id[1]"); 而应该用转义字符： 121. $("#id\#b"); 2. $("#id\[1\]"); 3)12345671. $(document).ready(function()&#123; 2. //... 3. &#125;); 4. 可以简写为 5. $(function()&#123; 6. //... 7. &#125;) 4)123456781. &lt;div class="test"&gt; 2. &lt;div style="display:none;"&gt;aa&lt;/div&gt; 3. &lt;div style="display:none;"&gt;bb&lt;/div&gt; 4. &lt;div style="display:none;"&gt;cc&lt;/div&gt; 5. &lt;div class="test" style="display:none;"&gt;dd&lt;/div&gt; 6. &lt;/div&gt; 7. &lt;div class="test" style="display:none;"&gt;ee&lt;/div&gt; 8. &lt;div class="test" style="display:none;"&gt;ff&lt;/div&gt; 下面用jquery选取： 123456789101. $(function()&#123; 2. //注意区分类似这样的选择器 3. //虽然一个空格，却截然不同的效果. 4. var t_a = ('.test :hidden'); 5. var t_b = ('.test:hidden'); 6. var len_a = $t_a.length; 7. var len_b = $t_b.length; 8. ("&lt;p&gt;('.test :hidden')的长度为"+len_a+"&lt;/p&gt;").appendTo("body"); //4 9. ("&lt;p&gt;('.test:hidden')的长度为"+len_b+"&lt;/p&gt;").appendTo("body"); //3 10. &#125;) 原因是： var $t_a = $(“.test :hidden”); 以上代码是选取class为”test”的元素里面的隐藏元素 而代码： var $t_b = $(“.test:hidden”); 这是选取隐藏的class为“test”的元素 5)detach()和remove()一样，也是从DOM中去掉匹配的元素。但是这个方法不会把匹配的元素从jQuery对象中删除，因而可以在将来再使用这些匹配的元素，与remove不同的是，所以绑定的事件、附加的数据等都会保留下来。 6)$(this).clone(true).appendTo(“body”); //注意参数true 在clone()方法中传递了一个参数true，它的含义是复制元素的同事复制元素中所绑定的事件，因而该元素的副本也同样具有复制功能。 7)在css()方法中，如果属性中带有“-”符号，例如font-size属性，如果在设置这些属性的值得时候不带引号，那么就要用驼峰式写法，例如： $(“p”).css({fontSize : “30px” , backgroundColor : “#888888”}); 如果加上了引号，既可以写成”font-size”,也可以写成“fontSize”。 8)show()方法和hide()方法会同时修改元素的多个样式属性，即高度、宽度和不透明度；fadeOut()和fadeIn()方法智慧修改元素的不透明度；slideDown()方法和slideUp()方法智慧改变元素的高度。 9)1234567891011121. $("button:eq(1)").click(function () &#123; 2. $("#panel").stop();//停止当前动画，继续下一个动画 3. &#125;); 4. $("button:eq(2)").click(function () &#123; 5. $("#panel").stop(true);//清除元素的所有动画 6. &#125;); 7. $("button:eq(3)").click(function () &#123; 8. $("#panel").stop(false,true);//让当前动画直接到达末状态 ，继续下一个动画 9. &#125;); 10. $("button:eq(4)").click(function () &#123; 11. $("#panel").stop(true,true);//清除元素的所有动画，让当前动画直接到达末状态 12. &#125;); 10)animate回调函数 12345$("#panel").click(function () &#123; $(this).animate(&#123;left: "400px", height: "200px", opacity: "1"&#125;, 3000) .animate(&#123;top: "200px", width: "200px"&#125;, 3000, function () &#123; $(this).css("border", "5px solid blue"); &#125;) 11)用attr()和prop()访问对象的属性的原则： 第一个原则：只添加属性名称该属性就会生效应该使用prop()； 第一个原则：只存在true/false的属性应该使用prop()。 按照官方说明，如果是设置disable和checked这些属性，应使用prop()方法，而不是使用attr()方法。（例如在某些浏览器里，只要写了disabled属性就可以，有些则要写：disabled = “disabled”。）]]></content>
      <categories>
        <category>javascript</category>
        <category>jQuery</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>jQuery</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript冒泡事件的作用效果]]></title>
    <url>%2F2017%2F04%2F22%2Fjavascript%E5%86%92%E6%B3%A1%E4%BA%8B%E4%BB%B6%E7%9A%84%E4%BD%9C%E7%94%A8%E6%95%88%E6%9E%9C%2F</url>
    <content type="text"><![CDATA[​ 这段时间在学习js，忽然发现了冒泡事件挺有趣的，故研究后来跟各位分享一下效果。 话不多说，直接上代码： 代码123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="body"&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=""&gt;home&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=""&gt;About&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;script&gt; function stopBubble(e)&#123; if(e &amp;&amp; e.stopPropagation)&#123;//如果不是IE浏览器 e.stopPropagation(); &#125;else&#123;//是IE浏览器 window.event.cancelBubble=true; &#125; &#125; var all = document.getElementsByTagName("*"); for(var i =0;i&lt;all.length;i++)&#123; all[i].onmouseover = function(e)&#123;//鼠标悬停在元素上 this.style.border="1px solid red"; stopBubble(e); &#125;; all[i].onmouseout=function(e)&#123;//鼠标离开 this.style.border="0px"; stopBubble(e);//阻止冒泡 &#125;; &#125; &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 总结​ 上面是一个简单的例子,当鼠标悬停在元素之上,我们为这个元素加上红色边框,如果离开了再去掉这个红色边框, ​ 如果不加 这个 阻止冒泡的方法,每次都会给父类增加红色边框,大家 可以试验一下.一试便知!]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>冒泡事件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[u盘安装windows 10与Ubuntu Linux双系统图解教程]]></title>
    <url>%2F2017%2F03%2F23%2FLinux%E5%8F%8C%E7%B3%BB%E7%BB%9F%E5%9B%BE%E8%A7%A3%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[注意如果图片加载不出来请在：http://blog.csdn.net/onlylove_kd/article/details/70544204 进行查看。 前言按照本图解教程的方法可以完成Windows 10和Ubuntu Kylin双系统的安装。（有些图片是百度得来的） Windows 10和Ubuntu Kylin双系统引导成功图： 1.安装环境Windows 10系统 2.安装 ubuntu 首先需要准备以下工具以及安装包：1、ubuntu 系统安装包​ https://mirrors.tuna.tsinghua.edu.cn/#（这个是清华的镜像站点，里面有各种镜像，下载速度也很可观） 2、刻录软件，推荐软碟通，会提示注册，选择继续使用​ 下载：在百度搜一大把 3、一个大于 2G 的 U 盘4、EasyBCD 软件，此软件是同来作为系统引导所用​ 下载地址：http://dl.pconline.com.cn/download/90611.html 3.准备安装1、回到桌面，鼠标右键点击开始菜单图标，选择属性，结果如下 2、进入然后选择磁盘管理，结果如下： 3、选择你认为剩余磁盘空间够大的磁盘，比如 D 盘，右键点击磁盘，选择压缩卷，结果如下： 4、然后就是分区的大小了，个人建议分个 50G 出去最好，然后等待，最终结果如下：压 缩后会发现多出一块未分区磁盘（黑色分区），如果选择的压缩大小是 50G， 则黑色的的应该是 50G 可用空间。 好了，磁盘分区到此结束，现在进行第四步。 4.用软碟通将 UBUNTU 的镜像写入 U 盘1、安装并打开软碟通，插上 U 盘，并且最好备份你的 U 盘，因为之后需要格式化 2、进入软碟通，进行如下操作 选择文件，并且打开你下载的 UBUNTU 所在的目录，选择 unbuntu 镜像（改成选择Ubuntu Kylin 镜像即可），选择打开，如图： 3、在软碟通界面菜单栏选择启动，选择写入硬盘映像，如图所示 接下来很重要，记住次序： 进入以后界面如下： 1、看你的硬盘驱动器是否对应的是你的 U 盘（必须是） ，一般默认是 2、看映像文件是否对应你的 ubuntu 镜像 3、如果上述均没有错误，选择格式化，之后就会格式化你的 U 盘 4、在 U 盘格式化完毕之后，选择写入，之后就是慢慢等待了，等待写入完毕 5.U 盘安装系统（记得关闭电脑的快速启动）写在前面，因为个厂商的计算机 BOOT 启动的快捷键不相同，所以 个人觉得要是你无法进入接下来的 BOOT 界面，还是自行百度如何 进入 BOOT 界面，本人华硕笔记本，所以默认快捷键是 F2。 第 6 步非常关键，如果你不想重装系统，你一定要小心 1、重启系统，在开机刚开始按 F2，之后里面会有如下界面，手机 渣渣，多多包涵，选择 USB HDD，回车确认 2、之后就进入 unbuntu 的安装界面了 3、或许没有这个界面，但是下面的界面是一定有的 4、然后选择左边的，往下拉会有中文选择，如图 5、安装 unbuntu 6、选择继续（注意，接下来这一步非常重要，一定小心），得到如下所视界面，如图 这一步很关键，一定要选择其他选项，切记，然后进入如下界面 看到没有，里面会有一个空闲分区，也就是我们之前所创建的那个分区 在这里，我们谈谈关于 Linux 的分区：a.首先 Linux 分区适合 WINDOWS 分区是不一样的， Linux 是以文 件形式作为分区 b.所以分区就像划分磁盘大小一样， 在这里我个人建议如果你的 划分的空盘分区为 60G，则我们可以将其分为 : 1)、/:这是 linux 也就是 ubuntu 的根目录就一个反斜杠表示， 我们将其分为 25G，文件格式为 ext4 2）、 /home:这是 ubuntu 根目录下的一个文件夹， 这个也可以说 是我们的个人目录，所以为了让我们自己的目录大一点，我们可 以将其分为 30G 或者 20G，文件格式为 ext4 3）、swap:这个是 Linux 也就是 ubuntu 的交换区目录，这个一 般的大小为内存的 2 倍左右， 主要是用来在电脑内存不足的情况 下，系统会调用这片区域，来运行程序，我们可以将其分为 4G， 这个没有让你选用文件格式 4）、/boot：这个就是实现你双系统的原因了，这个就是用启动 ubuntu 的目录，里面会有系统的引导，这个文件其实只有几十 兆，但是我们建议将其划分为 200M 文件格式为 ext4，这个分区必不可少，否则后果你懂得！ 好了，这部分分区讲诉完毕，下面就让我们来进行期待已久的分区吧。当然，你可以划分的更详细，具体划分可以百度。7、分区 选择空闲分区之后，点击添加，会得到如图界面： A.首先就是创建根目录，上面提到过，大小 25G 左右，用于 EXT4 文件系统，挂载点有下拉菜单，选择/就好，然后确定，继续选择空闲分区，别看错了，然后添加 B.然后就是交换区的创建，步骤如上，区别是大小为 4G，用于那个下拉菜单选择交换空间，即 SWAP，然后确定 C./BOOT 的创建，大小 200M，文件系统为 EXT4，挂载点选择/boot，点击确定 D、/HOME 的创建，大小 30G，文件系统 40G，挂载点/HOME,点击确定 到此分区完成 接下来的这一步很重要，切记（关系到 ubuntu 的开机启动） 依然在这个界面上，选择安装启动下拉菜单，我们刚刚不是创建了/boot 的文件 吗，现在你看看这个区前面的编号是多少，我的是下面这个 /dev/sda1,不同的机 子在在这个上面会有不同的编号，也就是 sda1 然后在安装启动的下拉菜单中找到 sda1，选择它，切记一定是/boot 的编号 如下图 接下来就选择开始安装了；8、选择继续，进入下一步操作，并设置地区为：chongqing，按你需要设置，在下一步操作中选择语言 9、键盘布局“默认”，建议选择下面的这个 10、这里设置系统用户，自己设置输入就可以了 11、这个可选可不选，点“继续” 12． 系统开始安装，可以喝杯咖啡，等安装完毕就可以了（这里应该是欢迎使用Ubuntu Kylin） 当这些全部完成之后，机子会重启。你会发现直接进入你的 win10 系统，因为我们把它的引 导搞到/boot 分区了。我们要用 EasyBCD 来给它创建启动时候的选择系统是 windows 还是 ubuntu 。 6.用 EasyBCD 引导 ubuntu接下来就很简单了，在 WIN10 下安装 EasyBCD,之后呢打开如图并且选择添加新条目： 得到如图，选择有企鹅那个，也就是 LINUX/BSD 那个选项，在磁盘驱动器那个下拉菜单选 择以 linux 开头，大小为 200M 左右的那个选项，如图 选择完了之后，添加条目，重启电脑，你就会发现你的 UBUNTU 和 WIN10的双系统就安装完成了。到此，ubuntu 安装结束！ 当你不要 ubuntu 的时候，直接在 window 里磁盘管理删了它所在的分区，然后在 Easybcd 里 删了它的引导就行，不影响你的 windows 系统，这就是为啥我不用 ubuntu 来引导 windows 的原因。 然后就可以尽情享受双系统的乐趣了哈哈哈。 Ubuntu Kylin桌面]]></content>
      <categories>
        <category>装系统</category>
      </categories>
      <tags>
        <tag>U盘</tag>
        <tag>windows10</tag>
        <tag>Ubuntu</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello Hexo]]></title>
    <url>%2F2017%2F01%2F23%2Fhello-hexo%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>Hexo教程</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于解决VS2015不能用fscanf而老是提示用fscanf_s的方法]]></title>
    <url>%2F2016%2F12%2F17%2F%E5%85%B3%E4%BA%8E%E8%A7%A3%E5%86%B3VS2015%E4%B8%8D%E8%83%BD%E7%94%A8fscanf%E8%80%8C%E8%80%81%E6%98%AF%E6%8F%90%E7%A4%BA%E7%94%A8fscanf-s%E7%9A%84%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[前言​ 由于笔者之前用的是dev还有code block，没怎么用过VS2015这个软件，所以发现有些东西不太一样，在下面跟大家分享一下。 问题​ 在处理文件输入的时候，我本来是想用fscanf函数，但是编译的时候老是说fscanf函数不安全，建议改成fscanf_s函数。但是fscanf_s函数我不会用，找了挺久的资料，终于知道解决方法了。 解决方法方法一：在程序最前面加#define _CRT_SECURE_NO_DEPRECATE； 方法二：在程序最前面加#define _CRT_SECURE_NO_WARNINGS； 方法三：在程序最前面加#pragma warning(disable:4996)； 方法四：把scanf改为scanf_s；. 方法五：无需在程序最前面加那行代码，只需在新建项目时取消勾选“SDL检查”即可； 方法六：若项目已建立好，在项目属性里关闭SDL也行； 方法七：在工程项目设置一下就行；将报错那个宏定义放到 项目属性 – C/C++– 预处理器 – 预处理器定义； 方法八：在 项目属性 – c/c++ – 命令行 添加：/D _CRT_SECURE_NO_WARNINGS 就行了。]]></content>
      <categories>
        <category>编译器问题</category>
      </categories>
      <tags>
        <tag>Visual Studio</tag>
        <tag>fscanf_s</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言实现链栈的基本操作]]></title>
    <url>%2F2016%2F04%2F01%2FC%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E9%93%BE%E6%A0%88%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[前言本文是关于链栈的**增删查改**等基本操作。 所用语言C 编译环境dev c++ 代码LinkStack.h123456789101112131415161718192021222324252627282930313233typedef struct StackNode&#123; ElemType data; struct StackNode *next; &#125; StackNode, *StackNodePtr; typedef struct LinkStack &#123; StackNodePtr top; int count; &#125; LinkStack, *LinkStackPtr; // 构造一个空栈 S，成功返回 TRUE，失败返回 FALSE Status initStack(LinkStackPtr S); /********************************************************************************** Name............: Status push(LinkStackPtr S,ElemType e) Description.....: 数据 e 压栈 Parameters......: S-指向 LinkStack 类型指针变量 e-压栈的数据 Return values...: 成功-return TRUE 失败-return FALSE PreCondition....：调用 push 前，S 需要经过 initStack 初始化 PostCondition...：成功时，生成了一个存储 e 的新结点，数据 e 压入了 S 栈顶，栈 S 的长度 count 增 1，同时栈 S 的 top 指针指向新结点；失败时，栈 S 不改变 **********************************************************************************/ // 数据压栈，成功返回 TRUE,失败返回 FALSE Status push(LinkStackPtr S, ElemType e); // 数据弹栈，并赋值给 e，成功返回 TRUE,失败返回 FALSE Status pop(LinkStackPtr S, ElemType *e); // 栈的判空，若为空，返回 TRUE，否则返回 FALSE Status isStackEmpty(LinkStackPtr S); // 获取栈顶元素，并赋值给 e，成功返回 TRUE,失败返回 FALSE Status getTop(LinkStackPtr S, ElemType *e); // 销毁栈，成功返回 TRUE,失败返回 FALSE Status destroyStack(LinkStackPtr S); //利用上面的操作，实现一个算术表达值的求值。 （求值独立成一个函数，写在 test.c 中，带括号的中 缀表达式只包括加减，包括括号），比如： (1+(2-3)-(4+5)) */ 栈作业.h1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192//将int类型定义为ElemType typedef int ElemType; //链栈结构 typedef struct StackNode &#123; ElemType data; struct StackNode *next; &#125; StackNode, *StackNodePtr; typedef struct LinkStack &#123; StackNodePtr top; int count; &#125; LinkStack, *LinkStackPtr; typedef enum Status &#123; FLASE, TRUE &#125;Status; // 构造一个空栈S，成功返回TRUE，失败返回FALSE Status initStack(LinkStackPtr S); /********************************************************************************** Name............: Status push(LinkStackPtr S,ElemType e) Description.....: 数据e压栈 Parameters......: S-指向LinkStack类型指针变量 e-压栈的数据 Return values...: 成功-return TRUE 失败-return FALSE PreCondition....：调用push前，S需要经过initStack初始化 PostCondition...：成功时，生成了一个存储e的新结点，数据e压入了S栈顶，栈S的长度count 增1，同时栈S的top指针指向新结点；失败时，栈S 不改变 **********************************************************************************/ // 数据压栈，成功返回TRUE,失败返回FALSE Status push(LinkStackPtr S, ElemType e); // 数据弹栈，并赋值给e，成功返回TRUE,失败返回FALSE Status pop(LinkStackPtr S, ElemType *e); // 栈的判空，若为空，返回TRUE，否则返回FALSE Status isStackEmpty(LinkStack S); // 获取栈顶元素，并赋值给e，成功返回TRUE,失败返回FALSE Status getTop(LinkStackPtr S, ElemType *e); // 销毁栈，成功返回TRUE,失败返回FALSE Status destroyStack(LinkStackPtr S); // 输出栈的元素 Status StackTraverse(LinkStack S); unsigned char Prior[8][8] = &#123; // 运算符优先级表 // '+' '-' '*' '/' '(' ')' '#' '^' /*'+'*/'&gt;','&gt;','&lt;','&lt;','&lt;','&gt;','&gt;','&lt;', /*'-'*/'&gt;','&gt;','&lt;','&lt;','&lt;','&gt;','&gt;','&lt;', /*'*'*/'&gt;','&gt;','&gt;','&gt;','&lt;','&gt;','&gt;','&lt;', /*'/'*/'&gt;','&gt;','&gt;','&gt;','&lt;','&gt;','&gt;','&lt;', /*'('*/'&lt;','&lt;','&lt;','&lt;','&lt;','=',' ','&lt;', /*')'*/'&gt;','&gt;','&gt;','&gt;',' ','&gt;','&gt;','&gt;', /*'#'*/'&lt;','&lt;','&lt;','&lt;','&lt;',' ','=','&lt;', /*'^'*/'&gt;','&gt;','&gt;','&gt;','&lt;','&gt;','&gt;','&gt;' &#125;; typedef struct StackChar &#123; char c; struct StackChar *next; &#125;SC; //StackChar类型的结点SC typedef struct StackFloat &#123; float f; struct StackFloat *next; &#125;SF; //StackFloat类型的结点SF 栈作业.c123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235#include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; #include"栈作业.h" #include&lt;math.h&gt; #include&lt;string.h&gt; /* 构造一个空栈S */ Status initStack(LinkStackPtr S) &#123; S-&gt;top = (StackNodePtr)malloc(sizeof(StackNode)); if(!S-&gt;top) &#123; return FLASE; &#125; S-&gt;top = NULL; S-&gt;count = 0; return TRUE; &#125; /*插入元素e为新的栈顶元素*/ Status push(LinkStackPtr S, ElemType e) &#123; StackNodePtr s= ( StackNodePtr ) malloc (sizeof (StackNode)); if( NULL == s) return FLASE; s-&gt;data = e; s-&gt;next = S-&gt;top;/*把当前的栈顶元素复制给新结点的直接后继*/ S-&gt;top = s; /*把新的结点s赋值给栈顶指针*/ S-&gt;count++; return TRUE; &#125; /*若栈不空，则删除S的栈顶元素，用e返回其值，并返回TRUE；否则返回FALSE*/ Status pop(LinkStackPtr S, ElemType *e) &#123; StackNodePtr p; if(isStackEmpty(*S)) return FLASE; *e = S-&gt;top-&gt;data; p = S-&gt;top; S-&gt;top = S-&gt;top-&gt;next; free(p); S-&gt;count--; return TRUE; &#125; // 栈的判空，若为空，返回TRUE，否则返回FALSE Status isStackEmpty(LinkStack S) &#123; return S.count==0?TRUE:FLASE; &#125; // 获取栈顶元素，并赋值给e，成功返回TRUE,失败返回FALSE Status getTop(LinkStackPtr S, ElemType *e) &#123; if(S-&gt;top == NULL) &#123; return FLASE; &#125; else &#123; *e = S-&gt;top-&gt;data; &#125; return TRUE; &#125; // 销毁栈，成功返回TRUE,失败返回FALSE Status destroyStack(LinkStackPtr S) &#123; StackNodePtr p,q; p = S-&gt;top; while(p) &#123; q = p; p = p-&gt;next; free(q); &#125; S-&gt;count=0; return TRUE; &#125; //输出栈的元素 Status StackTraverse(LinkStack S) &#123; StackNodePtr p; p=S.top; while(p) &#123; printf("%d ",p-&gt;data); p=p-&gt;next; &#125; printf("\n"); return TRUE; &#125; /*********************************************************************** 各个模块的主要功能： *Push(SC *s,char c)：把字符压栈 *Push1(SF *s,float f)：把数值压栈 *Pop(SC *s)：把字符退栈 *Pop1(SF *s)：把数值退栈 Operate(a,theta,b)：根据theta对a和b进行'+' 、'-' 、'*' 、'/' 、'^'操作 In(Test,*TestOp)：若Test为运算符则返回true，否则返回false ReturnOpOrd(op,*TestOp)：若Test为运算符，则返回此运算符在数组中的下标 precede(Aop,Bop)：根据运算符优先级表返回Aop与Bop之间的优先级 EvaluateExpression(*MyExpression)：用算符优先法对算术表达式求值 ***********************************************************************/ SC *Push(SC *s,char c) //SC类型的指针Push，返回p &#123; SC *p=(SC*)malloc(sizeof(SC)); p-&gt;c=c; p-&gt;next=s; return p; &#125; SF *Push1(SF *s,float f) //SF类型的指针Push，返回p &#123; SF *p=(SF*)malloc(sizeof(SF)); p-&gt;f=f; p-&gt;next=s; return p; &#125; SC *Pop(SC *s) //SC类型的指针Pop &#123; SC *q=s; s=s-&gt;next; free(q); return s; &#125; SF *Pop1(SF *s) //SF类型的指针Pop &#123; SF *q=s; s=s-&gt;next; free(q); return s; &#125; float Operate(float a,unsigned char theta, float b) //计算函数Operate &#123; switch(theta) &#123; case '+': return a+b; case '-': return a-b; case '*': return a*b; case '/': return a/b; case '^': return pow(a,b); default : return 0; &#125; &#125; char OPSET[8]=&#123;'+','-','*','/','(',')','#','^'&#125;; Status In(char Test,char *TestOp) &#123; int Find=FLASE,i; for(i=0; i&lt; 8; i++) &#123; if(Test == TestOp[i]) Find= TRUE; &#125; return Find; &#125; Status ReturnOpOrd(char op,char *TestOp) &#123; int i; for(i=0; i&lt; 8; i++) &#123; if (op == TestOp[i]) return i; &#125; &#125; char precede(char Aop, char Bop) &#123; return Prior[ReturnOpOrd(Aop,OPSET)][ReturnOpOrd(Bop,OPSET)]; &#125; float EvaluateExpression(char* MyExpression) &#123; // 算术表达式求值的算符优先算法 // 设OPTR和OPND分别为运算符栈和运算数栈，OP为运算符集合 SC *OPTR=NULL; // 运算符栈，字符元素 SF *OPND=NULL; // 运算数栈，实数元素 char TempData[20]; float Data,a,b; char theta,*c,Dr[]=&#123;'#','\0'&#125;; OPTR=Push(OPTR,'#'); c=strcat(MyExpression,Dr); strcpy(TempData,"\0");//字符串拷贝函数 while (*c!= '#' || OPTR-&gt;c!='#') &#123; if (!In(*c, OPSET)) &#123; Dr[0]=*c; strcat(TempData,Dr); //字符串连接函数 c++; if (In(*c, OPSET)) &#123; Data=atof(TempData); //字符串转换函数(double) OPND=Push1(OPND, Data); strcpy(TempData,"\0"); &#125; &#125; else // 不是运算符则进栈 &#123; switch (precede(OPTR-&gt;c, *c)) &#123; case '&lt;': // 栈顶元素优先级低 OPTR=Push(OPTR, *c); c++; break; case '=': // 脱括号并接收下一字符 OPTR=Pop(OPTR); c++; break; case '&gt;': // 退栈并将运算结果入栈 theta=OPTR-&gt;c;OPTR=Pop(OPTR); b=OPND-&gt;f;OPND=Pop1(OPND); a=OPND-&gt;f;OPND=Pop1(OPND); OPND=Push1(OPND, Operate(a, theta, b)); break; &#125; //switch &#125; &#125; //while return OPND-&gt;f; &#125; //EvaluateExpression Test.c123456789101112131415161718192021222324252627#include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; #include"栈作业.c" int main() &#123; int j; LinkStack s; int e; if(initStack(&amp;s)) for(j=1;j&lt;=10;j++) push(&amp;s,j); printf("栈中元素依次为："); StackTraverse(s); pop(&amp;s,&amp;e); printf("弹出的栈顶元素 e=%d\n",e); printf("栈空否：%d(1:空 0:否)\n",isStackEmpty(s)); getTop(&amp;s,&amp;e); destroyStack(&amp;s); printf("清空栈后，栈空否：%d(1:空 0:否)\n",isStackEmpty(s)); char array[128]; puts("请输入表达式:"); gets(array); puts("该表达式的值为:"); printf("%s\b=%g\n",s,EvaluateExpression(array)); getchar(); return 0; &#125; 总结本次通过对链栈的基本操作的编写，较深刻的理解了栈的结构以及原理，虽然过程磕磕绊绊，但是收获蛮多的。]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>linkstack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言实现链表的基本操作]]></title>
    <url>%2F2016%2F03%2F22%2FC%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E9%93%BE%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[前言本文是用C语言实现的关于链表的增删查改等基本操作。 编译环境dev c++ 下面贴出代码： 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; typedef struct Node &#123; int data; struct Node *next; &#125;Node, *ptr_Node; typedef enum Status &#123; SUCCESS, ERROR &#125;Status; const int MAXN = 1e5+7; const int totalPerLine = 8; int totalNode; ptr_Node create(int *arr, int n); void destroy(ptr_Node head); Status _insert(ptr_Node *head, ptr_Node node, int index); Status _delete(ptr_Node *head, int index, int *data); int search(ptr_Node head, int data); Status edit(ptr_Node head, int index, int *data); void print(ptr_Node head); Status sort(ptr_Node *head); int main() &#123; int i, n; int data[MAXN]; printf("please input n:\n"); scanf("%d", &amp;n); printf("please input %d numbers:\n",n); for(i = 0; i &lt; n; ++i) scanf("%d", &amp;data[i]);//初始化数组； totalNode = n; ptr_Node head = create(data, n);//将数组的内容输入到链表中； printf("Now the List is:\n"); print(head);//输出链表的内容； Node* node = (Node*)calloc(1, sizeof(Node*));//初始化要插入的结点； node-&gt;data = 122344; node-&gt;next = NULL; printf("insert node to 2\n"); _insert(&amp;head, node, 2);//将node插入到第2位之后； print(head);//输出插入后的结果； int k = 0; printf("delete a number:\n"); _delete(&amp;head, 2, &amp;k);//删除第2个数字的后一位； print(head); printf("the delete number is:\n"); printf("%d\n", k);//输出删除后的结果 ； k = search(head, 122344);//在链表中寻找122344； printf("%d\n", k); k = search(head, 12); printf("%d\n", k); printf("edit the (index+1) number:\n"); edit(head, 2, &amp;k); print(head); printf("%d\n", k); printf("the sort numbers are:\n"); sort(&amp;head); print(head); destroy(head); return 0; &#125; ptr_Node create(int *arr, int n) &#123; Node *head = (Node*)calloc(1, sizeof(Node)); if(head == NULL) return NULL; int cur = 0; head-&gt;data = arr[cur++]; Node *curNode = head; while(cur &lt; n)&#123; Node* temp = (Node*)calloc(1, sizeof(Node)); if(temp == NULL) &#123; destroy(head); return NULL; &#125; temp-&gt;data = arr[cur++]; curNode-&gt;next = temp; curNode = temp; &#125; return head; &#125; void destroy(ptr_Node head) &#123; Node *curNode = head; while(curNode != NULL) &#123; Node *temp = curNode-&gt;next; free(curNode); curNode = temp; &#125; &#125; Status _insert(ptr_Node *head, ptr_Node node, int index) &#123; int cur = 1; ptr_Node curNode = *head; while(cur &lt; index) &#123; curNode = curNode-&gt;next; ++cur; &#125; Node* rest = curNode-&gt;next; curNode-&gt;next = node; node-&gt;next = rest; ++totalNode; return SUCCESS; &#125; Status _delete(ptr_Node *head, int index, int *data) &#123; if(index == totalNode) return ERROR; int cur = 1; ptr_Node curNode = *head; while(cur &lt; index) &#123; curNode = curNode-&gt;next; ++cur; &#125; Node *rest = curNode-&gt;next-&gt;next; Node *temp = curNode-&gt;next; curNode-&gt;next = rest; *data = temp-&gt;data; free(temp); --totalNode; return SUCCESS; &#125; int search(ptr_Node head, int data) &#123; int cur = 0; ptr_Node curNode = head; while(curNode-&gt;data != data) &#123; curNode = curNode-&gt;next; if(curNode == NULL) return -1; ++cur; &#125; return cur; &#125; Status edit(ptr_Node head, int index, int *data) &#123; if(index == totalNode) return ERROR; int cur = 0; ptr_Node curNode = head; while(cur &lt; index) &#123; curNode = curNode-&gt;next; ++cur; &#125; printf("%d\n", *data); int temp = curNode-&gt;data; curNode-&gt;data = *data; *data = temp; return SUCCESS; &#125; void print(ptr_Node head) &#123; int curPerLine = 0; ptr_Node curNode = head; while(curNode != NULL) &#123; if(curPerLine == totalPerLine) &#123; puts(""); curPerLine = 0; &#125; printf("%d ", curNode-&gt;data); ++curPerLine; curNode = curNode-&gt;next; &#125; puts(""); &#125; Status sort(ptr_Node *head) &#123; ptr_Node curNodeA = *head; while(curNodeA != NULL) &#123; ptr_Node curNodeB = curNodeA; ptr_Node temp = curNodeA; while(curNodeB != NULL) &#123; if(temp-&gt;data &gt; curNodeB-&gt;data) temp = curNodeB; curNodeB = curNodeB-&gt;next; &#125; int tempData = curNodeA-&gt;data; curNodeA-&gt;data = temp-&gt;data; temp-&gt;data = tempData; curNodeA = curNodeA-&gt;next; &#125; return SUCCESS; &#125; 总结这是第一次做这么长的东西，感觉有点凌乱，有时候找bug找到想哭，不过在这个过程中收获了特别多。]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>linklist</tag>
      </tags>
  </entry>
</search>